<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flashcard App</title>

    <style>
        /* --- Base Styles (Light Mode Defaults) --- */
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px; /* Original padding */
            background-color: #f4f4f4; /* Light background default */
            color: #333; /* Dark text default */
            transition: background-color 0.3s ease, color 0.3s ease; /* Smooth transition */
        }

        h2 {
            color: #333; /* Dark headings */
            transition: color 0.3s ease; /* Smooth transition */
             margin-top: 0; /* Keep h2 margin */
             margin-bottom: 15px;
        }

        .container {
            display: flex; /* Keep flex for side-by-side sections */
            gap: 20px;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
             /* Centralize the container */
            max-width: 1200px; /* Maximum width for the content */
            margin: 20px auto; /* 20px top/bottom margin, auto left/right for centering */
            padding: 0 10px; /* Add some padding inside the container, just in case */
             box-sizing: border-box; /* Include padding in max-width */
        }

        .creation-section, .learning-section {
            flex: 1; /* Share width equally */
            min-width: 300px; /* Minimum width before wrapping */
            border: 1px solid #ccc; /* Light border */
            padding: 20px;
            border-radius: 8px;
            background-color: #fff; /* Light background */
            box-shadow: 0 0 10px rgba(0,0,0,0.05);
            transition: background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;

             /* No display: flex or flex-direction here */
        }

        textarea, input[type="text"], select {
            display: block; /* Still block for structure */
            width: calc(100% - 22px); /* Account for padding and border */
            margin-bottom: 10px;
            padding: 10px;
            border: 1px solid #ccc; /* Light border */
            border-radius: 4px;
            font-size: 1em;
            background-color: #fff;
            color: #333;
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
             box-sizing: border-box; /* Ensure padding/border included */
             width: 100%; /* Fill container width */
        }

         /* Specific width adjustments for folder dropdown and new folder input */
        .folder-controls select, .folder-controls input[type="text"] {
             width: 100%; /* Fill parent width */
             margin-bottom: 10px;
             box-sizing: border-box; /* Include padding/border in width */
             display: block; /* Ensure they stack */
        }
        .folder-controls label {
             display: block; /* Label above the dropdown */
             margin-bottom: 5px;
             font-weight: bold;
             font-size: 0.9em;
             color: #555; /* Slightly lighter dark text */
             transition: color 0.3s ease; /* Smooth transition */
        }
        .folder-controls {
             margin-bottom: 10px; /* Space below folder controls */
        }

        /* Style for folder delete button */
        .folder-controls button {
             margin-top: 5px; /* Space above delete button */
             margin-left: 0;
        }


        /* Make textarea and learning area scroll if content overflows */
        textarea {
            height: auto; /* Auto height based on content/rows */
            min-height: 150px; /* Ensure a minimum height */
            overflow-y: auto; /* Add scrollbar if content overflows */
            margin-bottom: 15px; /* Space below textarea */
        }

        #learningArea {
             /* No flex-grow here */
             overflow-y: auto; /* Add scrollbar if content overflows */
             min-height: 150px; /* Ensure a minimum height */
             margin-top: 20px; /* Keep original margin */
             text-align: center; /* Keep original text alignment */
             display: flex; /* Keep inner flex for card centering */
             flex-direction: column; /* Stack inner contents */
             align-items: center;
             justify-content: flex-start; /* Align to start now that it grows */
        }


        button {
            padding: 10px 15px;
            background-color: #007bff; /* Blue primary button */
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
            font-size: 1em;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        button:hover {
            background-color: #0056b3;
        }

         button:last-child {
             margin-right: 0;
         }

        /* Style for the Import Deck Label (made to look like a button) */
        input[type="file"] {
            display: none;
        }

        .button-like-label {
            display: inline-block;
            padding: 10px 15px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
             margin-bottom: 10px;
            font-size: 1em;
             transition: background-color 0.3s ease, color 0.3s ease;
        }

         .button-like-label:hover {
            background-color: #218838;
        }

        /* Text/Paragraphs related to file management */
        .creation-section p {
            margin-top: 15px;
             margin-bottom: 10px;
             font-weight: bold;
             color: #555;
        }


        /* Flashcard styling */
        .card {
            border: 1px solid #ddd; /* Light border */
            padding: 40px 20px;
            min-height: 150px;
            width: 90%;
            max-width: 500px;
             display: flex;
             align-items: center;
             justify-content: center;
            margin-bottom: 20px; /* Add margin below card */
            background-color: #fff; /* Light background */
            border-radius: 8px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
            font-size: 1.4em;
            white-space: pre-wrap;
            text-align: center;
             transition: background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
        }


         .card-face {
            width: 100%;
            height: 100%;
             display: flex;
             align-items: center;
             justify-content: center;
             padding: 0;
             box-sizing: border-box;
        }

        .hidden {
            display: none;
        }


        .controls, .progress-controls {
            margin-top: 15px;
            text-align: center;
            width: 100%;
        }

        .controls button, .progress-controls button {
            margin: 5px;
        }

         /* Specific styles for basic progress buttons (Mark Known/Needs Review) */
         .progress-controls button {
             padding: 10px 15px; /* Default button size */
             font-size: 1em; /* Default font size */
         }
         /* Ensure Mark Known/Needs Review buttons have appropriate colors */
         #markKnownBtn { background-color: #28a745; } /* Green */
         #markKnownBtn:hover { background-color: #218838; }
         #markNeedsReviewBtn { background-color: #ffc107; color: #333; } /* Yellow/Warning */
         #markNeedsReviewBtn:hover { background-color: #e0a800; }

         /* Style for the Favorite button */
         #toggleFavoriteBtn {
            background-color: #ff7f00; /* Orange */
            margin-left: 5px; /* Space it from the navigation buttons */
            display: inline-block; /* Ensure it sits next to others */
         }
         #toggleFavoriteBtn:hover {
            background-color: #cc6600;
         }
         #toggleFavoriteBtn.is-favorite {
             background-color: #e74c3c; /* Red when favorited */
         }
         #toggleFavoriteBtn.is-favorite:hover {
            background-color: #c0392b;
         }


         .progress-controls {
             border-top: 1px solid #eee; /* Light border */
             padding-top: 15px;
             margin-top: 15px;
              transition: border-color 0.3s ease;
         }


        #progressDisplay {
            margin-top: 10px;
            font-weight: bold;
            color: #555;
             transition: color 0.3s ease;
        }

        /* Optional preview area styles */
        /*
        .preview {
            border: 1px dashed #ccc;
            margin-top: 15px;
            padding: 10px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.9em;
            background-color: #f9f9f9;
            border-radius: 4px;
             transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        */


        /* --- Dark Mode Styles (Override Defaults) --- */
        body.dark-mode {
            background-color: #1e1e1e;
            color: #e0e0e0;
        }

        body.dark-mode h2 {
            color: #cccccc;
        }

        body.dark-mode .creation-section,
        body.dark-mode .learning-section {
            border-color: #333;
            background-color: #2d2d2d;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
        }

        body.dark-mode textarea,
        body.dark-mode input[type="text"],
        body.dark-mode select {
            border-color: #555;
            background-color: #3c3c3c;
            color: #e0e0e0;
        }

         body.dark-mode .folder-controls label {
             color: #b0b0b0;
         }
         body.dark-mode .creation-section p {
              color: #b0b0b0;
         }


        /* Adjust button colors for dark mode if desired, or keep them consistent */
        body.dark-mode button {
             background-color: #556cd6; /* Example: Darker primary button */
        }
        body.dark-mode button:hover {
            background-color: #4257b2;
        }
         /* Override specific button types in dark mode */
        body.dark-mode #markKnownBtn { background-color: #218838; } /* Darker Green */
        body.dark-mode #markKnownBtn:hover { background-color: #19742d; }
        body.dark-mode #markNeedsReviewBtn { background-color: #e0a800; color: #1e1e1e;} /* Darker Yellow */
        body.dark-mode #markNeedsReviewBtn:hover { background-color: #c49000; }

         /* Dark mode favorite button styles */
         body.dark-mode #toggleFavoriteBtn {
             background-color: #d66c2c; /* Darker Orange */
         }
         body.dark-mode #toggleFavoriteBtn:hover {
             background-color: #b35823;
         }
          body.dark-mode #toggleFavoriteBtn.is-favorite {
             background-color: #e74c3c; /* Red stays similar, or slightly adjusted */
         }
         body.dark-mode #toggleFavoriteBtn.is-favorite:hover {
            background-color: #c0392b;
         }


        body.dark-mode .button-like-label {
             background-color: #48a65f;
        }
         body.dark-mode .button-like-label:hover {
             background-color: #3a8c4e;
         }


        body.dark-mode .card {
             border-color: #555;
             background-color: #3c3c3c;
             box-shadow: 2px 2px 5px rgba(0,0,0,0.4);
        }

         body.dark-mode .progress-controls {
             border-top-color: #555;
         }

         body.dark-mode #progressDisplay {
             color: #b0b0b0;
         }

         /* Optional dark mode preview styles */
         /*
         body.dark-mode .preview {
            border-color: #555;
            background-color: #444;
            color: #e0e0e0;
         }
         */


        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                flex-direction: column; /* Stack creation/learning sections vertically */
                gap: 10px; /* Reduce gap on small screens */
                margin: 10px auto; /* Adjust margin on small screens */
                padding: 0 5px; /* Reduce padding inside container */
                max-width: 100%; /* Allow container to be full width */
            }
            .creation-section, .learning-section {
                min-width: auto;
                width: 100%; /* Ensure they take full width */
                padding: 15px; /* Reduce padding */
            }
             /* Adjust button/input stacking for small screens */
             .controls button, .progress-controls button, .file-controls button, .file-controls label,
             .folder-controls select, .folder-controls input[type="text"],
             .folder-controls button, /* Include folder button */
             textarea, input[type="text"]
             {
                 display: block;
                 width: 100%;
                 margin: 5px 0; /* Stack vertically */
                 box-sizing: border-box;
             }
              /* Override specific margins if necessary */
              /*
              button:last-child { margin-right: 0; }
              .button-like-label { margin-right: 0; }
              textarea { margin-bottom: 15px; }
              */

             .creation-section p {
                 text-align: left; /* Align file management text to left */
             }
             .card {
                 width: 100%; /* Card fills section width */
                 padding: 20px 10px; /* Adjust card padding */
                 font-size: 1.2em; /* Slightly smaller font on cards */
             }
             #progressDisplay {
                 text-align: center; /* Keep progress centered */
             }

             /* Adjust button margins for stacking on small screens */
             .controls button, .progress-controls button, .file-controls button, .button-like-label {
                 margin-right: 0 !important; /* Override inline/previous margin */
                 margin-bottom: 5px; /* Space between stacked buttons */
             }
             .controls button:last-child, .progress-controls button:last-child, .file-controls button:last-child {
                 margin-bottom: 0;
             }
             #toggleFavoriteBtn { /* Separate favorite button margin */
                 margin-top: 5px;
                 margin-bottom: 5px;
                 margin-left: 0 !important; /* Ensure left margin is also removed */
             }

        }

        /* Add styles for disabled buttons */
        button:disabled, .button-like-label:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Optional: Style for danger button */
        .danger-button {
             background-color: #dc3545;
        }
        .danger-button:hover {
             background-color: #c82333;
        }
        body.dark-mode .danger-button {
             background-color: #c82333;
        }
        body.dark-mode .danger-button:hover {
             background-color: #a71d2a;
        }

    </style>
</head>
<body class="dark-mode"> <!-- Starting in dark mode -->

    <div class="container">

        <section class="creation-section">
            <h2>Create/Update Deck</h2>
            <textarea id="textInput" rows="10" placeholder="Paste your text here. Use '::' to separate front and back, one card per line. Example: Apple :: A fruit"></textarea>

            <div class="folder-controls">
                <label for="folderSelect">Folder:</label>
                <select id="folderSelect">
                    <option value="">-- Select or Create Folder --</option>
                    <option value="new-folder-option">-- New Folder --</option>
                    <!-- Existing folders populated by JS -->
                </select>
                 <input type="text" id="newFolderNameInput" placeholder="Enter new folder name" style="display: none;">
                 <button id="deleteFolderBtn" class="danger-button">Delete Selected Folder</button>
            </div>

            <input type="text" id="deckNameInput" placeholder="Enter deck name">
            <button id="parseAndSaveBtn">Parse Text & Save/Update Deck</button>

            <p>Manage Files (Single Deck):</p>

             <input type="file" id="importDeckInput" accept=".json">
             <label for="importDeckInput" class="button-like-label">Import Deck File</label>
             <button id="exportCurrentDeckBtn">Export Loaded Deck File</button>
             <!-- Export All Decks Button is not included -->


            <!-- Optional: Preview Area -->
            <!-- <div id="previewArea" class="preview"> -->
                <!-- Parsed cards could be listed here temporarily -->
            <!-- </div> -->


        </section>

        <section class="learning-section">
            <h2>Learn Decks</h2>
            <select id="deckSelect">
                <option value="">-- Select a Deck --</option>
                <!-- Options populated by JavaScript from stored decks, grouped by folder -->
                <!-- Including a special option for Favorites -->
            </select>
            <button id="loadDeckBtn">Load Selected Deck</button>
             <button id="deleteDeckBtn" class="danger-button">Delete Selected Deck</button>

            <div id="learningArea" class="flashcard-area" style="display: none;">
                 <!-- <p id="sessionInfo"></p> --> <!-- Removed session info display -->
                <div id="flashcard" class="card">
                     <!-- Card content will be injected here by JS -->
                    <div id="cardFront" class="card-face front"></div>
                    <div id="cardBack" class="card-face back hidden"></div>
                </div>

                <div class="controls">
                    <button id="showAnswerBtn">Show Answer</button>
                     <!-- Navigation buttons are standard in this mode -->
                     <button id="previousCardBtn">Previous Card</button>
                     <button id="nextCardBtn">Next Card</button>
                     <!-- New button to toggle favorite status -->
                     <button id="toggleFavoriteBtn">Mark as Favorite</button>
                </div>

                 <!-- Removed SRS Rating Controls -->
                 <!--
                 <div class="srs-controls" style="display: none;">
                      <button id="rateAgainBtn" class="again-button">Again</button>
                      <button id="rateGoodBtn" class="good-button">Good</button>
                      <button id="rateEasyBtn" class="easy-button">Easy</button>
                 </div>
                 -->


                <div class="progress-controls">
                     <!-- Basic progress tracking buttons -->
                     <button id="markKnownBtn">Mark as Known</button>
                     <button id="markNeedsReviewBtn">Needs Review</button>
                     <div>
                        <label>
                            <input type="checkbox" id="randomizeCheckbox"> Randomize Order
                        </label>
                     </div>
                     <div id="progressDisplay"></div>
                     <!-- <div id="sessionProgressDisplay"></div> --> <!-- Removed session progress display -->
                </div>
            </div>
        </section>
    </div>

    <script>
        // --- JavaScript Logic ---

        // Get references to HTML elements
        const textInput = document.getElementById('textInput');
        const folderSelect = document.getElementById('folderSelect');
        const newFolderNameInput = document.getElementById('newFolderNameInput');
        const deckNameInput = document.getElementById('deckNameInput');
        const parseAndSaveBtn = document.getElementById('parseAndSaveBtn');
        const deckSelect = document.getElementById('deckSelect');
        const loadDeckBtn = document.getElementById('loadDeckBtn');
        const flashcard = document.getElementById('flashcard');
        const cardFront = document.getElementById('cardFront');
        const cardBack = document.getElementById('cardBack');
        const showAnswerBtn = document.getElementById('showAnswerBtn');
        const nextCardBtn = document.getElementById('nextCardBtn');
        const previousCardBtn = document.getElementById('previousCardBtn');
        const randomizeCheckbox = document.getElementById('randomizeCheckbox');
        const markKnownBtn = document.getElementById('markKnownBtn');
        const markNeedsReviewBtn = document.getElementById('markNeedsReviewBtn');
        const toggleFavoriteBtn = document.getElementById('toggleFavoriteBtn'); // New button
        const progressDisplay = document.getElementById('progressDisplay');
        const importDeckInput = document.getElementById('importDeckInput');
        const exportCurrentDeckBtn = document.getElementById('exportCurrentDeckBtn');
        const deleteDeckBtn = document.getElementById('deleteDeckBtn');
        const learningArea = document.getElementById('learningArea');
        const deleteFolderBtn = document.getElementById('deleteFolderBtn');

        let currentDeck = null; // { name: '...', folder: '...', cards: [{front:'...', back:'...', status:'...', isFavorite: boolean, sourceDeckName?: string, sourceCardFront?: string}], shuffledIndices: [...] }
        let currentCardIndex = 0; // Index within the shuffled/original order
        let isAnswerShowing = false;

        const DECK_STORAGE_KEY = 'flashcardsDecksCollection';
        const UNSORTED_FOLDER_KEY = "__UNSORTED__";
        const ALL_FAVORITES_KEY = "__ALL_FAVORITES__"; // Special key for the Favorites view

         // --- Deck Management (Collection in localStorage) ---

         // Helper to get all decks from localStorage
         function getAllDecksFromStorage() {
             try {
                const decks = JSON.parse(localStorage.getItem(DECK_STORAGE_KEY) || '{}');
                // Ensure basic properties exist for compatibility with older saves
                 for (const deckName in decks) {
                     const deck = decks[deckName];
                     if (!Array.isArray(deck.cards)) {
                          console.warn(`Deck "${deckName}" has invalid cards array.`);
                          delete decks[deckName]; // Remove invalid deck
                          continue;
                     }
                      deck.cards.forEach(card => {
                          if (!card.status) card.status = 'new';
                          if (typeof card.isFavorite !== 'boolean') card.isFavorite = false; // Add default favorite status
                          // Remove old SRS properties if they exist
                          delete card.interval;
                          delete card.repetitions;
                          delete card.easeFactor;
                          delete card.dueDate;
                      });
                      if (typeof deck.folder !== 'string' && typeof deck.folder !== 'undefined') {
                           deck.folder = undefined; // Ensure folder is string or undefined
                      }
                     // Shuffled indices will be handled on load
                 }
                 return decks;
             } catch (e) {
                 console.error("Error parsing decks from localStorage:", e);
                 alert("Error loading your saved decks. Your local storage might be corrupted. Clearing storage to prevent further issues.");
                 localStorage.removeItem(DECK_STORAGE_KEY); // Clear corrupted data
                 return {};
             }
         }

         // Helper to save the entire decks collection to localStorage
         function saveAllDecksToStorage(allDecks) {
              localStorage.setItem(DECK_STORAGE_KEY, JSON.stringify(allDecks));
         }

        // Function to save a single deck (updates the collection in localStorage)
        function saveDeck(deck) {
            const decks = getAllDecksFromStorage(); // Get the latest state first
            decks[deck.name] = deck; // Store/update by name
            saveAllDecksToStorage(decks); // Save the entire updated collection
            // Note: Does NOT repopulate selects or reload currentDeck here.
            // This is handled by explicit calls or events after save/load actions.
        }

        // Function to load a deck by name or the special Favorites collection
        function loadDeck(deckName) {
            const decks = getAllDecksFromStorage();
            let deckToLoad = null;
            let cardsToLoad = [];
            let deckDisplayName = "";
            let isFavoritesView = false;

            if (deckName === ALL_FAVORITES_KEY) {
                 isFavoritesView = true;
                 deckDisplayName = "All Favorite Cards";
                 // Collect all favorite cards from all decks
                 for (const name in decks) {
                     if (decks.hasOwnProperty(name)) {
                         const deck = decks[name];
                         deck.cards.forEach(card => {
                             if (card.isFavorite) {
                                 // For favorites view, add metadata to reference the original card
                                 cardsToLoad.push({
                                     ...card, // Copy existing properties
                                     sourceDeckName: deck.name, // Add source deck name
                                     sourceCardFront: card.front // Add source card front for lookup
                                 });
                             }
                         });
                     }
                 }
                // Create a temporary deck object for the favorites view
                 deckToLoad = {
                     name: ALL_FAVORITES_KEY, // Use the special key as the name
                     displayName: deckDisplayName, // Store a display name
                     folder: undefined, // No folder for favorites collection
                     cards: cardsToLoad
                 };

            } else {
                 // Loading a regular deck
                deckToLoad = decks[deckName];
                if (deckToLoad) {
                    deckDisplayName = deckToLoad.name;
                    cardsToLoad = deckToLoad.cards;
                } else {
                     console.error("Deck not found in storage:", deckName);
                     alert("Error loading deck. It might have been deleted or corrupted.");
                     resetLearningArea();
                     populateDeckSelect(); // Refresh options in case of deletion
                     return;
                }
            }

            if (!deckToLoad || !Array.isArray(deckToLoad.cards) || deckToLoad.cards.length === 0) {
                 alert(`No cards found ${isFavoritesView ? 'in your favorites' : `in deck "${deckName}"`}.`);
                 resetLearningArea(); // Clear learning area
                 populateDeckSelect(); // Refresh options
                 return;
            }


            currentDeck = deckToLoad; // Set the current deck object
            currentCardIndex = 0; // Start at the beginning of the loaded deck's cards

            // Ensure shuffledIndices exists and is correct length, or create/recreate it
            if (!currentDeck.shuffledIndices || currentDeck.shuffledIndices.length !== currentDeck.cards.length || isFavoritesView) {
                 // Always regenerate indices for Favorites view or if missing/mismatch
                 console.warn(`${isFavoritesView ? 'Favorites view' : `Deck "${deckName}"`} shuffled indices mismatch or missing. Re-generating ${isFavoritesView ? 'order' : 'original order'}.`);
                 currentDeck.shuffledIndices = Array.from({length: currentDeck.cards.length}, (_, i) => i);
            }

            // Apply randomization if checked (shuffles the indices)
            if (randomizeCheckbox.checked) {
                 currentDeck.shuffledIndices = shuffleArray(Array.from({length: currentDeck.cards.length}, (_, i) => i)); // Shuffle fresh indices
            } else if (!isFavoritesView){
                 // If not random and not favorites view, ensure it's in original order (0, 1, 2...)
                 // Don't reset favorites view order unless re-shuffling
                 currentDeck.shuffledIndices = Array.from({length: currentDeck.cards.length}, (_, i) => i);
            }
             // Note: Shuffling indices for the temporary favorites deck determines the order for *this session*.
             // This order is NOT saved back to localStorage unless we explicitly save the temporary deck object,
             // which isn't necessary or desirable for the favorites view.

            document.querySelector('.learning-section h2').textContent = `Learn: ${deckDisplayName}`; // Update section title

            displayCurrentCard(); // Display the first card in the chosen order
            updateProgressDisplay();
            learningArea.style.display = 'flex';
            deckSelect.value = deckName; // Keep deck dropdown in sync

             // Enable learning buttons
            showAnswerBtn.disabled = false;
            nextCardBtn.disabled = false;
            previousCardBtn.disabled = false;
            markKnownBtn.disabled = false;
            markNeedsReviewBtn.disabled = false;
            toggleFavoriteBtn.disabled = false; // Enable favorite button

            // Enable export button only if NOT in Favorites view
            exportCurrentDeckBtn.disabled = isFavoritesView;
             // Delete deck button disabled in Favorites view
             deleteDeckBtn.disabled = isFavoritesView;

        }

        function populateFolderSelect() {
             folderSelect.innerHTML = ''; // Clear current options

             const defaultOption = document.createElement('option');
             defaultOption.value = "";
             defaultOption.textContent = "-- Select or Create Folder --";
             folderSelect.appendChild(defaultOption);

             const newFolderOption = document.createElement('option');
             newFolderOption.value = "new-folder-option";
             newFolderOption.textContent = "-- New Folder --";
             folderSelect.appendChild(newFolderOption);

            const decks = getAllDecksFromStorage();
            const folders = new Set();

            Object.values(decks).forEach(deck => {
                if (deck.folder && typeof deck.folder === 'string' && deck.folder.trim()) {
                    folders.add(deck.folder.trim());
                }
            });

            Array.from(folders).sort().forEach(folderName => {
                const option = document.createElement('option');
                option.value = folderName;
                option.textContent = folderName;
                folderSelect.appendChild(option);
            });

            newFolderNameInput.style.display = 'none';
            newFolderNameInput.value = '';

            updateDeleteFolderButtonState();
        }


        function populateDeckSelect() {
            deckSelect.innerHTML = '<option value="">-- Select a Deck --</option>';
            const decks = getAllDecksFromStorage();
            const deckNames = Object.keys(decks);

            const groupedDecks = {};
            const UNSORTED_FOLDER_LABEL = "Unsorted Decks";

            // Add the special "All Favorites" option at the top
            const favoritesOption = document.createElement('option');
            favoritesOption.value = ALL_FAVORITES_KEY;
            favoritesOption.textContent = "⭐ All Favorite Cards";
            deckSelect.appendChild(favoritesOption);


            deckNames.forEach(deckName => {
                const deck = decks[deckName];
                const folder = (deck.folder && typeof deck.folder === 'string' && deck.folder.trim()) || UNSORTED_FOLDER_KEY;
                if (!groupedDecks[folder]) {
                    groupedDecks[folder] = [];
                }
                groupedDecks[folder].push(deck);
            });

            const sortedFolders = Object.keys(groupedDecks).sort((a, b) => {
                if (a === UNSORTED_FOLDER_KEY) return 1;
                if (b === UNSORTED_FOLDER_KEY) return -1;
                return a.localeCompare(b);
            });

            sortedFolders.forEach(folderKey => {
                const folderDecks = groupedDecks[folderKey];
                folderDecks.sort((a, b) => a.name.localeCompare(b.name));

                const optgroup = document.createElement('optgroup');
                optgroup.label = (folderKey === UNSORTED_FOLDER_KEY) ? UNSORTED_FOLDER_LABEL : folderKey;

                folderDecks.forEach(deck => {
                    const option = document.createElement('option');
                    option.value = deck.name;
                    option.textContent = deck.name; // Maybe add card counts later?
                    optgroup.appendChild(option);
                });

                deckSelect.appendChild(optgroup);
            });

            // Try to re-select the current deck if it still exists
             if(currentDeck && decks[currentDeck.name]) {
                 deckSelect.value = currentDeck.name;
             } else if (currentDeck && currentDeck.name === ALL_FAVORITES_KEY) {
                 deckSelect.value = ALL_FAVORITES_KEY;
             }
             else {
                 resetLearningArea(); // Reset if the current deck was deleted
                 deckSelect.value = "";
             }

             const hasDecks = deckNames.length > 0;
             // Load button enabled if *any* option is selected (including Favorites)
             // Delete/Export buttons enabled only if a *regular* deck is selected or loaded
             loadDeckBtn.disabled = false; // Assume something is selectable initially
             deleteDeckBtn.disabled = (deckSelect.value === "" || deckSelect.value === ALL_FAVORITES_KEY);
             exportCurrentDeckBtn.disabled = (currentDeck === null || currentDeck.name === ALL_FAVORITES_KEY);
        }

         function resetLearningArea() {
              currentDeck = null;
              currentCardIndex = 0; // Reset index

              learningArea.style.display = 'none';
              cardFront.textContent = "";
              cardBack.textContent = "";
              progressDisplay.textContent = "";

              document.querySelector('.learning-section h2').textContent = 'Learn Decks'; // Reset title

              showAnswerBtn.disabled = true;
              nextCardBtn.disabled = true; // Navigation buttons disabled
              previousCardBtn.disabled = true; // Navigation buttons disabled
              markKnownBtn.disabled = true; // Basic progress buttons disabled
              markNeedsReviewBtn.disabled = true; // Basic progress buttons disabled
              toggleFavoriteBtn.disabled = true; // Favorite button disabled
              toggleFavoriteBtn.textContent = 'Mark as Favorite'; // Reset text
              toggleFavoriteBtn.classList.remove('is-favorite'); // Reset class


              exportCurrentDeckBtn.disabled = true;
              deleteDeckBtn.disabled = true; // Disable delete button when no deck is loaded
              deckSelect.value = ""; // Reset deck select dropdown
         }

         function updateDeleteFolderButtonState() {
             const selectedValue = folderSelect.value;
             deleteFolderBtn.disabled = (selectedValue === "" || selectedValue === "new-folder-option");
         }


        // --- Creation Logic ---

        parseAndSaveBtn.addEventListener('click', () => {
            const text = textInput.value;
            const deckName = deckNameInput.value.trim();
            let folderName = "";

            const selectedFolderValue = folderSelect.value;
            if (selectedFolderValue === 'new-folder-option') {
                folderName = newFolderNameInput.value.trim();
            } else {
                folderName = selectedFolderValue;
            }

            if (!text || !deckName) {
                alert("Please enter text for cards and a deck name.");
                return;
            }
            if (selectedFolderValue === 'new-folder-option' && !folderName) {
                 alert("Please enter a name for the new folder.");
                 newFolderNameInput.focus();
                 return;
            }


            const existingDecks = getAllDecksFromStorage();
            let overwrite = false;
            if (existingDecks[deckName]) {
                 if (!confirm(`Deck "${deckName}" already exists. Do you want to overwrite it? This will replace the cards and reset progress/favorites for this deck.`)) {
                     return;
                 }
                 overwrite = true;
            }


            const lines = text.split('\n');
            const cards = [];
            lines.forEach(line => {
                const parts = line.match(/^(.*?)::(.*)$/);
                if (parts && parts.length === 3 && parts[1].trim() && parts[2].trim()) {
                     cards.push({
                         front: parts[1].trim(),
                         back: parts[2].trim(),
                         status: 'new', // Start as new
                         isFavorite: false // Default to not favorited
                          // Removed SRS properties: interval, repetitions, easeFactor, dueDate
                      });
                } else if (line.trim() !== '') {
                    console.warn(`Skipping malformed or empty line: "${line.trim()}"`);
                }
            });

            if (cards.length > 0) {
                const newDeck = {
                    name: deckName,
                    folder: folderName || undefined, // Store empty folder as undefined
                    cards: cards,
                    // shuffledIndices are generated on load, not saved with the deck
                };

                saveDeck(newDeck); // Save the new/updated deck

                alert(`Deck "${deckName}" saved/updated with ${cards.length} cards${folderName ? ` in folder "${folderName}"` : ''}.`);
                textInput.value = '';
                 folderSelect.value = "";
                 newFolderNameInput.value = '';
                 newFolderNameInput.style.display = 'none';

                deckNameInput.value = '';

                 populateFolderSelect(); // Refresh dropdowns after saving
                 populateDeckSelect();

                 resetLearningArea(); // Clear learning area - force user to click Load

            } else {
                alert("No valid flashcards found in the text. Ensure each line has a '::' separator and non-empty front/back sides.");
            }
        });

        folderSelect.addEventListener('change', () => {
             if (folderSelect.value === 'new-folder-option') {
                 newFolderNameInput.style.display = 'block';
                 newFolderNameInput.focus();
             } else {
                 newFolderNameInput.style.display = 'none';
                 newFolderNameInput.value = '';
             }
             updateDeleteFolderButtonState();
        });


        // --- Learning Logic ---

        loadDeckBtn.addEventListener('click', () => {
            const selectedDeckName = deckSelect.value;
            if (selectedDeckName) {
                loadDeck(selectedDeckName);
            } else {
                resetLearningArea();
                alert("Please select a deck or 'All Favorite Cards' to load.");
            }
        });

         // Function to display the current card from the shuffled/original order
        function displayCurrentCard() {
            if (!currentDeck || !currentDeck.cards || currentDeck.cards.length === 0 || !currentDeck.shuffledIndices || currentDeck.shuffledIndices.length === 0) {
                 cardFront.textContent = "No cards available in this deck/view.";
                 cardBack.textContent = "";
                 cardBack.classList.add('hidden'); // Hide back
                 cardFront.classList.remove('hidden'); // Ensure front is visible (or just show "No cards")
                 isAnswerShowing = false; // Reset state
                  updateProgressDisplay(); // Clear progress display or show 0/0
                 // Disable card controls if no cards
                 showAnswerBtn.disabled = true;
                 nextCardBtn.disabled = true;
                 previousCardBtn.disabled = true;
                 markKnownBtn.disabled = true;
                 markNeedsReviewBtn.disabled = true;
                 toggleFavoriteBtn.disabled = true; // Disable favorite button
                 toggleFavoriteBtn.textContent = 'Mark as Favorite'; // Reset text
                 toggleFavoriteBtn.classList.remove('is-favorite'); // Reset class
                 return;
            }

            // Ensure currentCardIndex is within bounds
             currentCardIndex = Math.max(0, Math.min(currentCardIndex, currentDeck.shuffledIndices.length - 1));

            // Get the actual card index from the shuffled/ordered indices array
            const actualCardIndex = currentDeck.shuffledIndices[currentCardIndex];
             // Ensure the actual index is valid
             if (actualCardIndex < 0 || actualCardIndex >= currentDeck.cards.length) {
                 console.error("Invalid shuffled index encountered:", actualCardIndex, "Deck:", currentDeck.name);
                 cardFront.textContent = "Error displaying card.";
                 cardBack.textContent = "";
                 cardBack.classList.add('hidden');
                 cardFront.classList.remove('hidden');
                 isAnswerShowing = false;
                 updateProgressDisplay();
                 // Keep controls disabled or handle gracefully? Let's disable.
                 showAnswerBtn.disabled = true;
                 nextCardBtn.disabled = true;
                 previousCardBtn.disabled = true;
                 markKnownBtn.disabled = true;
                 markNeedsReviewBtn.disabled = true;
                 toggleFavoriteBtn.disabled = true;
                 toggleFavoriteBtn.textContent = 'Mark as Favorite';
                 toggleFavoriteBtn.classList.remove('is-favorite');
                 return;
             }

            const card = currentDeck.cards[actualCardIndex];

            cardFront.textContent = card.front;
            cardBack.textContent = card.back;

            // Always show front and hide back when a new card is displayed
            cardFront.classList.remove('hidden'); // Make front visible
            cardBack.classList.add('hidden');     // Hide back
            isAnswerShowing = false; // Reset state to show front

             // Update favorite button state
             updateFavoriteButtonState(card.isFavorite);

             // Show/Enable relevant controls
             showAnswerBtn.disabled = false;
             nextCardBtn.disabled = false;
             previousCardBtn.disabled = false;
             markKnownBtn.disabled = false;
             markNeedsReviewBtn.disabled = false;
             toggleFavoriteBtn.disabled = false; // Enable favorite button


            updateProgressDisplay(); // Update display with current card number and overall progress
        }

        showAnswerBtn.addEventListener('click', () => {
            if (currentDeck && currentDeck.cards.length > 0) {
                if (!isAnswerShowing) {
                    // Currently showing front, show back
                    cardFront.classList.add('hidden');    // Hide front
                    cardBack.classList.remove('hidden'); // Show back
                    isAnswerShowing = true;
                } else {
                    // Currently showing back, show front
                    cardBack.classList.add('hidden');    // Hide back
                    cardFront.classList.remove('hidden'); // Show front
                    isAnswerShowing = false;
                }
            }
        });

         // --- Standard Navigation Button Logic ---

        nextCardBtn.addEventListener('click', () => {
            if (currentDeck && currentDeck.shuffledIndices.length > 0) {
                 currentCardIndex = (currentCardIndex + 1) % currentDeck.shuffledIndices.length; // Loop back to start
                displayCurrentCard(); // Display the next card (resets to front view)
            }
        });

        previousCardBtn.addEventListener('click', () => {
             if (currentDeck && currentDeck.shuffledIndices.length > 0) {
                currentCardIndex = (currentCardIndex - 1 + currentDeck.shuffledIndices.length) % currentDeck.shuffledIndices.length; // Loop back to end
                displayCurrentCard(); // Display the previous card (resets to front view)
            }
        });

        randomizeCheckbox.addEventListener('change', () => {
            if (currentDeck) {
                // Re-shuffle or reset order if randomization state changes while a deck is loaded
                if (randomizeCheckbox.checked) {
                     // Shuffle the *original* indices to get a new random order
                     currentDeck.shuffledIndices = shuffleArray(Array.from({length: currentDeck.cards.length}, (_, i) => i));
                } else {
                     // If not random, reset to the original index order (0, 1, 2...)
                     currentDeck.shuffledIndices = Array.from({length: currentDeck.cards.length}, (_, i) => i);
                }
                currentCardIndex = 0; // Start from the beginning of the new order
                displayCurrentCard(); // Display the first card in the new order
                 // Only save shuffledIndices if it's a regular deck, not the temporary favorites view
                 if (currentDeck.name !== ALL_FAVORITES_KEY) {
                    saveDeck(currentDeck); // Save the whole deck object, including the new shuffledIndices
                 }
            }
             // If no deck is loaded, the change just affects the setting for the *next* loaded deck
        });

        // Basic shuffling function (Fisher-Yates) - creates a new shuffled array
        function shuffleArray(array) {
            const shuffled = [...array]; // Work on a copy
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]]; // Swap elements
            }
            return shuffled;
        }


        // --- Favorite Logic ---

        function updateFavoriteButtonState(isFavorite) {
             if (isFavorite) {
                 toggleFavoriteBtn.textContent = 'Unmark Favorite';
                 toggleFavoriteBtn.classList.add('is-favorite');
             } else {
                 toggleFavoriteBtn.textContent = 'Mark as Favorite';
                 toggleFavoriteBtn.classList.remove('is-favorite');
             }
        }

        toggleFavoriteBtn.addEventListener('click', () => {
             if (!currentDeck || currentDeck.cards.length === 0 || currentDeck.shuffledIndices.length === 0) {
                 return; // Should be disabled if no cards, but safety check
             }

             const actualCardIndex = currentDeck.shuffledIndices[currentCardIndex];
             const card = currentDeck.cards[actualCardIndex];

             // Toggle favorite status
             card.isFavorite = !card.isFavorite;

             // Update button state immediately
             updateFavoriteButtonState(card.isFavorite);

             // Now, update and save the *original* deck where this card resides
             // This is necessary especially if we are in the "All Favorites" view
             let originalDeckName;
             let cardFrontToFind;

             if (currentDeck.name === ALL_FAVORITES_KEY) {
                 // In Favorites view, use the stored source info
                 originalDeckName = card.sourceDeckName;
                 cardFrontToFind = card.sourceCardFront; // Use original front for lookup
                 // If card content was changed in the source deck after favoriting,
                 // this lookup by front might fail. A unique ID would be more robust.
             } else {
                 // In a regular deck view, the source is the current deck
                 originalDeckName = currentDeck.name;
                 cardFrontToFind = card.front; // Use current front for lookup
             }

             if (originalDeckName) {
                 const decks = getAllDecksFromStorage();
                 const originalDeck = decks[originalDeckName];

                 if (originalDeck && Array.isArray(originalDeck.cards)) {
                     // Find the card in the original deck by its front content (assuming front is unique per deck)
                     const originalCard = originalDeck.cards.find(c => c.front === cardFrontToFind);

                     if (originalCard) {
                         // Update the favorite status on the original card object
                         originalCard.isFavorite = card.isFavorite;

                         // Save the original deck back to storage
                         saveDeck(originalDeck);
                         console.log(`Card "${card.front}" in deck "${originalDeckName}" favorite status toggled.`);

                         // If we are in the All Favorites view and just unmarked a card,
                         // should we remove it from the current session? Yes, makes sense.
                         if (currentDeck.name === ALL_FAVORITES_KEY && !card.isFavorite) {
                              // Remove the card from the *current temporary* shuffledIndices and cards list
                              // Find the index of the current *shuffled* card in the shuffledIndices array
                              const currentShuffledIndexInIndices = currentDeck.shuffledIndices.indexOf(actualCardIndex);

                              if (currentShuffledIndexInIndices > -1) {
                                  // Remove the entry from shuffledIndices
                                  currentDeck.shuffledIndices.splice(currentShuffledIndexInIndices, 1);

                                  // Remove the card from the *temporary* cards array (optional but keeps it in sync)
                                  currentDeck.cards.splice(actualCardIndex, 1);

                                  // Adjust subsequent indices in shuffledIndices if necessary (complex!)
                                   // Easier: Re-generate shuffledIndices for the remaining temporary cards
                                  currentDeck.shuffledIndices = Array.from({length: currentDeck.cards.length}, (_, i) => i);
                                   // Re-shuffle if randomization is on
                                   if (randomizeCheckbox.checked) {
                                       currentDeck.shuffledIndices = shuffleArray(currentDeck.shuffledIndices);
                                   }


                                  // Move to the next card in the updated list
                                  if (currentDeck.shuffledIndices.length > 0) {
                                       // Adjust currentCardIndex if the removed card was before it
                                       // Or simply move to the next index, wrap around if needed
                                       currentCardIndex = currentCardIndex % currentDeck.shuffledIndices.length; // Stay within new bounds
                                       displayCurrentCard();
                                  } else {
                                       // No cards left in the favorites session
                                       alert("No more favorite cards left in this view.");
                                       resetLearningArea();
                                       populateDeckSelect(); // Refresh options
                                  }
                                   updateProgressDisplay(); // Update progress for the favorites view
                              } else {
                                   console.error("Error finding current card in shuffled indices array.");
                              }


                         } else {
                              // If not in favorites view, or if favoriting, just update progress display
                              updateProgressDisplay();
                         }


                     } else {
                         console.error(`Could not find original card "${cardFrontToFind}" in deck "${originalDeckName}" to toggle favorite status.`);
                         alert("Error updating favorite status. Could not find the original card.");
                     }
                 } else {
                     console.error(`Could not find original deck "${originalDeckName}" in storage to toggle favorite status.`);
                     alert("Error updating favorite status. Could not find the source deck.");
                 }
             } else {
                 console.error("No source deck information available for this card.");
                 alert("Error updating favorite status.");
             }
        });


        // --- Progress Tracking (Basic Status) ---

        // Helper function to find and update a card in its original deck in localStorage
        function updateCardInOriginalDeck(currentCard, updateFunc) {
             if (!currentCard) return false;

             let originalDeckName;
             let cardFrontToFind; // Using front for lookup

             if (currentDeck.name === ALL_FAVORITES_KEY) {
                 // In Favorites view, use the stored source info
                 originalDeckName = currentCard.sourceDeckName;
                 cardFrontToFind = currentCard.sourceCardFront;
             } else {
                 // In a regular deck view, the source is the current deck
                 originalDeckName = currentDeck.name;
                 cardFrontToFind = currentCard.front;
             }

            if (originalDeckName) {
                const decks = getAllDecksFromStorage();
                const originalDeck = decks[originalDeckName];

                if (originalDeck && Array.isArray(originalDeck.cards)) {
                    const originalCard = originalDeck.cards.find(c => c.front === cardFrontToFind);

                    if (originalCard) {
                        // Apply the update function (e.g., change status)
                        updateFunc(originalCard);
                        // Save the modified deck
                        saveDeck(originalDeck);
                        return true; // Success
                    } else {
                         console.error(`Could not find original card "${cardFrontToFind}" in deck "${originalDeckName}" for update.`);
                    }
                } else {
                     console.error(`Could not find original deck "${originalDeckName}" in storage for update.`);
                }
            } else {
                console.error("No source deck information available for this card for update.");
            }
            return false; // Failure
        }


        markKnownBtn.addEventListener('click', () => {
             if (currentDeck && currentDeck.cards.length > 0 && currentDeck.shuffledIndices.length > 0) {
                 const actualCardIndex = currentDeck.shuffledIndices[currentCardIndex];
                  if (actualCardIndex >= 0 && actualCardIndex < currentDeck.cards.length) {
                     const card = currentDeck.cards[actualCardIndex]; // Get the current card object

                     // Update status in the original deck in storage
                     const updated = updateCardInOriginalDeck(card, (originalCard) => {
                          originalCard.status = 'known';
                          card.status = 'known'; // Update status in the current view as well
                     });

                     if (updated) {
                        updateProgressDisplay();
                        // Optional: Move to the next card automatically after marking
                        // nextCardBtn.click();
                     } else {
                         alert("Error marking card as known.");
                     }
                  }
             }
        });

        markNeedsReviewBtn.addEventListener('click', () => {
             if (currentDeck && currentDeck.cards.length > 0 && currentDeck.shuffledIndices.length > 0) {
                 const actualCardIndex = currentDeck.shuffledIndices[currentCardIndex];
                  if (actualCardIndex >= 0 && actualCardIndex < currentDeck.cards.length) {
                      const card = currentDeck.cards[actualCardIndex]; // Get the current card object

                      // Update status in the original deck in storage
                      const updated = updateCardInOriginalDeck(card, (originalCard) => {
                           originalCard.status = 'needsReview';
                            card.status = 'needsReview'; // Update status in the current view as well
                      });

                     if (updated) {
                        updateProgressDisplay();
                        // Optional: Move to the next card automatically after marking
                        // nextCardBtn.click();
                     } else {
                         alert("Error marking card as 'Needs Review'.");
                     }
                  }
             }
        });


        function updateProgressDisplay() {
            if (currentDeck && currentDeck.cards && currentDeck.cards.length > 0) {

                const totalCardsInView = currentDeck.shuffledIndices ? currentDeck.shuffledIndices.length : 0;
                 const currentCardNumberDisplay = totalCardsInView > 0 ? currentCardIndex + 1 : 0;


                if (currentDeck.name === ALL_FAVORITES_KEY) {
                     // For Favorites view, just show count and current card number
                     const totalFavorites = currentDeck.cards.length; // Total cards currently in the favorite view
                     progressDisplay.innerHTML = `Card: ${currentCardNumberDisplay}/${totalCardsInView}<br>
                                                  Total Favorites: ${totalFavorites}`;
                } else {
                     // For regular decks, show standard progress counts
                     const knownCount = currentDeck.cards.filter(card => card.status === 'known').length;
                      const needsReviewCount = currentDeck.cards.filter(card => card.status === 'needsReview').length;
                      const newCount = currentDeck.cards.filter(card => card.status === 'new').length;
                     const totalCards = currentDeck.cards.length; // Total cards in the original deck
                     const knownPercentage = totalCards > 0 ? ((knownCount / totalCards) * 100).toFixed(0) : 0;


                    progressDisplay.innerHTML = `Card: ${currentCardNumberDisplay}/${totalCardsInView}<br>
                                                Deck Status: ${knownCount} Known / ${needsReviewCount} Review / ${newCount} New<br>
                                                Overall Progress: ${knownPercentage}% Known`;
                }

            } else {
                 progressDisplay.textContent = '';
            }
        }


        // --- File Import/Export (Individual Deck Files) ---

        importDeckInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) {
                return;
            }
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedDeck = JSON.parse(e.target.result);
                    // Basic validation: Check if it looks like a deck object
                    if (importedDeck && typeof importedDeck.name === 'string' && Array.isArray(importedDeck.cards)) {

                         // Clean up and ensure necessary properties for imported cards
                         importedDeck.cards.forEach(card => {
                             // If importing from old format or SRS, set default status/favorite
                             if (!card.status || (card.status !== 'new' && card.status !== 'known' && card.status !== 'needsReview')) {
                                 card.status = 'new';
                             }
                              if (typeof card.isFavorite !== 'boolean') { // Add default favorite status if missing
                                 card.isFavorite = false;
                             }
                             // Remove old SRS properties if they exist in the imported file
                             delete card.interval;
                             delete card.repetitions;
                             delete card.easeFactor;
                             delete card.dueDate;
                             // Also remove temporary source info if present from a favorited export (unlikely but safe)
                             delete card.sourceDeckName;
                             delete card.sourceCardFront;
                         });
                          // Ensure folder property exists (string or undefined)
                         if (typeof importedDeck.folder !== 'string' && typeof importedDeck.folder !== 'undefined') {
                            importedDeck.folder = undefined;
                         }


                         // We don't save shuffledIndices with the deck file itself
                         delete importedDeck.shuffledIndices;
                         delete importedDeck.displayName; // Remove temporary display name if present


                         // Check if a deck with this name already exists and confirm overwrite
                         const existingDecks = getAllDecksFromStorage();
                         if (existingDecks[importedDeck.name]) {
                             if (!confirm(`A deck named "${importedDeck.name}" already exists in your browser. Do you want to overwrite it with the imported file? This will replace the existing deck and its progress/favorites.`)) {
                                 // User cancelled import
                                 event.target.value = ''; // Reset file input
                                 return;
                             }
                         }

                         // Check if the imported deck name is the special favorites key
                         if (importedDeck.name === ALL_FAVORITES_KEY) {
                              alert(`Cannot import a deck with the reserved name "${ALL_FAVORITES_KEY}". Please rename the deck file.`);
                              event.target.value = ''; // Reset file input
                              return;
                         }


                         // Save the imported deck to localStorage
                         saveDeck(importedDeck); // This updates the overall collection in localStorage

                         alert(`Deck "${importedDeck.name}" imported and saved to your browser successfully!`);

                         // Select the newly imported deck in the dropdown
                         // Use a timeout to ensure the populateDeckSelect has finished adding the option
                         setTimeout(() => {
                              deckSelect.value = importedDeck.name;
                             // Don't automatically load, let the user click Load
                             resetLearningArea(); // Ensure current view is cleared
                         }, 50);


                    } else {
                        alert("Invalid flashcard deck file format. File must be a JSON object with 'name' (string) and 'cards' (array) properties.");
                    }
                } catch (error) {
                    alert("Error reading or parsing the file: " + error.message);
                    console.error(error);
                } finally {
                    // Reset the file input so the same file can be selected again if needed
                    event.target.value = '';
                }
            };
            reader.readAsText(file); // Read the file content as text
        });

        // Handle export current deck button click
        exportCurrentDeckBtn.addEventListener('click', () => {
            if (!currentDeck || currentDeck.name === ALL_FAVORITES_KEY) {
                alert("Please load a regular deck first before exporting. The 'All Favorite Cards' view cannot be exported as a single deck file.");
                return;
            }

            // Ensure we export the current state of the deck from localStorage, not just the in-memory object
             const decks = getAllDecksFromStorage();
             const deckToExport = decks[currentDeck.name]; // Get the latest version

             if (!deckToExport) {
                 alert("Could not find the currently loaded deck in storage for export. Please try loading it again.");
                 return;
             }

             // Clean up the deck object for export - remove temporary internal state like shuffledIndices or display name
             const cleanedDeck = JSON.parse(JSON.stringify(deckToExport)); // Deep copy
             delete cleanedDeck.shuffledIndices;
             delete cleanedDeck.displayName; // Should not be on regular decks anyway, but safety

             // Ensure cards don't have temporary source info (shouldn't happen on regular decks, but safety)
             cleanedDeck.cards.forEach(card => {
                 delete card.sourceDeckName;
                 delete card.sourceCardFront;
             });


            const dataStr = JSON.stringify(cleanedDeck, null, 2); // Pretty print JSON
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = `${deckToExport.name.replace(/[^a-z0-9]/gi, '_')}_flashcard_deck.json`; // Sanitize filename and add suffix
            document.body.appendChild(a); // Required for Firefox
            a.click(); // Trigger download
            document.body.removeChild(a); // Clean up
            URL.revokeObjectURL(url); // Free up the object URL

            // Optional: Inform user
            // alert(`Exported deck "${currentDeck.name}".`);
        });


        // --- Delete Deck ---
        deleteDeckBtn.addEventListener('click', () => {
             const selectedDeckName = deckSelect.value;
            if (selectedDeckName && selectedDeckName !== ALL_FAVORITES_KEY) {
                const decks = getAllDecksFromStorage();
                const deckToDelete = decks[selectedDeckName];
                const folderDisplay = deckToDelete && deckToDelete.folder ? ` in folder "${deckToDelete.folder}"` : "";

                if (confirm(`Are you sure you want to delete the deck "${selectedDeckName}"${folderDisplay} from your browser's storage? This action cannot be undone.`)) {
                    delete decks[selectedDeckName];
                    saveAllDecksToStorage(decks);

                    if (currentDeck && currentDeck.name === selectedDeckName) {
                         resetLearningArea(); // Reset if the deleted deck was loaded
                    }

                    alert(`Deck "${selectedDeckName}" deleted.`);
                    populateFolderSelect(); // Refresh dropdowns
                    populateDeckSelect();
                }
            } else if (selectedDeckName === ALL_FAVORITES_KEY) {
                alert("You cannot delete the 'All Favorite Cards' view. This view shows cards marked as favorite across all your decks.");
            }
             else {
                 alert("Please select a deck to delete.");
            }
        });

        // --- Delete Folder ---
        deleteFolderBtn.addEventListener('click', () => {
             const selectedFolder = folderSelect.value;

             if (selectedFolder === "" || selectedFolder === "new-folder-option") {
                 alert("Please select a specific folder to delete.");
                 return;
             }

             const allDecks = getAllDecksFromStorage();
             const decksInFolder = Object.values(allDecks).filter(deck => (deck.folder || '').trim() === selectedFolder.trim());

             if (decksInFolder.length === 0) {
                  if (confirm(`Folder "${selectedFolder}" appears empty. Do you want to delete it anyway?`)) {
                       // To delete an empty folder visually, we just need to repopulate the select boxes.
                       // The data structure implicitly doesn't store empty folders.
                       alert(`Folder "${selectedFolder}" removed from list.`);
                       populateFolderSelect(); // Repopulating removes the empty folder option
                       populateDeckSelect(); // Ensure deck select is also refreshed
                  }
                  return;
             }


             const confirmMessage = `Are you sure you want to delete the folder "${selectedFolder}"?\n\nThis will also delete ${decksInFolder.length} deck(s) within this folder:\n- ${decksInFolder.map(d => d.name).join('\n- ')}\n\nFavorite status and progress for cards in these decks will also be lost.\n\nThis action cannot be undone.`;

             if (confirm(confirmMessage)) {
                  const decksAfterDeletion = {};
                  for (const deckName in allDecks) {
                       const deck = allDecks[deckName];
                       // Keep decks that are NOT in the selected folder
                       if ((deck.folder || '').trim() !== selectedFolder.trim()) {
                           decksAfterDeletion[deckName] = deck;
                       }
                  }

                  saveAllDecksToStorage(decksAfterDeletion);

                  // Check if the currently loaded deck was in the deleted folder
                  // Need to check if currentDeck exists and if its name matches any of the deleted decks
                   if (currentDeck && currentDeck.name !== ALL_FAVORITES_KEY) {
                       const wasCurrentDeckDeleted = decksInFolder.some(deck => deck.name === currentDeck.name);
                       if (wasCurrentDeckDeleted) {
                           resetLearningArea();
                       }
                   }
                   // If in favorites view, resetting is handled implicitly by populateDeckSelect
                   // and the next time favorites are loaded, the deleted cards won't be included.


                  alert(`Folder "${selectedFolder}" and its ${decksInFolder.length} deck(s) deleted.`);
                  populateFolderSelect(); // Refresh dropdowns
                  populateDeckSelect();
             }
        });


        // --- Initialization ---

        document.addEventListener('DOMContentLoaded', () => {
            populateFolderSelect();
            populateDeckSelect();

             resetLearningArea(); // Ensure learning UI is hidden initially
        });

        // Add event listener to deckSelect to update delete/export button state when selection changes
        deckSelect.addEventListener('change', () => {
             const selectedValue = deckSelect.value;
             deleteDeckBtn.disabled = (selectedValue === "" || selectedValue === ALL_FAVORITES_KEY);
             // Export button should technically be disabled here too, but it's better
             // to keep it enabled only when a *loaded* deck is non-favorites.
             // We disable it in loadDeck and resetLearningArea.
             // exportCurrentDeckBtn.disabled = (selectedValue === "" || selectedValue === ALL_FAVORITES_KEY);
        });


    </script>
</body>
</html>
