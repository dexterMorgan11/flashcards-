<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flashcard App</title>

    <style>
        /* --- Base Styles (Light Mode Defaults) --- */
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px; /* Original padding */
            background-color: #f4f4f4; /* Light background default */
            color: #333; /* Dark text default */
            transition: background-color 0.3s ease, color 0.3s ease; /* Smooth transition */
            min-height: 100vh; /* Ensure full viewport height */
            display: flex; /* Center content vertically */
            justify-content: center; /* Center horizontally */
            align-items: center; /* Center vertically */
        }

        h2 {
            color: #333; /* Dark headings */
            transition: color 0.3s ease; /* Smooth transition */
             margin-top: 0; /* Keep h2 margin */
             margin-bottom: 15px;
        }

        h4 { /* Style for new headings within sections */
            margin: 0 0 10px 0;
            color: #555;
            font-size: 1em; /* Default font size */
            font-weight: bold; /* Default font weight */
            transition: color 0.3s ease;
        }

        /* --- Main Menu Styles --- */
        .main-menu {
            display: flex;
            flex-direction: column;
            gap: 30px;
            text-align: center;
            padding: 40px 20px;
            width: 100%;
            max-width: 800px;
            margin: 0 auto; /* Center the menu horizontally */
        }

        .menu-button {
            padding: 30px 20px;
            font-size: 1.5em;
            border: none;
            border-radius: 10px;
            background-color: #000000; /* Changed to black */
            color: white;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .menu-button:hover {
            background-color: #333333; /* Darker shade for hover */
        }

        /* Dark mode for main menu */
        body.dark-mode .menu-button {
            background-color: #000000; /* Black in dark mode too */
        }

        body.dark-mode .menu-button:hover {
            background-color: #333333; /* Darker shade for hover in dark mode */
        }

        .container {
            display: flex;
            flex-direction: column; /* Stack creation/learning sections vertically */
            gap: 20px;
             /* Centralize the container */
            max-width: 1200px; /* Maximum width for the content */
            margin: 20px auto; /* 20px top/bottom margin, auto left/right for centering */
            padding: 0 10px; /* Add some padding inside the container, just in case */
             box-sizing: border-box; /* Include padding in max-width */
            width: 100%; /* Take full width up to max-width */
        }

        /* Hide sections by default */
        .creation-section, .learning-section {
            display: none; /* Hidden by default */
            width: 100%; /* Take full width in column layout */
            /* min-width: 300px; */ /* Not strictly needed now that width is 100% in column */
            border: 1px solid #ccc; /* Light border */
            padding: 20px;
            border-radius: 8px;
            background-color: #fff; /* Light background */
            box-shadow: 0 0 10px rgba(0,0,0,0.05);
            transition: background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;

             /* No display: flex or flex-direction here */
        }

        /* Back to menu button */
        .back-to-menu {
            margin-top: 20px;
            width: 100%;
            padding: 10px 15px;
            background-color: #6c757d; /* Gray */
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s ease;
        }

        .back-to-menu:hover {
            background-color: #5a6268;
        }

        /* Dark mode for back button */
        body.dark-mode .back-to-menu {
            background-color: #5a6268;
        }

        body.dark-mode .back-to-menu:hover {
            background-color: #495057;
        }

        textarea, input[type="text"], select {
            display: block; /* Still block for structure */
            width: calc(100% - 22px); /* Account for padding and border */
            margin-bottom: 10px;
            padding: 10px;
            border: 1px solid #ccc; /* Light border */
            border-radius: 4px;
            font-size: 1em;
            background-color: #fff;
            color: #333;
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
             box-sizing: border-box; /* Ensure padding/border included */
             width: 100%; /* Fill container width */
        }

         /* Specific width adjustments for folder dropdown and new folder input */
        .folder-controls select, .folder-controls input[type="text"] {
             width: 100%; /* Fill parent width */
             margin-bottom: 10px;
             box-sizing: border-box; /* Include padding/border in width */
             display: block; /* Ensure they stack */
        }
        .folder-controls label {
             display: block; /* Label above the dropdown */
             margin-bottom: 5px;
             font-weight: bold;
             font-size: 0.9em;
             color: #555; /* Slightly lighter dark text */
             transition: color 0.3s ease; /* Smooth transition */
        }
        .folder-controls {
             margin-bottom: 10px; /* Space below folder controls */
        }

        /* Style for folder delete button */
        .folder-controls button {
             margin-top: 5px; /* Space above delete button */
             margin-left: 0;
        }


        /* Make textarea and learning area scroll if content overflows */
        textarea {
            height: auto; /* Auto height based on content/rows */
            min-height: 150px; /* Ensure a minimum height */
            overflow-y: auto; /* Add scrollbar if content overflows */
            margin-bottom: 15px; /* Space below textarea */
        }

        #learningArea {
             /* No flex-grow here */
             overflow-y: auto; /* Add scrollbar if content overflows */
             min-height: 150px; /* Ensure a minimum height */
             margin-top: 20px; /* Keep original margin */
             text-align: center; /* Keep original text alignment */
             display: flex; /* Keep inner flex for card centering */
             flex-direction: column; /* Stack inner contents */
             align-items: center;
             justify-content: flex-start; /* Align to start now that it grows */
             width: 100%; /* Make learning area take full width of parent section */
        }


        button {
            padding: 10px 15px;
            background-color: #007bff; /* Blue primary button */
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
            font-size: 1em;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        button:hover {
            background-color: #0056b3;
        }

         button:last-child {
             margin-right: 0;
         }

        /* Style for the Import Deck Label (made to look like a button) */
        input[type="file"] {
            display: none;
        }

        .button-like-label {
            display: inline-block;
            padding: 10px 15px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
             margin-bottom: 10px;
            font-size: 1em;
             transition: background-color 0.3s ease, color 0.3s ease;
        }

         .button-like-label:hover {
            background-color: #218838;
        }

        /* Text/Paragraphs related to file management */
        .creation-section p {
            margin-top: 15px;
             margin-bottom: 10px;
             font-weight: bold;
             color: #555;
        }


        /* Flashcard styling */
        .card {
            border: 1px solid #ddd; /* Light border */
            padding: 20px; /* Adjusted padding to accommodate image/text */
            min-height: 150px;
            width: 100%; /* Make card take full width of #learningArea */
            /* max-width: 500px; */ /* REMOVED to allow card to expand */
             display: flex; /* Use flexbox for vertical stacking of image/text */
             flex-direction: column;
             align-items: center;
             justify-content: flex-start; /* Changed to flex-start to avoid centering empty space */
            margin-bottom: 20px; /* Add margin below card */
            background-color: #fff; /* Light background */
            border-radius: 8px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
            font-size: 1.4em;
            white-space: pre-wrap; /* Allows wrapping but preserves manual line breaks */
            text-align: center;
             transition: background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
             /* user-select state is controlled by JS on card-text-content */
             user-select: none; /* Default disabled on card container */
             -webkit-user-select: none;
             box-sizing: border-box; /* Include padding in width/height */
             overflow-y: auto; /* Add scrollbar if content overflows */
        }


         .card-face {
            width: 100%;
            /* No explicit height here, let content define it */
             display: flex; /* Use flex to stack image and text vertically within the face */
             flex-direction: column;
             align-items: center; /* Center image and text horizontally */
             /* justify-content: center; /* Vertically center image/text within the face - removed to align content to top if overflows */ */
             padding: 0;
             box-sizing: border-box;
             /* Inherit user-select from .card or set here if needed */
             user-select: inherit;
             -webkit-user-select: inherit;
        }

         .card-image-container {
             margin-bottom: 10px; /* Space between image and text */
             /* Ensure image container doesn't take up more space than needed */
             flex-shrink: 0;
             max-width: 100%; /* Ensure image container doesn't exceed face width */
             display: flex; /* Use flex to center image */
             justify-content: center;
         }

         .card-image-container img {
             max-width: 100%; /* Ensure image fits within container */
             max-height: 150px; /* Limit image height in learning view */
             border-radius: 4px;
              /* Ensure user-select doesn't apply to image itself */
             user-select: none;
             -webkit-user-select: none;
             object-fit: contain; /* Ensure image is not distorted */
             cursor: zoom-in; /* Indicate that it's clickable for zoom */
         }

         .card-text-content {
             flex-grow: 1; /* Allow text content to take available space */
             width: 100%; /* Ensure text content takes full width */
             /* Allow text alignment set on .card to apply */
              /* This div is where highlighting happens and user-select is managed */
             overflow-y: auto; /* Add scrollbar for text content if it overflows */
             padding: 0; /* No padding here, padding is on .card */
              box-sizing: border-box;
             white-space: pre-wrap; /* IMPORTANT: Retain whitespace for formatting like bullet points */
             text-align: inherit; /* Inherit text alignment from .card */
         }


        .hidden {
            display: none;
        }


        .controls, .progress-controls, .image-input-learning-container {
            margin-top: 15px; /* Standard margin top */
            text-align: center;
            width: 100%;
        }

        /* Style the controls container to arrange buttons horizontally */
        .controls {
            display: flex; /* Use flexbox to arrange buttons horizontally */
            gap: 10px;     /* Add spacing between buttons */
            flex-wrap: wrap; /* Allow wrapping if screen is too narrow */
            justify-content: center; /* Center the buttons */
        }

         /* Style for the main deck selection checkboxes section */
         .deck-selection-controls, .favorite-filter-controls {
             text-align: left; /* Align controls to the left */
             margin-bottom: 15px; /* Space below these controls */
         }

         /* Style for the container holding checkboxes */
         #deckCheckboxesContainer, #favoriteSourceCheckboxesContainer {
              border: 1px solid #ccc;
              border-radius: 4px;
              padding: 10px;
              max-height: 150px; /* Limit height to make it scrollable */
              overflow-y: auto; /* Add scrollbar */
              margin-bottom: 10px;
              background-color: #fff;
               transition: background-color 0.3s ease, border-color 0.3s ease;
         }
          /* Style for individual checkbox items */
         .checkbox-item { /* Use a more general class name */
             display: flex; /* Align checkbox and label */
             align-items: center;
             margin-bottom: 5px; /* Space between items */
             font-size: 0.95em;
         }
          /* Style for the checkbox itself */
         .checkbox-item input[type="checkbox"] {
             margin-right: 8px; /* Space between checkbox and label */
             flex-shrink: 0; /* Prevent checkbox from shrinking */
             width: auto; /* Override general input width */
             display: inline-block; /* Keep it inline */
         }
         /* Style for the label text */
         .checkbox-item label {
             margin: 0; /* Override default label margins */
             font-weight: normal; /* Override default label weight */
             flex-grow: 1; /* Allow label text to take space */
             cursor: pointer; /* Indicate label is clickable */
             color: #333;
              transition: color 0.3s ease;
         }
         /* Style for group headings within the checkbox list */
         .checkbox-item strong {
              display: block; /* Make heading take full width */
              margin: 5px 0; /* Add margin around headings */
              font-size: 1em;
              color: #555;
               transition: color 0.3s ease;
         }
         /* Special styling for the "All" option if needed */
          .checkbox-item.item-all {
              font-weight: bold;
              margin-bottom: 10px; /* Extra space below "All" */
              padding-bottom: 5px; /* Bottom padding */
              border-bottom: 1px solid #eee; /* Separator line */
               transition: border-color 0.3s ease;
          }
          .checkbox-item.item-folder-heading {
              font-weight: bold;
              margin-top: 10px; /* Space above folder headings */
               margin-bottom: 5px;
               padding-top: 5px;
               border-top: 1px solid #eee;
                transition: border-color 0.3s ease;
          }
          .checkbox-item.item-folder-heading:first-child { /* No top border for the very first heading */
               margin-top: 0;
               padding-top: 0;
               border-top: none;
          }


         /* Specific margin for the image input section */
         .image-input-learning-container {
             margin-top: 20px; /* Extra space above this section */
             padding-top: 15px; /* Space inside with border */
             border-top: 1px solid #eee; /* Separator line */
             transition: border-color 0.3s ease;
         }
         body.dark-mode .learning-section .image-input-learning-container {
             border-top-color: #555;
         }

         body.dark-mode .deck-selection-controls h4,
         body.dark-mode .favorite-filter-controls h4 { /* Dark mode for the new heading */
             color: #b0b0b0;
         }
          body.dark-mode #deckCheckboxesContainer,
          body.dark-mode #favoriteSourceCheckboxesContainer {
               border-color: #555;
               background-color: #3c3c3c;
          }
          body.dark-mode .checkbox-item label {
               color: #e0e0e0;
          }
           body.dark-mode .checkbox-item strong {
                color: #b0b0b0;
           }
           body.dark-mode .checkbox-item.item-all {
                border-bottom-color: #555;
           }
            body.dark-mode .checkbox-item.item-folder-heading {
                 border-top-color: #555;
            }


        /* Progress controls and other buttons remain stacked vertically */
        .progress-controls button, .image-input-learning-container button,
        .deck-selection-controls button, .favorite-filter-controls button { /* Added both section buttons */
            margin: 5px 0; /* Consistent vertical spacing */
            display: block; /* Stack vertically */
            width: 100%;
        }

        /* Controls buttons are arranged horizontally */
        .controls button {
            margin: 0; /* Remove default margins */
            flex: 1 1 auto; /* Allow buttons to grow/shrink as needed */
            display: inline-block; /* Keep buttons inline */
            min-width: auto; /* Allow natural width */
            max-width: fit-content; /* Prevent excessive width */
        }

         /* Specific styles for basic progress buttons (Mark Known/Needs Review) */
         .progress-controls button {
             padding: 10px 15px; /* Default button size */
             font-size: 1em; /* Default font size */
         }
         /* Ensure Mark Known/Needs Review buttons have appropriate colors */
         #markKnownBtn { background-color: #28a745; } /* Green */
         #markKnownBtn:hover { background-color: #218838; }
         #markNeedsReviewBtn { background-color: #ffc107; color: #333; } /* Yellow/Warning */
         #markNeedsReviewBtn:hover { background-color: #e0a800; }

         /* Style for the Favorite button */
         #toggleFavoriteBtn {
            background-color: #ff7f00; /* Orange */
            margin-left: 5px; /* Space it from the navigation buttons */
            display: inline-block; /* Ensure it sits next to others */
         }
         #toggleFavoriteBtn:hover {
            background-color: #cc6600;
         }
         #toggleFavoriteBtn.is-favorite {
             background-color: #e74c3c; /* Red when favorited */
         }
         #toggleFavoriteBtn.is-favorite:hover {
            background-color: #c0392b;
         }

         /* Styles for new highlight action buttons */
         #undoHighlightBtn {
             background-color: #6c757d; /* Gray */
         }
         #undoHighlightBtn:hover {
             background-color: #5a6268;
         }
         #resetHighlightBtn {
             background-color: #dc3545; /* Red/Danger */
         }
         #resetHighlightBtn:hover {
             background-color: #c82333;
         }


         .progress-controls {
             border-top: 1px solid #eee; /* Light border */
             padding-top: 15px;
             margin-top: 15px;
              transition: border-color 0.3s ease;
         }

         /* Style for the new Reset Status button */
         #resetStatusBtn {
             background-color: #dc3545; /* Danger color */
         }
         #resetStatusBtn:hover {
            background-color: #c82333; /* Darker danger */
         }
         body.dark-mode #resetStatusBtn {
             background-color: #c82333;
         }
         body.dark-mode #resetStatusBtn:hover {
             background-color: #a71d2a;
         }


        #progressDisplay {
            margin-top: 10px;
            font-weight: bold;
            color: #555;
             transition: color 0.3s ease;
        }


        /* --- Highlighting Styles --- */
        /* Style for **syntax** processed highlighting */
        .syntax-highlight {
             background-color: #ffff00; /* Bright yellow */
             padding: 0 2px;
             border-radius: 2px;
             color: #000; /* Ensure text is black for readability */
             /* Prevents user-select interfering with highlighting itself */
             user-select: text;
             -webkit-user-select: text;
        }

         /* Style for user-applied highlighting - NOW YELLOW */
         .user-highlight {
            background-color: #ffff00; /* Bright yellow */ /* Changed from light blue */
            padding: 0 2px;
            border-radius: 2px;
            color: #000; /* Ensure text is black */
             user-select: text;
             -webkit-user-select: text;
        }

        /* Dark mode highlight adjustment */
        body.dark-mode .syntax-highlight {
            background-color: #ffd700; /* Darker yellow for dark mode */
            color: #000; /* Keep text black for contrast */
        }

         body.dark-mode .user-highlight {
             background-color: #ffd700; /* Darker yellow in dark mode */ /* Changed from royal blue */
             color: #000; /* Ensure text is black for readability on yellow */ /* Changed from lighter text */
         }

        /* Highlighter button styles */
        #highlighterBtn {
            background-color: #ffff00; /* Yellow background */
            color: #000; /* Black text */
        }

        #highlighterBtn.active {
            background-color: #ffd700; /* Darker yellow when active */
            box-shadow: 0 0 5px rgba(255, 215, 0, 0.7); /* Glow effect when active */
        }

        body.dark-mode #highlighterBtn {
            background-color: #ffd700; /* Darker yellow for dark mode */
            color: #000;
        }

        body.dark-mode #highlighterBtn.active {
            background-color: #ffcc00; /* Even darker yellow when active in dark mode */
            box-shadow: 0 0 5px rgba(255, 204, 0, 0.7); /* Glow effect when active */
        }


        /* --- Dark Mode Styles (Override Defaults) --- */
        body.dark-mode {
            background-color: #1e1e1e;
            color: #e0e0e0;
        }

        body.dark-mode h2 {
            color: #cccccc;
        }

        body.dark-mode h4 { /* Dark mode for new headings */
            color: #b0b0b0;
        }


        body.dark-mode .creation-section,
        body.dark-mode .learning-section {
            border-color: #333;
            background-color: #2d2d2d;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
        }

        body.dark-mode textarea,
        body.dark-mode input[type="text"],
        body.dark-mode select {
            border-color: #555;
            background-color: #3c3c3c;
            color: #e0e0e0;
        }

         body.dark-mode .folder-controls label {
             color: #b0b0b0;
         }
         body.dark-mode .creation-section p {
              color: #b0b0b0;
         }

         body.dark-mode #deckCheckboxesContainer,
         body.dark-mode #favoriteSourceCheckboxesContainer {
               border-color: #555;
               background-color: #3c3c3c;
          }
          body.dark-mode .checkbox-item label {
               color: #e0e0e0;
          }
           body.dark-mode .checkbox-item strong {
                color: #b0b0b0;
           }
           body.dark-mode .checkbox-item.item-all {
                border-bottom-color: #555;
           }
            body.dark-mode .checkbox-item.item-folder-heading {
                 border-top-color: #555;
            }


        /* Adjust button colors for dark mode if desired, or keep them consistent */
        body.dark-mode button {
             background-color: #556cd6; /* Example: Darker primary button */
        }
        body.dark-mode button:hover {
            background-color: #4257b2;
        }
         /* Override specific button types in dark mode */
        body.dark-mode #markKnownBtn { background-color: #218838; } /* Darker Green */
        body.dark-mode #markKnownBtn:hover { background-color: #19742d; }
        body.dark-mode #markNeedsReviewBtn { background-color: #e0a800; color: #1e1e1e;} /* Darker Yellow */
        body.dark-mode #markNeedsReviewBtn:hover { background-color: #c49000; }

         /* Dark mode favorite button styles */
         body.dark-mode #toggleFavoriteBtn {
             background-color: #d66c2c; /* Darker Orange */
         }
         body.dark-mode #toggleFavoriteBtn:hover {
             background-color: #b35823;
         }
          body.dark-mode #toggleFavoriteBtn.is-favorite {
             background-color: #e74c3c; /* Red stays similar, or slightly adjusted */
         }
         body.dark-mode #toggleFavoriteBtn.is-favorite:hover {
            background-color: #c0392b;
         }

         /* Dark mode styles for new highlight action buttons */
         body.dark-mode #undoHighlightBtn {
             background-color: #5a6268; /* Darker Gray */
         }
         body.dark-mode #undoHighlightBtn:hover {
             background-color: #495056;
         }
         body.dark-mode #resetHighlightBtn {
             background-color: #dc3545; /* Red/Danger */
         }
         body.dark-mode #resetHighlightBtn:hover {
             background-color: #c82333;
         }

         /* Dark mode style for the new Reset Status button */
         body.dark-mode #resetStatusBtn {
             background-color: #c82333;
         }
         body.dark-mode #resetStatusBtn:hover {
             background-color: #a71d2a;
         }


        body.dark-mode .button-like-label {
             background-color: #48a65f;
        }
         body.dark-mode .button-like-label:hover {
             background-color: #3a8c4e;
         }


        body.dark-mode .card {
             border-color: #555;
             background-color: #3c3c3c;
             box-shadow: 2px 2px 5px rgba(0,0,0,0.4);
        }

         body.dark-mode .progress-controls {
             border-top-color: #555;
         }

         body.dark-mode #progressDisplay {
             color: #b0b0b0;
        }

         /* --- Image handling styles (Creation Section) --- */
         /* (These were largely copied from the previous version) */
         .creation-section .drop-zone {
             border: 2px dashed #ccc;
             border-radius: 4px;
             padding: 15px; /* Increased padding */
             text-align: center;
             margin-bottom: 10px;
             transition: border-color 0.3s ease, background-color 0.3s ease;
             cursor: pointer; /* Indicate it's interactive */
         }

         .creation-section .drop-zone.active {
             border-color: #007bff;
             background-color: rgba(0, 123, 255, 0.1);
         }

         .creation-section .drop-zone p {
             margin: 0;
             font-weight: normal; /* Override p style */
             color: #555; /* Lighter text */
             display: flex; /* Use flex to align button */
             align-items: center;
             justify-content: center;
             gap: 10px; /* Space between text and button */
             flex-wrap: wrap; /* Allow wrapping on small screens */
         }
         body.dark-mode .creation-section .drop-zone p {
              color: #b0b0b0;
         }
         .creation-section .drop-zone p button { /* Style the paste button inside p */
             padding: 5px 10px;
             font-size: 0.9em;
             margin: 0; /* Reset button margins */
             display: inline-block; /* Keep inline */
         }


         .creation-section .image-preview-container { /* Container for image in drop zone */
             margin-top: 10px;
             margin-bottom: 0;
             max-height: 200px; /* Limit preview height */
             overflow: hidden; /* Hide parts of image exceeding max height */
             display: flex; /* Center image horizontally */
             justify-content: center;
         }

         .creation-section .image-preview-container img { /* Image style in drop zone preview */
             max-width: 100%; /* Ensure image fits container */
             max-height: 200px; /* Limit preview height */
             border-radius: 4px;
             box-shadow: 0 2px 4px rgba(0,0,0,0.1);
             object-fit: contain; /* Ensure image is not distorted */
         }
          body.dark-mode .creation-section .image-preview-container img {
               box-shadow: 0 2pk 4px rgba(0,0,0,0.3);
          }


         .creation-section .image-controls {
             display: flex;
             justify-content: center; /* Center the controls below the image */
             margin-top: 10px; /* Space above controls */
         }

         .creation-section .image-controls button {
             padding: 5px 10px;
             font-size: 0.9em;
             margin: 0 5px; /* Space between buttons */
         }
          .creation-section .image-controls button:first-child { margin-left: 0; }
          .creation-section .image-controls button:last-child { margin-right: 0; }


         /* --- Image Handling Styles (Learning Section) --- */
         .learning-section .image-input-learning-container {
             width: 100%; /* Take full width of learning section */
             display: flex;
             flex-direction: column;
             align-items: center;
             margin-top: 20px; /* Space above image inputs */
             padding-top: 15px;
             border-top: 1px solid #eee; /* Separator line */
              transition: border-color 0.3s ease;
         }


         .learning-section .image-input-learning-container h4 {
              margin: 0 0 10px 0; /* Space below heading */
              color: #555; /* Lighter color */
               transition: color 0.3s ease;
         }
         body.dark-mode .learning-section .image-input-learning-container h4 {
              color: #b0b0b0;
         }

          .learning-section .image-input-learning-container .drop-zone {
             width: 90%; /* Match card width */
             max-width: 500px; /* Match card max-width */
             border: 2px dashed #ccc;
             border-radius: 4px;
             padding: 15px;
             text-align: center;
             margin-bottom: 10px; /* Space between drop zones */
             transition: border-color 0.3s ease, background-color 0.3s ease;
             cursor: pointer;
          }
          .learning-section .image-input-learning-container .drop-zone.active {
               border-color: #007bff;
               background-color: rgba(0, 123, 255, 0.1);
          }
          body.dark-mode .learning-section .image-input-learning-container .drop-zone {
               border-color: #555;
          }
           body.dark-mode .learning-section .image-input-learning-container .drop-zone.active {
               border-color: #556cd6;
               background-color: rgba(85, 108, 214, 0.2);
           }

         .learning-section .image-input-learning-container .drop-zone p {
             margin: 0;
             font-weight: normal;
             color: #555;
              transition: color 0.3s ease;
              display: flex;
              align-items: center;
              justify-content: center;
              gap: 10px;
              flex-wrap: wrap;
         }
          body.dark-mode .learning-section .image-input-learning-container .drop-zone p {
               color: #b0b0b0;
          }

          .learning-section .image-input-learning-container .drop-zone p button { /* Style the paste button */
               padding: 5px 10px;
               font-size: 0.9em;
               margin: 0;
               display: inline-block;
          }


         .learning-section .image-input-learning-container .image-preview-container { /* Preview image in learning section inputs */
             margin-top: 10px;
             margin-bottom: 0;
             max-height: 120px; /* Smaller preview height */
             overflow: hidden;
             display: flex;
             justify-content: center;
         }
         .learning-section .image-input-learning-container .image-preview-container img {
              max-width: 100%;
              max-height: 120px; /* Match container max-height */
              border-radius: 4px;
              box-shadow: 0 1px 3px rgba(0,0,0,0.1);
              object-fit: contain;
         }
          body.dark-mode .learning-section .image-input-learning-container .image-preview-container img {
               box-shadow: 0 1px 3px rgba(0,0,0,0.3);
          }


         .learning-section .image-input-learning-container .image-controls {
             display: flex;
             justify-content: center;
             margin-top: 10px;
         }
         .learning-section .image-input-learning-container .image-controls button {
              padding: 5px 10px;
              font-size: 0.9em;
              margin: 0 5px;
         }
          .learning-section .image-input-learning-container .image-controls button:first-child { margin-left: 0; }
          .learning-section .image-input-learning-container .image-controls button:last-child { margin-right: 0; }


         /* --- Modal Styles for Image Zoom --- */
         .modal {
             display: none; /* Hidden by default */
             position: fixed; /* Stay in place */
             z-index: 1000; /* Sit on top */
             left: 0;
             top: 0;
             width: 100%; /* Full width */
             height: 100%; /* Full height */
             overflow: auto; /* Enable scroll if needed */
             background-color: rgba(0,0,0,0.9); /* Black background with opacity */
             align-items: center; /* Center vertically */
             justify-content: center; /* Center horizontally */
             flex-direction: column; /* Stack image and caption */
             padding: 20px; /* Add some padding */
             box-sizing: border-box;
         }

         .modal.visible {
             display: flex; /* Show when active */
         }

         .modal-content {
             margin: auto; /* Center the image */
             display: block;
             max-width: 95%; /* Max width */
             max-height: 95%; /* Max height */
             object-fit: contain; /* Ensure image fits without distortion */
         }

         #modalCaption {
             margin-top: 15px;
             display: block;
             color: #ccc;
             font-size: 1.2em;
             text-align: center;
             max-width: 95%;
         }

         /* Close button */
         .modal-close {
             position: absolute;
             top: 15px;
             right: 35px;
             color: #f1f1f1;
             font-size: 40px;
             font-weight: bold;
             transition: 0.3s;
             cursor: pointer;
             z-index: 1001; /* Ensure close button is above image */
         }

         .modal-close:hover,
         .modal-close:focus {
             color: #bbb;
             text-decoration: none;
             cursor: pointer;
         }

         /* Dark mode for modal */
         body.dark-mode .modal-close {
             color: #ccc;
         }
         body.dark-mode .modal-close:hover,
         body.dark-mode .modal-close:focus {
             color: #aaa;
         }
         body.dark-mode #modalCaption {
             color: #bbb;
         }


        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                /* flex-direction: column; */ /* Removed - now global */
                gap: 10px; /* Reduce gap on small screens */
                margin: 10px auto; /* Adjust margin on small screens */
                padding: 0 5px; /* Reduce padding inside container */
                max-width: 100%; /* Allow container to be full width */
            }
            .creation-section, .learning-section {
                min-width: auto;
                /* width: 100%; */ /* Removed - now global */
                padding: 15px; /* Reduce padding */
            }
             /* Adjust button/input stacking for small screens */
             .progress-controls button, .file-controls button, .file-controls label,
             .folder-controls select, .folder-controls input[type="text"],
             .folder-controls button, /* Include folder button */
             textarea, input[type="text"],
             .deck-selection-controls button, .favorite-filter-controls button /* Both section buttons */
             {
                 display: block;
                 width: 100%;
                 margin: 5px 0; /* Stack vertically */
                 box-sizing: border-box;
             }

             /* Keep controls buttons horizontal but adjust for small screens */
             .controls {
                 gap: 5px; /* Reduce gap on small screens */
             }

             .controls button {
                 flex: 1 1 auto; /* Allow more flexible sizing on small screens */
                 font-size: 0.9em; /* Slightly smaller font on small screens */
                 padding: 8px 10px; /* Slightly smaller padding */
             }
              /* Override specific margins if necessary */
              /*
              button:last-child { margin-right: 0; }
              .button-like-label { margin-right: 0; }
              textarea { margin-bottom: 15px; }
              */
             /* Checkbox items should NOT stack as full width buttons */
             .checkbox-item {
                 display: flex; /* Maintain inline-flex like behavior */
                 width: auto; /* Prevent taking full width */
                 margin: 0 0 5px 0; /* Adjust margin */
             }
             .checkbox-item input[type="checkbox"] {
                  width: auto !important; /* Ensure checkbox isn't forced to 100% */
                  display: inline-block !important;
             }
             .checkbox-item label {
                  width: auto !important; /* Ensure label isn't forced to 100% */
                  display: inline-block !important;
             }
             .checkbox-item strong { /* Headings should still take width */
                 display: block !important;
                 width: 100% !important;
             }


             .creation-section p {
                 text-align: left; /* Align file management text to left */
             }
             .card {
                 width: 100%; /* Card fills section width */
                 padding: 20px 10px; /* Adjust card padding */
                 font-size: 1.2em; /* Slightly smaller font on cards */
             }
              .card-image-container img { /* Adjust image height on small screens */
                  max-height: 120px;
              }
             #progressDisplay {
                 text-align: center; /* Keep progress centered */
             }

             /* Adjust button margins for stacking on small screens */
             .controls button, .progress-controls button, .file-controls button, .button-like-label,
             .deck-selection-controls button, .favorite-filter-controls button /* Both section buttons */
             {
                 margin-right: 0 !important; /* Override inline/previous margin */
                 margin-bottom: 5px; /* Space between stacked buttons */
             }
             .controls button:last-child, .progress-controls button:last-child, .file-controls button:last-child {
                 margin-bottom: 0;
             }
             #toggleFavoriteBtn { /* Separate favorite button margin */
                 margin-top: 5px;
                 margin-bottom: 5px;
                 margin-left: 0 !important; /* Ensure left margin is also removed */
             }
             /* Adjust new highlight buttons for stacking */
             #undoHighlightBtn, #resetHighlightBtn {
                 margin-right: 0 !important;
                 margin-bottom: 5px;
             }

             /* Image controls stacking on small screens (Creation & Learning) */
              .creation-section .image-controls,
              .learning-section .image-input-learning-container .image-controls
               {
                  flex-direction: column;
                  align-items: center;
              }
             .creation-section .image-controls button,
             .learning-section .image-input-learning-container .image-controls button
              {
                  width: 100%;
                  margin: 5px 0; /* Stack vertically */
             }

            /* Stack paste button and text in drop zones */
            .drop-zone p {
                 flex-direction: column;
                 gap: 5px;
            }
            .drop-zone p button {
                margin: 0 !important; /* Ensure no residual margin */
            }

            /* Ensure drop zones stack */
            .learning-section .image-input-learning-container .drop-zone {
                 width: 100%; /* Use full width on small screens */
            }

            /* Responsive adjustments for modal close button */
            .modal-close {
                top: 10px;
                right: 20px;
                font-size: 30px;
            }
             #modalCaption {
                font-size: 1em;
             }
        }

        /* Add styles for disabled buttons */
        button:disabled, .button-like-label:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Optional: Style for danger button */
        .danger-button {
             background-color: #dc3545;
        }
        .danger-button:hover {
             background-color: #c82333;
        }
        body.dark-mode .danger-button {
             background-color: #c82333;
        }
        body.dark-mode .danger-button:hover {
             background-color: #a71d2a;
        }

    </style>
</head>
<body class="dark-mode"> <!-- Starting in dark mode -->

    <div class="container">
        <!-- Main Menu -->
        <div class="main-menu" id="mainMenu">
            <h2>Flashcard App</h2>
            <button class="menu-button" onclick="showCreation()">Create Flashcards</button>
            <button class="menu-button" onclick="showLearning()">Start Learning Session</button>
            <button class="menu-button" id="toggleDarkModeBtn">Toggle Dark Mode</button>
        </div>

        <section class="creation-section" id="creationSection">
            <h2>Create/Update Deck</h2>

            <!-- Option to select an existing deck to add to -->
            <div class="add-to-deck-controls">
                <label for="addDeckSelect">Add to Existing Deck:</label>
                <select id="addDeckSelect">
                    <option value="">-- Select Deck to Add To --</option>
                    <!-- Existing decks populated by JS -->
                </select>
            </div>
            <p style="text-align: center; font-weight: normal; margin-bottom: 10px; color: #777;">OR</p> <!-- Separator text -->
            <input type="text" id="deckNameInput" placeholder="Enter NEW deck name">


            <!-- Front side image drop zone (Creation) -->
            <div id="creationFrontImageDropZone" class="drop-zone">
                <p>Drag & drop image for front side or <button id="creationFrontImagePasteBtn" type="button">Paste from clipboard</button></p>
                <div id="creationFrontImagePreviewContainer" class="image-preview-container"></div>
                <div class="image-controls" id="creationFrontImageControls" style="display: none;">
                    <button id="removeCreationFrontImageBtn" class="danger-button" type="button">Remove Image</button>
                </div>
            </div>

            <textarea id="textInput" rows="10" placeholder="Paste new cards here. Separate front and back using '::'. One card per line or use multiline format:
Front content::
- Back point 1
- Back point 2
- etc."></textarea>

            <!-- Back side image drop zone (Creation) -->
            <div id="creationBackImageDropZone" class="drop-zone">
                <p>Drag & drop image for back side or <button id="creationBackImagePasteBtn" type="button">Paste from clipboard</button></p>
                 <div id="creationBackImagePreviewContainer" class="image-preview-container"></div>
                <div class="image-controls" id="creationBackImageControls" style="display: none;">
                    <button id="removeCreationBackImageBtn" class="danger-button" type="button">Remove Image</button>
                </div>
            </div>


            <div class="folder-controls">
                <label for="folderSelect">Folder (for NEW decks):</label>
                <select id="folderSelect">
                    <option value="">-- Select or Create Folder --</option>
                    <option value="new-folder-option">-- New Folder --</option>
                    <!-- Existing folders populated by JS -->
                </select>
                 <input type="text" id="newFolderNameInput" placeholder="Enter new folder name" style="display: none;">
                 <button id="deleteFolderBtn" class="danger-button" type="button">Delete Selected Folder</button>
            </div>

            <button id="parseAndSaveBtn" type="button">Process Input</button>

            <button class="back-to-menu" onclick="goBack()">Back to Menu</button>

            <p>Manage Files (Single Deck):</p>

             <input type="file" id="importDeckInput" accept=".json">
             <label for="importDeckInput" class="button-like-label">Import Deck File</label>
             <button id="exportCurrentDeckBtn" type="button" disabled>Export Loaded Deck File</button> <!-- Disabled by default -->


        </section>

        <section class="learning-section" id="learningSection">
            <h2>Learn Decks</h2>
            <!-- Main Deck Selection Checkboxes (Replaced Select) -->
            <div class="deck-selection-controls">
                 <h4>Select Decks to Load:</h4>
                 <div id="deckCheckboxesContainer">
                     <!-- Deck checkboxes populated by JS -->
                 </div>
                 <button id="loadDeckBtn" type="button" disabled>Load Selected Deck(s)</button> <!-- Disabled by default -->
                 <button id="deleteDeckBtn" class="danger-button" type="button" disabled>Delete Selected Deck(s)</button> <!-- Disabled by default -->
            </div>


            <!-- New Favorite Filter Controls -->
            <div class="favorite-filter-controls">
                 <h4>Load Favorite Cards from:</h4>
                <div id="favoriteSourceCheckboxesContainer">
                    <!-- Favorite source checkboxes populated by JS -->
                </div>
                 <button id="loadFilteredFavoritesBtn" type="button" disabled>Load Favorite Cards</button> <!-- Disabled by default -->
            </div>


            <div id="learningArea" class="flashcard-area" style="display: none;">
                <div id="flashcard" class="card">
                     <!-- Card content will be injected here by JS -->
                    <div id="cardFront" class="card-face front">
                        <!-- Image and Text content will be dynamically added here by JS -->
                        <div class="card-image-container"></div>
                        <div class="card-text-content"></div>
                    </div>
                    <div id="cardBack" class="card-face back hidden">
                        <!-- Image and Text content will be dynamically added here by JS -->
                        <div class="card-image-container"></div>
                        <div class="card-text-content"></div>
                    </div>
                </div>


                <div class="controls">
                    <button id="showAnswerBtn" type="button">Show Answer</button>
                    <button id="markKnownBtn" type="button" disabled>Mark Known</button> <!-- Moved here from progress-controls -->
                     <!-- Navigation buttons are standard in this mode -->
                     <button id="previousCardBtn" type="button">Previous Card</button>
                     <button id="nextCardBtn" type="button">Next Card</button>
                     <!-- New button to toggle favorite status -->
                     <button id="toggleFavoriteBtn" type="button" disabled>Mark as Favorite</button> <!-- Disabled by default -->
                     <!-- New highlighter button -->
                     <button id="highlighterBtn" type="button" disabled>Highlighter</button> <!-- Disabled by default -->
                     <!-- New buttons for undo/reset highlight -->
                     <button id="undoHighlightBtn" disabled type="button">Undo Highlight</button>
                     <button id="resetHighlightBtn" disabled type="button">Reset Highlight</button>
                </div>


                <div class="progress-controls">
                     <!-- Basic progress tracking buttons -->
                     <button id="markNeedsReviewBtn" type="button" disabled>Mark Needs Review</button> <!-- Disabled by default -->
                     <!-- New button to reset status to New -->
                     <button id="resetStatusBtn" class="danger-button" type="button" disabled>Reset All to New</button> <!-- Disabled by default -->
                     <div>
                        <label>
                            <input type="checkbox" id="randomizeCheckbox"> Randomize Order
                        </label>
                     </div>
                     <div id="progressDisplay"></div>
                </div>

                 <!-- --- Image Input Controls for Learning Section --- -->
                 <div class="image-input-learning-container" style="display: none;"> <!-- Hidden by default -->
                      <h4>Add/Update Card Images (Current Deck Only)</h4> <!-- Clarified text -->
                      <!-- Front side image input (Learning) -->
                       <div id="learningFrontImageDropZone" class="drop-zone">
                           <p>Front Image: Drag & drop or <button id="learningFrontImagePasteBtn" type="button">Paste from clipboard</button></p>
                           <div id="learningFrontImagePreviewContainer" class="image-preview-container"></div>
                           <div class="image-controls" id="learningFrontImageControls" style="display: none;">
                               <button id="removeLearningFrontImageBtn" class="danger-button" type="button">Remove Front Image</button>
                           </div>
                       </div>
                      <!-- Back side image input (Learning) -->
                       <div id="learningBackImageDropZone" class="drop-zone">
                           <p>Back Image: Drag & drop or <button id="learningBackImagePasteBtn" type="button">Paste from clipboard</button></p>
                           <div id="learningBackImagePreviewContainer" class="image-preview-container"></div>
                           <div class="image-controls" id="learningBackImageControls" style="display: none;">
                               <button id="removeLearningBackImageBtn" class="danger-button" type="button">Remove Back Image</button>
                           </div>
                       </div>
                 </div>
                 <!-- --- End Image Input Controls for Learning Section --- -->

            </div>

            <button class="back-to-menu" onclick="goBack()">Back to Menu</button>
        </section>
    </div>

    <!-- The Modal for image zoom -->
    <div id="imageModal" class="modal">
      <span class="modal-close">&times;</span>
      <img class="modal-content" id="modalImage">
      <div id="modalCaption"></div>
    </div>
    <!-- End Modal -->


    <script>
        // --- UI Control Functions ---
        function showCreation() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('creationSection').style.display = 'block';
            document.getElementById('learningSection').style.display = 'none';
        }

        function showLearning() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('creationSection').style.display = 'none';
            document.getElementById('learningSection').style.display = 'block';
        }

        function goBack() {
            document.getElementById('mainMenu').style.display = 'flex';
            document.getElementById('creationSection').style.display = 'none';
            document.getElementById('learningSection').style.display = 'none';
            resetLearningArea(); // Reset learning area when going back to menu
        }

        // --- JavaScript Logic ---

        // Get references to HTML elements (Creation Section)
        const addDeckSelect = document.getElementById('addDeckSelect'); // New dropdown for adding to existing
        const textInput = document.getElementById('textInput');
        const folderSelect = document.getElementById('folderSelect');
        const newFolderNameInput = document.getElementById('newFolderNameInput');
        const deckNameInput = document.getElementById('deckNameInput'); // Now only for NEW decks
        const parseAndSaveBtn = document.getElementById('parseAndSaveBtn'); // Button now says "Process Input"

        const creationFrontImageDropZone = document.getElementById('creationFrontImageDropZone');
        const creationFrontImagePreviewContainer = document.getElementById('creationFrontImagePreviewContainer');
        const creationFrontImageControls = document.getElementById('creationFrontImageControls');
        const removeCreationFrontImageBtn = document.getElementById('removeCreationFrontImageBtn');
        const creationFrontImagePasteBtn = document.getElementById('creationFrontImagePasteBtn');

        const creationBackImageDropZone = document.getElementById('creationBackImageDropZone');
        const creationBackImagePreviewContainer = document.getElementById('creationBackImagePreviewContainer');
        const creationBackImageControls = document.getElementById('creationBackImageControls');
        const removeCreationBackImageBtn = document.getElementById('removeCreationBackImageBtn');
        const creationBackImagePasteBtn = document.getElementById('creationBackImagePasteBtn');


        // Get references to HTML elements (Learning Section)
        // const deckSelect = document.getElementById('deckSelect'); // REMOVED - Replaced with div
        const deckCheckboxesContainer = document.getElementById('deckCheckboxesContainer'); // New container for deck checkboxes
        const loadDeckBtn = document.getElementById('loadDeckBtn');
        const flashcard = document.getElementById('flashcard');
        const cardFront = document.getElementById('cardFront');
        const cardBack = document.getElementById('cardBack');
         // Get references to inner image and text containers within card faces
         const cardFrontImageContainer = cardFront.querySelector('.card-image-container');
         const cardFrontTextContent = cardFront.querySelector('.card-text-content');
         const cardBackImageContainer = cardBack.querySelector('.card-image-container');
         const cardBackTextContent = cardBack.querySelector('.card-text-content');

        // Favorite Filter elements
        const favoriteSourceCheckboxesContainer = document.getElementById('favoriteSourceCheckboxesContainer'); // The new container div
        const loadFilteredFavoritesBtn = document.getElementById('loadFilteredFavoritesBtn');


        const showAnswerBtn = document.getElementById('showAnswerBtn');
        const nextCardBtn = document.getElementById('nextCardBtn');
        const previousCardBtn = document.getElementById('previousCardBtn');
        const randomizeCheckbox = document.getElementById('randomizeCheckbox');
        const markKnownBtn = document.getElementById('markKnownBtn'); // Now "Mark Known" (individual)
        const markNeedsReviewBtn = document.getElementById('markNeedsReviewBtn'); // Now "Mark Needs Review" (individual)
        const resetStatusBtn = document.getElementById('resetStatusBtn'); // Reset Status button ("Reset All to New") (bulk)
        const toggleFavoriteBtn = document.getElementById('toggleFavoriteBtn'); // Mark/Unmark Favorite (still individual)
        const highlighterBtn = document.getElementById('highlighterBtn'); // Highlighter button (still individual)
        const undoHighlightBtn = document.getElementById('undoHighlightBtn'); // Undo button (still individual)
        const resetHighlightBtn = document.getElementById('resetHighlightBtn'); // Reset button (still individual)
        const progressDisplay = document.getElementById('progressDisplay');
        const importDeckInput = document.getElementById('importDeckInput');
        const exportCurrentDeckBtn = document.getElementById('exportCurrentDeckBtn');
        const deleteDeckBtn = document.getElementById('deleteDeckBtn'); // This button now deletes SELECTED decks
        const learningArea = document.getElementById('learningArea');
        const deleteFolderBtn = document.getElementById('deleteFolderBtn');

        // Get references to Image Input Elements in Learning Section
        const learningImageInputContainer = document.querySelector('.image-input-learning-container');
        const learningFrontImageDropZone = document.getElementById('learningFrontImageDropZone');
        const learningFrontImagePreviewContainer = document.getElementById('learningFrontImagePreviewContainer');
        const learningFrontImageControls = document.getElementById('learningFrontImageControls');
        const removeLearningFrontImageBtn = document.getElementById('removeLearningFrontImageBtn');
        const learningFrontImagePasteBtn = document.getElementById('learningFrontImagePasteBtn');

        const learningBackImageDropZone = document.getElementById('learningBackImageDropZone');
        const learningBackImagePreviewContainer = document.getElementById('learningBackImagePreviewContainer');
        const learningBackImageControls = document.getElementById('learningBackImageControls');
        const removeLearningBackImageBtn = document.getElementById('removeLearningBackImageBtn');
        const learningBackImagePasteBtn = document.getElementById('learningBackImagePasteBtn');

        // Get references to Modal elements
        const imageModal = document.getElementById('imageModal');
        const modalImage = document.getElementById('modalImage');
        const modalCaption = document.getElementById('modalCaption');
        const modalClose = document.querySelector('.modal-close');


        let currentDeck = null; // { name: '...', folder: '...', cards: [{front:'...', back:'...', status:'...', isFavorite: boolean, sourceDeckName?: string, sourceCardFront?: string, frontHighlighted?: string, backHighlighted?: string, frontHighlightHistory?: string[], backHighlightHistory?: string[], frontImage?: string, backImage?: string}], shuffledIndices: [...], displayName?: string }
        let currentCardIndex = 0; // Index within the shuffled/original order
        let isAnswerShowing = false;
        let isHighlighterActive = false; // Track if highlighter mode is active

        // Image handling variables (for Creation Section ONLY)
        let creationFrontImage = null; // Stores Data URL for the image added in the creation section front
        let creationBackImage = null; // Stores Data URL for the image added in the creation section back


        const DECK_STORAGE_KEY = 'flashcardsDecksCollection';
        const UNSORTED_FOLDER_KEY = "__UNSORTED__";
        const ALL_FAVORITES_KEY = "__ALL_FAVORITES__"; // Special key for the Favorites view
        const MERGED_DECKS_KEY = "__MERGED_DECKS__"; // Special key for the Merged Decks view


         // Define a prefix for checkbox IDs to make them unique and identifiable
        const CHECKBOX_ID_PREFIX = 'fav-src-cb-'; // Prefix for favorite sources
        const DECK_CHECKBOX_ID_PREFIX = 'deck-cb-'; // Prefix for main deck selection


        const MAX_HIGHLIGHT_HISTORY = 10; // Limit history depth


         // --- Deck Management (Collection in localStorage) ---

         // Helper to get all decks from localStorage
         function getAllDecksFromStorage() {
             try {
                const decks = JSON.parse(localStorage.getItem(DECK_STORAGE_KEY) || '{}');
                // Ensure basic properties exist for compatibility with older saves and add new ones
                 for (const deckName in decks) {
                     const deck = decks[deckName];
                     // Basic structural check for the top-level deck object
                     if (!deck || typeof deck.name !== 'string' || !Array.isArray(deck.cards)) {
                          console.warn(`Deck "${deckName}" has invalid structure. Skipping.`);
                          delete decks[deckName]; // Remove invalid deck
                          continue;
                     }
                      // Ensure card properties exist and are of the correct type
                      deck.cards = deck.cards.filter(card => { // Filter out any invalid card objects
                          if (!card || typeof card.front !== 'string' || typeof card.back !== 'string') {
                                console.warn(`Card in deck "${deckName}" has invalid structure. Skipping card.`);
                                return false; // Remove invalid card
                          }
                          // Normalize and add missing properties to valid cards
                          if (!card.status || (card.status !== 'new' && card.status !== 'known' && card.status !== 'needsReview')) {
                             card.status = 'new'; // Default status
                          }
                          if (typeof card.isFavorite !== 'boolean') card.isFavorite = false; // Add default favorite status if missing

                           // Normalize highlight properties: must be string or undefined
                          if (typeof card.frontHighlighted !== 'string' && typeof card.frontHighlighted !== 'undefined') {
                               console.warn(`Card "${card.front}" in deck "${deckName}" has invalid frontHighlighted type (${typeof card.frontHighlighted}). Resetting to undefined.`);
                               card.frontHighlighted = undefined;
                           }
                          if (typeof card.backHighlighted !== 'string' && typeof card.backHighlighted !== 'undefined') {
                               console.warn(`Card "${card.front}" in deck "${deckName}" has invalid backHighlighted type (${typeof card.backHighlighted}). Resetting to undefined.`);
                               card.backHighlighted = undefined;
                          }

                           // Normalize image properties: must be string (data URL) or undefined
                           // Ensure data URLs are strings starting with 'data:', otherwise set to undefined
                           if (typeof card.frontImage !== 'string' || (card.frontImage && !card.frontImage.startsWith('data:'))) {
                                console.warn(`Card "${card.front}" in deck "${deckName}" has invalid frontImage data. Resetting to undefined.`);
                                card.frontImage = undefined;
                           }
                           if (typeof card.backImage !== 'string' || (card.backImage && !card.backImage.startsWith('data:'))) {
                                console.warn(`Card "${card.front}" in deck "${deckName}" has invalid backImage data. Resetting to undefined.`);
                                card.backImage = undefined;
                           }


                           // Initialize history arrays if missing or not arrays. History is NOT persisted from storage.
                           // Ensure they are arrays for session use.
                           card.frontHighlightHistory = []; // Always start with empty history on load from storage
                           card.backHighlightHistory = []; // Always start with empty history on load from storage


                           // Remove old SRS properties if they exist (for migration/cleanup)
                          delete card.interval;
                          delete card.repetitions;
                          delete card.easeFactor;
                          delete card.dueDate;

                           // Remove temporary source info if present (cleanup for regular decks)
                           delete card.sourceDeckName;
                           delete card.sourceCardFront;

                           return true; // Keep this card as it's valid or normalized
                      });

                      // Ensure folder property exists (string or undefined)
                      if (typeof deck.folder !== 'string' && typeof deck.folder !== 'undefined') {
                           console.warn(`Deck "${deckName}" has invalid folder type (${typeof deck.folder}). Resetting to undefined.`);
                           deck.folder = undefined;
                      }
                     // Shuffled indices and display name are session-specific and should not be loaded from storage
                      delete deck.shuffledIndices; // Ensure this isn't loaded from storage
                      delete deck.displayName; // Ensure this isn't loaded from storage

                 }
                 return decks;
             } catch (e) {
                 console.error("Error parsing decks from localStorage:", e);
                 alert("Error loading your saved decks. Your local storage might be corrupted. Clearing storage to prevent further issues.");
                 localStorage.removeItem(DECK_STORAGE_KEY); // Clear corrupted data
                 return {};
             }
         }

         // Helper to save the entire decks collection to localStorage
         function saveAllDecksToStorage(allDecks) {
              try {
                 // Check if any decks are marked with special temporary keys before saving
                 if (allDecks[ALL_FAVORITES_KEY]) {
                      console.warn(`Attempted to save decks collection including the temporary "${ALL_FAVORITES_KEY}" view. Removing it before saving.`);
                      delete allDecks[ALL_FAVORITES_KEY]; // Do NOT save the temporary favorites view
                 }
                  if (allDecks[MERGED_DECKS_KEY]) {
                       console.warn(`Attempted to save decks collection including the temporary "${MERGED_DECKS_KEY}" view. Removing it before saving.`);
                       delete allDecks[MERGED_DECKS_KEY]; // Do NOT save the temporary merged view
                  }
                 localStorage.setItem(DECK_STORAGE_KEY, JSON.stringify(allDecks));
              } catch (e) {
                  console.error("Error saving decks to localStorage:", e);
                   if (e.name === 'QuotaExceededError') {
                       alert('Cannot save deck. Local storage is full. Please export some decks and clear your browser storage.');
                   } else {
                       alert('Error saving deck: ' + e.message);
                   }
              }
         }

        // Function to save a single deck (updates the collection in localStorage)
        function saveDeck(deck) {
             // Do not attempt to save temporary decks
             if (!deck || deck.name === ALL_FAVORITES_KEY || deck.name === MERGED_DECKS_KEY) {
                 console.warn(`Attempted to save a temporary deck (${deck ? deck.name : 'null'}) or null deck. Ignoring.`);
                 return; // Don't save temporary views
             }

            const decks = getAllDecksFromStorage(); // Get the latest state first
            // Create a clean copy for saving, removing properties not meant for long-term storage
             const deckToSave = JSON.parse(JSON.stringify(deck)); // Deep copy
             // Remove history arrays - they are temporary for the session
             deckToSave.cards.forEach(card => {
                 delete card.frontHighlightHistory;
                 delete card.backHighlightHistory;
             });
             // Remove other temporary properties if they somehow got added
              delete deckToSave.shuffledIndices;
              delete deckToSave.displayName;
             // Remove source info if present (only used in temporary view objects)
             deckToSave.cards.forEach(card => {
                 delete card.sourceDeckName;
                 delete card.sourceCardFront;
             });


            decks[deckToSave.name] = deckToSave; // Store/update by name
            saveAllDecksToStorage(decks); // Save the entire updated collection
            // Note: Does NOT repopulate selects or reload currentDeck here.
            // This is handled by explicit calls or events after save/load actions.
        }

        // Function to load a single deck by name (Used internally if only one deck is selected)
        function loadSingleDeck(deckName) {
             console.log("loadSingleDeck function called for:", deckName);
             // Ensure we don't load special keys with this function
             if (deckName === ALL_FAVORITES_KEY || deckName === MERGED_DECKS_KEY || deckName === "") {
                  console.error("loadSingleDeck called with a special key or empty name. Use loadFilteredFavorites or the main load button.");
                  resetLearningArea();
                 return;
             }

            const decks = getAllDecksFromStorage();
            let deckToLoad = decks[deckName];

            if (!deckToLoad || !Array.isArray(deckToLoad.cards) || deckToLoad.cards.length === 0) {
                 alert(`No cards found in deck "${deckName}".`);
                 resetLearningArea(); // Clear learning area
                 populateDeckSelect(); // Refresh options (which also populates favoritesources)
                 return;
            }

             // Ensure cards in the loaded deck have history arrays initialized (handled by getAllDecksFromStorage)
             // Ensure image properties exist (handled by getAllDecksFromStorage)
             // Ensure source info is NOT present (handled by getAllDecksFromStorage)


            currentDeck = deckToLoad; // Set the current deck object
            currentCardIndex = 0; // Start at the beginning of the loaded deck's cards

            // Ensure shuffledIndices exists and is correct length, or create/recreate it
            // Regenerate indices if missing/mismatch or randomize checked
            if (!currentDeck.shuffledIndices || currentDeck.shuffledIndices.length !== currentDeck.cards.length || randomizeCheckbox.checked) {
                 console.log(`Deck "${deckName}" indices mismatch/missing or randomize checked. Re-generating ${randomizeCheckbox.checked ? 'shuffled' : 'original'} order.`);
                  const initialIndices = Array.from({length: currentDeck.cards.length}, (_, i) => i);
                 currentDeck.shuffledIndices = randomizeCheckbox.checked ? shuffleArray(initialIndices) : initialIndices;
            } else {
                 console.log(`Loading Deck "${deckName}" with existing order.`);
                 // Ensure it's just the 0..n-1 sequence if randomize is off
                 if (!randomizeCheckbox.checked) {
                      currentDeck.shuffledIndices = Array.from({length: currentDeck.cards.length}, (_, i) => i);
                      console.log("Deck order reset to original based on randomize checkbox state.");
                 } else {
                      // If randomize IS checked but indices match original length, it might be from a previous session.
                      // Re-shuffle to get a *new* random order if randomize is checked.
                      const initialIndices = Array.from({length: currentDeck.cards.length}, (_, i) => i);
                      currentDeck.shuffledIndices = shuffleArray(initialIndices);
                      console.log("Deck shuffled based on randomize checkbox state.");
                 }
            }
             currentCardIndex = 0; // Reset index to 0 when loading


            document.querySelector('.learning-section h2').textContent = `Learn: ${currentDeck.name}`; // Update section title

            displayCurrentCard(); // Display the first card in the chosen order
            updateProgressDisplay();
            learningArea.style.display = 'flex';

             // Clear Favorite Source Checkboxes when a regular deck is loaded
             favoriteSourceCheckboxesContainer.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                 checkbox.checked = false;
             });
             // Clear Main Deck Checkboxes when one is loaded via loadSingleDeck (which happens if exactly one is checked)
             deckCheckboxesContainer.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                 checkbox.checked = false;
             });


             // Enable/Disable buttons based on single regular deck load
            showAnswerBtn.disabled = false;
            nextCardBtn.disabled = false;
            previousCardBtn.disabled = false;
            markKnownBtn.disabled = false; // Individual status enabled
            markNeedsReviewBtn.disabled = false; // Individual status enabled
            resetStatusBtn.disabled = false; // Bulk status enabled for single regular deck
            toggleFavoriteBtn.disabled = false; // Favorite enabled
            highlighterBtn.disabled = false; // Highlighter enabled
             // Undo/Reset states updated by displayCurrentCard
            exportCurrentDeckBtn.disabled = false; // Export enabled
            // deleteDeckBtn state depends on selected checkboxes, not loaded deck


             // Show image input controls in learning section
             learningImageInputContainer.style.display = 'flex';

             // Ensure highlighter mode is OFF by default when loading a deck
             isHighlighterActive = false;
             highlighterBtn.classList.remove('active');
             highlighterBtn.textContent = 'Highlighter';

             // Text selection is managed per face in displayCurrentCard/showAnswerBtn handlers

        }


         // New function to load favorite cards based on selected sources (Adapted for checkboxes)
         function loadFilteredFavorites() {
             console.log("loadFilteredFavorites button clicked.");
             // Get values from checked checkboxes
             const selectedValues = Array.from(favoriteSourceCheckboxesContainer.querySelectorAll('input[type="checkbox"]:checked')).map(checkbox => checkbox.value);
             console.log("Selected favorite source values from checkboxes:", selectedValues);

             if (selectedValues.length === 0) {
                 alert("Please select at least one source (folder or deck) to load favorite cards from.");
                 console.warn("Load Filtered Favorites failed: No sources selected.");
                 resetLearningArea(); // Clear learning area if trying to load nothing
                 return;
             }

             const decks = getAllDecksFromStorage();
             let filteredFavoriteCards = [];
             const addedCardIdentifiers = new Set(); // To prevent adding the same card multiple times if included via folder and deck


             // Handle the special "All Decks & Folders" case
             const loadAllFavorites = selectedValues.includes(ALL_FAVORITES_KEY);
             console.log("Load All Favorites selected:", loadAllFavorites);


             // If 'All' is selected, iterate through *all* decks. Otherwise, iterate through selected values.
             // Map values to a standard format { type: 'folder' | 'deck', name: '...' }
             const sourcesToProcess = [];
             if (loadAllFavorites) {
                  Object.keys(decks).forEach(name => {
                       if (name !== ALL_FAVORITES_KEY && name !== MERGED_DECKS_KEY) { // Exclude special keys
                           sourcesToProcess.push({ type: 'deck', name: name }); // Process all valid decks as deck sources
                       }
                  });
             } else {
                  selectedValues.forEach(value => {
                      const parts = value.split(':');
                      if (parts.length >= 2) {
                          const type = parts[0];
                          const name = parts.slice(1).join(':');
                           if ((type === 'folder' || type === 'deck') && name) { // Basic check for type and name
                                sourcesToProcess.push({ type: type, name: name });
                           } else {
                                console.warn("Skipping malformed or invalid selected source value:", value);
                           }
                      } else {
                          console.warn("Skipping invalid selected source value:", value);
                      }
                  });
             }
             console.log("Sources to process for favorites:", sourcesToProcess);


             sourcesToProcess.forEach(source => {
                 const type = source.type;
                 const name = source.name;

                  if (type === 'folder') {
                     console.log("Processing selected folder:", name);
                     Object.values(decks).forEach(deck => {
                         // Ensure the deck is a valid deck object and not a temporary view itself
                         if (deck && deck.name !== ALL_FAVORITES_KEY && deck.name !== MERGED_DECKS_KEY && (deck.folder || '').trim() === name.trim()) {
                             console.log(`Including favorite cards from deck "${deck.name}" in folder "${name}".`);
                             deck.cards.forEach(card => {
                                 if (card.isFavorite) {
                                      // Create a unique identifier for the card (deckName + original front text)
                                      // Using a combination of original deck name and original front text as a unique identifier *within* the temporary view.
                                      // This identifier is NOT saved persistently.
                                      const cardIdentifier = `${deck.name}::${card.front}`;
                                      if (!addedCardIdentifiers.has(cardIdentifier)) {
                                           // Clone and add source info for the temporary view
                                           const cardCopy = JSON.parse(JSON.stringify(card));
                                           cardCopy.sourceDeckName = deck.name;
                                           cardCopy.sourceCardFront = card.front; // Store the original front for lookup later
                                           cardCopy.frontHighlightHistory = []; // Start history fresh for the session
                                           cardCopy.backHighlightHistory = []; // Start history fresh for the session
                                           filteredFavoriteCards.push(cardCopy);
                                           addedCardIdentifiers.add(cardIdentifier);
                                           // console.log(`Added favorite card: "${card.front}" from "${deck.name}".`);
                                      } // else console.log(`Skipping duplicate favorite card: "${card.front}" from "${deck.name}".`);
                                 }
                             });
                         }
                     });
                 } else if (type === 'deck') { // Process 'deck' type
                     console.log("Processing selected deck:", name);
                     const deck = decks[name];
                     // Ensure the deck is a valid deck object and not a temporary view itself
                     if (deck && deck.name !== ALL_FAVORITES_KEY && deck.name !== MERGED_DECKS_KEY) {
                          console.log(`Including favorite cards from deck "${deck.name}".`);
                         deck.cards.forEach(card => {
                             if (card.isFavorite) {
                                  // Create a unique identifier for the card
                                  const cardIdentifier = `${deck.name}::${card.front}`;
                                  if (!addedCardIdentifiers.has(cardIdentifier)) {
                                       // Clone and add source info
                                       const cardCopy = JSON.parse(JSON.stringify(card));
                                       cardCopy.sourceDeckName = deck.name;
                                       cardCopy.sourceCardFront = card.front; // Store the original front for lookup later
                                       cardCopy.frontHighlightHistory = []; // Start history fresh
                                       cardCopy.backHighlightHistory = []; // Start history fresh
                                       filteredFavoriteCards.push(cardCopy);
                                       addedCardIdentifiers.add(cardIdentifier);
                                       // console.log(`Added favorite card: "${card.front}" from "${deck.name}".`);
                                  } // else console.log(`Skipping duplicate favorite card: "${card.front}" from "${deck.name}".`);
                             }
                         });
                     } else {
                         console.warn(`Selected deck not found or was a temporary view for favorites filter: "${name}".`);
                     }
                 } else {
                     console.warn("Unknown or unhandled source type during processing:", type, "from source:", source);
                 }
             });

             console.log("Total favorite cards gathered:", filteredFavoriteCards.length);

             if (filteredFavoriteCards.length === 0) {
                 alert("No favorite cards found matching your selected sources.");
                 console.log("No favorite cards found for selected sources. Resetting learning area.");
                 resetLearningArea();
                 // Keep the favoriteSourceCheckboxes state as is
                 return;
             }

             // Create the temporary deck object for the filtered favorites view
             currentDeck = {
                 name: ALL_FAVORITES_KEY, // Use the special key
                 displayName: " Filtered Favorite Cards", // Display name
                 folder: undefined, // No folder for this view
                 cards: filteredFavoriteCards // This array contains *copies* of favorite cards with source info
             };

             currentCardIndex = 0; // Start at the beginning

             // Generate shuffled indices based on the filtered cards
             const initialIndices = Array.from({length: currentDeck.cards.length}, (_, i) => i);
             currentDeck.shuffledIndices = randomizeCheckbox.checked ? shuffleArray(initialIndices) : initialIndices;
              console.log(`Filtered Favorites loaded. Total cards: ${currentDeck.cards.length}, Shuffled indices created.`);


            document.querySelector('.learning-section h2').textContent = currentDeck.displayName; // Update section title

            displayCurrentCard(); // Display the first card
            updateProgressDisplay();
            learningArea.style.display = 'flex';
             // Clear the main deck checkboxes when loading favorites
             deckCheckboxesContainer.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                 checkbox.checked = false;
             });


             // Enable/Disable buttons based on Favorites view load
            showAnswerBtn.disabled = false;
            nextCardBtn.disabled = false;
            previousCardBtn.disabled = false;
             markKnownBtn.disabled = false; // Individual status enabled
             markNeedsReviewBtn.disabled = false; // Individual status enabled
             resetStatusBtn.disabled = true; // Bulk status disabled for favorites
            toggleFavoriteBtn.disabled = false; // Favorite enabled
            highlighterBtn.disabled = false; // Highlighter enabled
             // Undo/Reset states updated by displayCurrentCard
            exportCurrentDeckBtn.disabled = true; // Export disabled
            // deleteDeckBtn state depends on selected checkboxes, not loaded deck


             // Hide image input controls in learning section for temporary views
             learningImageInputContainer.style.display = 'none';


             // Ensure highlighter mode is OFF by default
             isHighlighterActive = false;
             highlighterBtn.classList.remove('active');
             highlighterBtn.textContent = 'Highlighter';

             // Text selection is managed per face in displayCurrentCard/showAnswerBtn handlers
         }

        // New function to load MERGED decks based on checked main deck checkboxes
        function loadMergedDecks() {
             console.log("loadMergedDecks function called.");
             // Get the names of the checked decks
             const selectedDeckNames = Array.from(deckCheckboxesContainer.querySelectorAll(`input[type="checkbox"]:checked`))
                                          .filter(checkbox => checkbox.value !== MERGED_DECKS_KEY) // Exclude the "All Decks" value
                                          .map(checkbox => checkbox.value);

             console.log("Selected decks to merge:", selectedDeckNames);

            if (selectedDeckNames.length === 0) {
                 alert("Please select at least one deck to load.");
                 console.warn("Load Merged Decks failed: No decks selected.");
                 resetLearningArea();
                 return;
            }

             // If only one deck is selected, use the single deck loading logic
             if (selectedDeckNames.length === 1) {
                 console.log("Only one deck selected, calling loadSingleDeck.");
                 loadSingleDeck(selectedDeckNames[0]); // Call the existing single-deck load function
                 // Ensure checkboxes are cleared after loading
                  deckCheckboxesContainer.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                     checkbox.checked = false;
                 });
                  // And clear favorite source checkboxes
                  favoriteSourceCheckboxesContainer.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                     checkbox.checked = false;
                 });
                 return; // Stop here, loadSingleDeck handles the rest
             }

            // --- Merge logic for multiple decks ---
            const decks = getAllDecksFromStorage();
            let mergedCards = [];
             const addedCardIdentifiers = new Set(); // To prevent adding duplicates if a deck is somehow listed twice or structure is odd

             selectedDeckNames.forEach(deckName => {
                 const deck = decks[deckName];
                  // Ensure the deck exists and is not a temporary view
                 if (deck && deck.name !== ALL_FAVORITES_KEY && deck.name !== MERGED_DECKS_KEY && Array.isArray(deck.cards)) {
                      console.log(`Including cards from deck "${deck.name}" in merged view.`);
                      deck.cards.forEach(card => {
                           // Create a unique identifier for the card (deckName + original front text)
                            const cardIdentifier = `${deck.name}::${card.front}`;
                           if (!addedCardIdentifiers.has(cardIdentifier)) {
                                // Clone the card object
                                const cardCopy = JSON.parse(JSON.stringify(card));
                                // Add source info to the cloned card
                                cardCopy.sourceDeckName = deck.name;
                                cardCopy.sourceCardFront = card.front; // Store original front for lookup
                                cardCopy.frontHighlightHistory = []; // Start history fresh for the session
                                cardCopy.backHighlightHistory = []; // Start history fresh for the session
                                mergedCards.push(cardCopy);
                                addedCardIdentifiers.add(cardIdentifier);
                                // console.log(`Added card: "${card.front}" from "${deck.name}" to merged view.`);
                           } // else console.log(`Skipping duplicate card: "${card.front}" from "${deck.name}" during merge.`);
                      });
                 } else {
                     console.warn(`Selected deck "${deckName}" not found or invalid for merging.`);
                 }
             });

             console.log("Total cards in merged view:", mergedCards.length);

             if (mergedCards.length === 0) {
                 alert("No cards found in the selected decks.");
                 console.log("No cards found in selected decks for merging. Resetting learning area.");
                 resetLearningArea();
                 return; // Keep the selected checkboxes as is
             }

            // Create the temporary deck object for the merged view
             currentDeck = {
                 name: MERGED_DECKS_KEY, // Use the special key for merged decks
                 displayName: ` Merged Decks (${selectedDeckNames.join(', ')})`, // Display name indicating source
                 folder: undefined, // No folder for this view
                 cards: mergedCards // This array contains *copies* of cards with source info
             };

            currentCardIndex = 0; // Start at the beginning

            // Generate shuffled indices based on the merged cards
            const initialIndices = Array.from({length: currentDeck.cards.length}, (_, i) => i);
            currentDeck.shuffledIndices = randomizeCheckbox.checked ? shuffleArray(initialIndices) : initialIndices;
             console.log(`Merged decks loaded. Total cards: ${currentDeck.cards.length}, Shuffled indices created.`);


           document.querySelector('.learning-section h2').textContent = currentDeck.displayName; // Update section title

           displayCurrentCard(); // Display the first card
           updateProgressDisplay();
           learningArea.style.display = 'flex';
            // Clear all deck checkboxes after loading
            deckCheckboxesContainer.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                 checkbox.checked = false;
             });
            // Clear favorite source checkboxes
             favoriteSourceCheckboxesContainer.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                 checkbox.checked = false;
             });


            // Enable/Disable buttons based on Merged view load
           showAnswerBtn.disabled = false;
           nextCardBtn.disabled = false;
           previousCardBtn.disabled = false;
            markKnownBtn.disabled = false; // Individual status enabled
            markNeedsReviewBtn.disabled = false; // Individual status enabled
            resetStatusBtn.disabled = true; // Bulk status disabled for merged view
           toggleFavoriteBtn.disabled = false; // Favorite enabled
           highlighterBtn.disabled = false; // Highlighter enabled
            // Undo/Reset states updated by displayCurrentCard
           exportCurrentDeckBtn.disabled = true; // Export disabled
           // deleteDeckBtn state depends on selected checkboxes


            // Hide image input controls in learning section for temporary views
            learningImageInputContainer.style.display = 'none';


            // Ensure highlighter mode is OFF by default
            isHighlighterActive = false;
            highlighterBtn.classList.remove('active');
            highlighterBtn.textContent = 'Highlighter';

            // Text selection is managed per face in displayCurrentCard/showAnswerBtn handlers
        }


        function populateFolderSelect() {
             console.log("Populating folder select...");
             const currentValue = folderSelect.value; // Remember current selection

             folderSelect.innerHTML = ''; // Clear current options

             const defaultOption = document.createElement('option');
             defaultOption.value = "";
             defaultOption.textContent = "-- Select or Create Folder --";
             folderSelect.appendChild(defaultOption);

             const newFolderOption = document.createElement('option');
             newFolderOption.value = "new-folder-option";
             newFolderOption.textContent = "-- New Folder --";
             folderSelect.appendChild(newFolderOption);

            const decks = getAllDecksFromStorage();
            const folders = new Set();

            Object.values(decks).forEach(deck => {
                 // Ensure deck is valid before accessing folder
                if (deck && typeof deck.folder === 'string' && deck.folder.trim()) {
                    folders.add(deck.folder.trim());
                }
            });

            Array.from(folders).sort().forEach(folderName => {
                const option = document.createElement('option');
                option.value = folderName;
                option.textContent = folderName;
                folderSelect.appendChild(option);
            });

             // Attempt to restore previous selection
             if (folderSelect.querySelector(`option[value="${currentValue}"]`)) {
                 folderSelect.value = currentValue;
             } else {
                  folderSelect.value = ""; // Default if previous is gone or invalid
             }


            newFolderNameInput.style.display = 'none'; // Always hide the input initially after repopulating
            newFolderNameInput.value = ''; // Clear the input value

            updateDeleteFolderButtonState();
             console.log("Folder select populated.");
        }

        // New function to populate the "Add to Existing Deck" dropdown in the creation section
        function populateAddDeckSelect() {
             console.log("Populating 'Add to Existing Deck' select...");
            const currentSelectedValue = addDeckSelect.value; // Remember current selection

            addDeckSelect.innerHTML = '<option value="">-- Select Deck to Add To --</option>'; // Clear and add default option

            const decks = getAllDecksFromStorage();
            // Filter out the special Favorites key and Merged key before listing
            const deckNames = Object.keys(decks).filter(name => name !== ALL_FAVORITES_KEY && name !== MERGED_DECKS_KEY).sort(); // Sort deck names alphabetically

            deckNames.forEach(deckName => {
                const deck = decks[deckName]; // Get the deck object
                const folderPrefix = (deck.folder && typeof deck.folder === 'string' && deck.folder.trim()) ? `${deck.folder.trim()}/` : ''; // Add folder prefix if exists

                const option = document.createElement('option');
                option.value = deckName; // Value is the actual deck name
                option.textContent = `${folderPrefix}${deckName}`; // Display name with folder
                addDeckSelect.appendChild(option);
            });

             // Attempt to re-select the previously selected deck
             if (addDeckSelect.querySelector(`option[value="${currentSelectedValue}"]`)) {
                 addDeckSelect.value = currentSelectedValue;
                 console.log("Restored previous addDeckSelect selection:", currentSelectedValue);
             } else {
                  addDeckSelect.value = ""; // Default if previous is gone or invalid
                   console.log("addDeckSelect selection reset to default.");
             }

             // The state of the "Process Input" button is now managed by the button click listener logic itself
        }


        // Function to populate the main deck selection checkboxes
        function populateDeckSelect() { // Renamed internally, but keeps original purpose for this section
             console.log("Populating main deck checkboxes...");
            // Store currently checked values to try and restore them
             const currentSelectedValues = Array.from(deckCheckboxesContainer.querySelectorAll('input[type="checkbox"]:checked')).map(checkbox => checkbox.value);
             console.log("Current deckCheckboxes selected values:", currentSelectedValues);

             deckCheckboxesContainer.innerHTML = ''; // Clear current checkboxes

            const decks = getAllDecksFromStorage();
            // Filter out the special Favorites key and Merged key from the regular deck list
            const deckNames = Object.keys(decks).filter(name => name !== ALL_FAVORITES_KEY && name !== MERGED_DECKS_KEY);


            const groupedDecks = {};
            const UNSORTED_FOLDER_LABEL = "Unsorted Decks";

            deckNames.forEach(deckName => {
                const deck = decks[deckName];
                const folder = (deck.folder && typeof deck.folder === 'string' && deck.folder.trim()) || UNSORTED_FOLDER_KEY;
                if (!groupedDecks[folder]) {
                    groupedDecks[folder] = [];
                }
                groupedDecks[folder].push(deck);
            });

            const sortedFolders = Object.keys(groupedDecks).sort((a, b) => {
                if (a === UNSORTED_FOLDER_KEY) return 1;
                if (b === UNSORTED_FOLDER_KEY) return -1;
                return a.localeCompare(b);
            });

             // Add a special option to select *all* decks
              const allOptionContainer = document.createElement('div');
              allOptionContainer.className = 'checkbox-item item-all'; // Add classes for styling
              const allCheckbox = document.createElement('input');
              allCheckbox.type = 'checkbox';
              allCheckbox.id = DECK_CHECKBOX_ID_PREFIX + 'all'; // Unique ID
              allCheckbox.value = MERGED_DECKS_KEY; // Use the merged key value here for consistency with selection logic
              const allLabel = document.createElement('label');
              allLabel.htmlFor = allCheckbox.id;
              allLabel.textContent = " All Decks";
              allOptionContainer.appendChild(allCheckbox);
              allOptionContainer.appendChild(allLabel);
              deckCheckboxesContainer.appendChild(allOptionContainer);


            sortedFolders.forEach(folderKey => {
                const folderDecks = groupedDecks[folderKey];
                folderDecks.sort((a, b) => a.name.localeCompare(b.name));

                 // Add folder heading item
                 const folderHeadingContainer = document.createElement('div');
                 folderHeadingContainer.className = 'checkbox-item item-folder-heading';
                 const folderHeadingStrong = document.createElement('strong');
                 folderHeadingStrong.textContent = (folderKey === UNSORTED_FOLDER_KEY) ? UNSORTED_FOLDER_LABEL : folderKey;
                 folderHeadingContainer.appendChild(folderHeadingStrong);
                 deckCheckboxesContainer.appendChild(folderHeadingContainer);


                folderDecks.forEach(deck => {
                     const itemContainer = document.createElement('div');
                     itemContainer.className = 'checkbox-item';
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = DECK_CHECKBOX_ID_PREFIX + `${deck.name.replace(/[^a-z0-9]/gi, '-')}`; // Unique ID based on deck name
                    checkbox.value = deck.name; // Value is the actual deck name
                    const label = document.createElement('label');
                    label.htmlFor = checkbox.id;
                    label.textContent = deck.name; // Display just the deck name here
                    itemContainer.appendChild(checkbox);
                    itemContainer.appendChild(label);
                    deckCheckboxesContainer.appendChild(itemContainer);
                });
            });

             // --- Add event listeners for mutual exclusion within deck checkboxes ---
            allCheckbox.addEventListener('change', () => {
                 console.log("'All Decks' checkbox changed. Checked:", allCheckbox.checked);
                if (allCheckbox.checked) {
                    // If 'All' is checked, uncheck all other specific deck checkboxes
                    deckCheckboxesContainer.querySelectorAll(`.checkbox-item input[type="checkbox"]:not(#${DECK_CHECKBOX_ID_PREFIX}all)`).forEach(cb => {
                        cb.checked = false;
                    });
                }
                 updateDeckButtonStates(); // Update button states based on selection
            });

             // Add listeners to all other deck checkboxes
            deckCheckboxesContainer.addEventListener('change', (event) => {
                 // Check if the target is a checkbox and not the 'All' checkbox
                 if (event.target.type === 'checkbox' && event.target.id !== DECK_CHECKBOX_ID_PREFIX + 'all') {
                      console.log("Specific deck checkbox changed. Checked:", event.target.checked);
                      if (event.target.checked) {
                          // If any specific checkbox is checked, uncheck the 'All' checkbox
                          allCheckbox.checked = false;
                      }
                      updateDeckButtonStates(); // Update button states based on selection
                 }
            });


            // Attempt to restore previous selections
             currentSelectedValues.forEach(value => {
                 const checkbox = deckCheckboxesContainer.querySelector(`input[type="checkbox"][value="${value}"]`);
                 if (checkbox) {
                     checkbox.checked = true;
                 }
             });
             console.log("Main deck checkboxes populated.");

             // Update initial button states based on the current selection after population
             updateDeckButtonStates();

             // After populating main decks, also populate the favorite source checkboxes
             populateFavoriteSourceSelect(); // Ensure this is called after decks are populated

             // Add listener for mutual exclusion between deck checkboxes and favorite checkboxes
             addMutualExclusionListeners();
        }


         // Function to populate the Favorite Source checkboxes (Adapted)
         function populateFavoriteSourceSelect() {
             console.log("Populating favorite source checkboxes...");
             // Store currently selected values to try and restore them
             const currentSelectedValues = Array.from(favoriteSourceCheckboxesContainer.querySelectorAll('input[type="checkbox"]:checked')).map(checkbox => checkbox.value);
             console.log("Current favoriteSourceCheckboxes selected values:", currentSelectedValues);

             favoriteSourceCheckboxesContainer.innerHTML = ''; // Clear current checkboxes

             const decks = getAllDecksFromStorage();
             const folders = new Set();
             const deckNames = Object.keys(decks);
             const UNSORTED_FOLDER_LABEL = "Unsorted Decks";


             // Add a special option to select *all* decks/folders for favorites
              const allOptionContainer = document.createElement('div');
              allOptionContainer.className = 'checkbox-item item-all'; // Add classes for styling
              const allCheckbox = document.createElement('input');
              allCheckbox.type = 'checkbox';
              allCheckbox.id = CHECKBOX_ID_PREFIX + 'all'; // Unique ID
              allCheckbox.value = ALL_FAVORITES_KEY;
              const allLabel = document.createElement('label');
              allLabel.htmlFor = allCheckbox.id;
              allLabel.textContent = " All Favorite Cards"; // Clear wording
              allOptionContainer.appendChild(allCheckbox);
              allOptionContainer.appendChild(allLabel);
              favoriteSourceCheckboxesContainer.appendChild(allOptionContainer);

             // Add options for folders first
              const folderGroupHeadingContainer = document.createElement('div');
              folderGroupHeadingContainer.className = 'checkbox-item item-folder-heading';
              const folderGroupHeadingStrong = document.createElement('strong');
              folderGroupHeadingStrong.textContent = "Folders";
              folderGroupHeadingContainer.appendChild(folderGroupHeadingStrong);
              // We add the heading even if no folders, just for structure, unless there are absolutely no decks/folders
              // Wait until after checking if there are any items at all


             Object.values(decks).forEach(deck => {
                 // Ensure deck is valid before accessing folder
                 if (deck && typeof deck.folder === 'string' && deck.folder.trim()) {
                     folders.add(deck.folder.trim());
                 }
             });

             Array.from(folders).sort().forEach(folderName => {
                 const itemContainer = document.createElement('div');
                 itemContainer.className = 'checkbox-item';
                 const checkbox = document.createElement('input');
                 checkbox.type = 'checkbox';
                 checkbox.id = CHECKBOX_ID_PREFIX + `folder-${folderName.replace(/[^a-z0-9]/gi, '-')}`; // Unique ID
                 checkbox.value = `folder:${folderName}`; // Prefix value
                 const label = document.createElement('label');
                 label.htmlFor = checkbox.id;
                 label.textContent = ` ${folderName}`; // Display with an icon/prefix
                 itemContainer.appendChild(checkbox);
                 itemContainer.appendChild(label);
                 favoriteSourceCheckboxesContainer.appendChild(itemContainer); // Append directly for flat list
             });

             if (folders.size > 0) { // Only add folder group heading if there are folders
                 favoriteSourceCheckboxesContainer.insertBefore(folderGroupHeadingContainer, favoriteSourceCheckboxesContainer.children[1]); // Insert after "All"
             }


             // Add options for individual decks
              const deckGroupHeadingContainer = document.createElement('div');
              deckGroupHeadingContainer.className = 'checkbox-item item-folder-heading';
              const deckGroupHeadingStrong = document.createElement('strong');
              deckGroupHeadingStrong.textContent = "Decks";
              deckGroupHeadingContainer.appendChild(deckGroupHeadingStrong);
               // We add the heading even if no decks, just for structure, unless there are absolutely no decks/folders


            deckNames.filter(name => name !== ALL_FAVORITES_KEY && name !== MERGED_DECKS_KEY) // Exclude special keys
             .sort((a, b) => { // Sort decks by folder then name for better grouping visibility
                 const deckA = decks[a];
                 const deckB = decks[b];
                 const folderA = (deckA && typeof deckA.folder === 'string' ? deckA.folder.trim() : UNSORTED_FOLDER_KEY);
                 const folderB = (deckB && typeof deckB.folder === 'string' ? deckB.folder.trim() : UNSORTED_FOLDER_KEY);

                 if (folderA !== folderB) {
                     // Sort folders alphabetically, but put Unsorted at the end
                     if (folderA === UNSORTED_FOLDER_KEY) return 1;
                     if (folderB === UNSORTED_FOLDER_KEY) return -1;
                     return folderA.localeCompare(folderB);
                 }
                 return a.localeCompare(b); // Then sort by deck name within folders
             })
             .forEach(deckName => {
                const deck = decks[deckName];
                const folderPrefix = (deck && typeof deck.folder === 'string' && deck.folder.trim()) ? `${deck.folder.trim()}/` : ''; // Add folder prefix for display
                 const itemContainer = document.createElement('div');
                 itemContainer.className = 'checkbox-item';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = CHECKBOX_ID_PREFIX + `deck-${deckName.replace(/[^a-z0-9]/gi, '-')}`; // Unique ID
                checkbox.value = `deck:${deckName}`; // Prefix value
                const label = document.createElement('label');
                label.htmlFor = checkbox.id;
                label.textContent = ` ${folderPrefix}${deckName}`; // Display with an icon/prefix and folder path
                 itemContainer.appendChild(checkbox);
                 itemContainer.appendChild(label);
                 favoriteSourceCheckboxesContainer.appendChild(itemContainer); // Append directly for flat list
            });

            if (deckNames.filter(name => name !== ALL_FAVORITES_KEY && name !== MERGED_DECKS_KEY).length > 0) { // Only add deck group heading if there are decks
                // Find the position to insert the deck heading - after folder heading if it exists, otherwise after "All"
                 const insertPos = (folders.size > 0) ? favoriteSourceCheckboxesContainer.children[2] : favoriteSourceCheckboxesContainer.children[1];
                 favoriteSourceCheckboxesContainer.insertBefore(deckGroupHeadingContainer, insertPos);
            }


            // --- Add event listeners for mutual exclusion within favorite source checkboxes ---
            // Find the "All" checkbox again as it was created dynamically
            const favAllCheckbox = favoriteSourceCheckboxesContainer.querySelector(`#${CHECKBOX_ID_PREFIX}all`);
             if (favAllCheckbox) { // Ensure it exists
                 favAllCheckbox.addEventListener('change', () => {
                      console.log("'All Favorite Sources' checkbox changed. Checked:", favAllCheckbox.checked);
                     if (favAllCheckbox.checked) {
                         // If 'All' is checked, uncheck all other specific checkboxes
                         favoriteSourceCheckboxesContainer.querySelectorAll(`.checkbox-item input[type="checkbox"]:not(#${CHECKBOX_ID_PREFIX}all)`).forEach(cb => {
                             cb.checked = false;
                         });
                     }
                      updateFavoriteButtonStates(); // Update button states based on selection
                 });
             } else {
                  console.warn("Favorite 'All' checkbox not found after population.");
             }


             // Add listeners to all other favorite source checkboxes
            favoriteSourceCheckboxesContainer.addEventListener('change', (event) => {
                 // Check if the target is a checkbox and not the 'All' checkbox
                 if (event.target.type === 'checkbox' && event.target.id !== CHECKBOX_ID_PREFIX + 'all') {
                      console.log("Specific favorite source checkbox changed. Checked:", event.target.checked);
                      if (event.target.checked) {
                          // If any specific checkbox is checked, uncheck the 'All' checkbox
                           const favAllCb = favoriteSourceCheckboxesContainer.querySelector(`#${CHECKBOX_ID_PREFIX}all`);
                           if (favAllCb) {
                                favAllCb.checked = false;
                           }
                      }
                       updateFavoriteButtonStates(); // Update button states based on selection
                 }
            });


            // Attempt to restore previous selections
             currentSelectedValues.forEach(value => {
                 const checkbox = favoriteSourceCheckboxesContainer.querySelector(`input[type="checkbox"][value="${value}"]`);
                 if (checkbox) {
                     checkbox.checked = true;
                 }
             });
             console.log("Favorite source checkboxes populated.");
              // Update initial button states based on the current selection after population
             updateFavoriteButtonStates();

             // Add listener for mutual exclusion between deck checkboxes and favorite checkboxes
             addMutualExclusionListeners();
        }


         // New function to add mutual exclusion listeners between deck and favorite source checkboxes
         function addMutualExclusionListeners() {
             console.log("Adding mutual exclusion listeners between deck and favorite source checkboxes.");

             // Listener on deck checkboxes container
             deckCheckboxesContainer.addEventListener('change', (event) => {
                  if (event.target.type === 'checkbox') {
                       const anyDeckChecked = deckCheckboxesContainer.querySelector(`input[type="checkbox"]:checked`);
                       if (anyDeckChecked) {
                           // If any deck checkbox is checked, uncheck all favorite source checkboxes
                            favoriteSourceCheckboxesContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                                cb.checked = false;
                            });
                           updateFavoriteButtonStates(); // Update favorite button
                       }
                       // The state of the main deck load/delete buttons is updated by updateDeckButtonStates
                  }
             });

              // Listener on favorite source checkboxes container
              favoriteSourceCheckboxesContainer.addEventListener('change', (event) => {
                  if (event.target.type === 'checkbox') {
                       const anyFavoriteChecked = favoriteSourceCheckboxesContainer.querySelector('input[type="checkbox"]:checked');
                       if (anyFavoriteChecked) {
                           // If any favorite source checkbox is checked, uncheck all main deck checkboxes
                            deckCheckboxesContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                                cb.checked = false;
                            });
                           updateDeckButtonStates(); // Update main deck buttons
                       }
                       // The state of the favorite load button is updated by updateFavoriteButtonStates
                   }
             });

             console.log("Mutual exclusion listeners added.");

         }

         // Helper function to update the state of the main deck Load/Delete buttons
         function updateDeckButtonStates() {
             const selectedDeckCheckboxes = deckCheckboxesContainer.querySelectorAll(`input[type="checkbox"]:checked`);
             const numSelected = selectedDeckCheckboxes.length;

             // Load button is enabled if at least one deck checkbox is checked (excluding the "All" value itself)
             // Check for value != MERGED_DECKS_KEY because the 'All' checkbox has this value, but doesn't count as selecting *a* deck for deletion/export
             const numSpecificDecksSelected = Array.from(selectedDeckCheckboxes).filter(cb => cb.value !== MERGED_DECKS_KEY).length;

             loadDeckBtn.disabled = (numSelected === 0);

             // Delete button is enabled if at least one *specific* deck checkbox is checked (not the "All" option)
             deleteDeckBtn.disabled = (numSpecificDecksSelected === 0);

             // Export button is only enabled when a *single regular* deck is *loaded* (handled by loadSingleDeck)
             // Do NOT enable/disable export based on checkbox selection here.

             console.log(`Deck button states updated: Selected=${numSelected}, Specific Selected=${numSpecificDecksSelected}. Load Disabled=${loadDeckBtn.disabled}, Delete Disabled=${deleteDeckBtn.disabled}`);
         }

          // Helper function to update the state of the Favorite Load button
         function updateFavoriteButtonStates() {
              const selectedFavoriteCheckboxes = favoriteSourceCheckboxesContainer.querySelectorAll('input[type="checkbox"]:checked');
              const numSelected = selectedFavoriteCheckboxes.length;

              // Load Favorite Cards button is enabled if at least one favorite source checkbox is checked
              loadFilteredFavoritesBtn.disabled = (numSelected === 0);

              console.log(`Favorite button state updated: Selected=${numSelected}. Load Disabled=${loadFilteredFavoritesBtn.disabled}`);
         }


         function resetLearningArea() {
              console.log("Resetting learning area.");
              currentDeck = null;
              currentCardIndex = 0; // Reset index

              learningArea.style.display = 'none';
              // Clear card content elements
              cardFrontImageContainer.innerHTML = "";
              cardFrontTextContent.innerHTML = "No cards available in this deck/view.";
              cardBackImageContainer.innerHTML = "";
              cardBackTextContent.innerHTML = "";

              cardBack.classList.add('hidden'); // Hide back
              cardFront.classList.remove('hidden'); // Ensure front is visible
               isAnswerShowing = false; // Reset state

              // Hide and clear learning section image inputs
              learningImageInputContainer.style.display = 'none';
              clearLearningImageInputs(); // Clear the previews and controls

              progressDisplay.textContent = "";

              document.querySelector('.learning-section h2').textContent = 'Learn Decks'; // Reset title

               // Disable ALL card interaction buttons when no deck is loaded
              showAnswerBtn.disabled = true;
              nextCardBtn.disabled = true;
              previousCardBtn.disabled = true;
              markKnownBtn.disabled = true;
              markNeedsReviewBtn.disabled = true;
              resetStatusBtn.disabled = true;
              toggleFavoriteBtn.disabled = true;
              updateFavoriteButtonState(false); // Reset favorite button appearance

              highlighterBtn.disabled = true;
              highlighterBtn.classList.remove('active');
              highlighterBtn.textContent = 'Highlighter';
              isHighlighterActive = false;

              undoHighlightBtn.disabled = true;
              resetHighlightBtn.disabled = true;

               // Ensure text selection is disabled on the card text elements
                   // Also remove any previously attached click listeners (images)
                  removeImageClickListeners(cardFrontImageContainer);
                   removeImageClickListeners(cardBackImageContainer);
                  cardFrontTextContent.style.userSelect = 'none';
                  cardFrontTextContent.style.webkitUserSelect = 'none';
                  cardFrontTextContent.style.cursor = 'default';
                  cardBackTextContent.style.userSelect = 'none';
                  cardBackTextContent.style.webkitUserSelect = 'none';
                  cardBackTextContent.style.cursor = 'default';


              exportCurrentDeckBtn.disabled = true; // Export is disabled when no deck is loaded
              // deleteDeckBtn state depends on selected checkboxes, not loaded deck state

               // Do NOT clear checkboxes here, user might want to re-load or load favorites
         }

         function updateDeleteFolderButtonState() {
             const selectedValue = folderSelect.value;
             deleteFolderBtn.disabled = (selectedValue === "" || selectedValue === "new-folder-option");
             console.log("Delete Folder button state updated. Disabled:", deleteFolderBtn.disabled);
         }

         // Clears the image inputs in the creation section ONLY
         function clearCreationImageInputs() {
              console.log("Clearing creation image inputs.");
              creationFrontImagePreviewContainer.innerHTML = "";
              creationFrontImageControls.style.display = 'none';
              creationFrontImage = null;

              creationBackImagePreviewContainer.innerHTML = "";
              creationBackImageControls.style.display = 'none';
              creationBackImage = null;
         }

         // Clears the image inputs/previews in the learning section ONLY
         function clearLearningImageInputs() {
             console.log("Clearing learning image inputs.");
              learningFrontImagePreviewContainer.innerHTML = "";
              learningFrontImageControls.style.display = 'none';

              learningBackImagePreviewContainer.innerHTML = "";
              learningBackImageControls.style.display = 'none';
         }


        // --- Creation Logic ---

        // Revised Helper function to parse text input into an array of card objects
        function parseTextToCards(text) {
            console.log("Parsing text input into cards (revised split logic).");
            const cards = [];
            // Split the entire text by the separator '::'
            const blocks = text.split('::');
            console.log("Split into blocks:", blocks.length, blocks);

            // We expect blocks to be in pairs: blocks[0] is Front1, blocks[1] is Back1,
            // blocks[2] is Front2, blocks[3] is Back2, and so on.
            // If the total number of blocks is odd, the last block is the Front of the last card with no Back.
            // If the total number of blocks is 1, it's a single card with a Front and no Back.

            for (let i = 0; i < blocks.length; i += 2) {
                const frontBlock = blocks[i];
                const backBlock = blocks[i + 1]; // This will be undefined if blocks.length is odd and i is the last index

                const frontContent = frontBlock ? frontBlock.trim() : ''; // Trim front whitespace
                const backContent = backBlock ? backBlock : '';           // Do NOT trim back content generally, preserve formatting like indents/bullets

                // Only create a card object if there is *any* content in the front or back,
                // or if it's the very first block and it contains non-whitespace (to allow image-only cards created without text)
                if (frontContent !== '' || backContent !== '' || (i === 0 && frontBlock && frontBlock.trim() !== '')) {
                     cards.push({
                         front: frontContent,
                         back: backContent,
                         status: 'new', // New cards added start as new
                         isFavorite: false, // Default to not favorited
                         frontHighlighted: undefined, // No highlights initially
                         backHighlighted: undefined,
                         frontHighlightHistory: [], // Empty history initially
                         backHighlightHistory: [],
                         frontImage: undefined, // Images will be added later in the parseAndSaveBtn logic if present
                         backImage: undefined
                     });
                     console.log(`Created card ${cards.length}: Front trimmed length=${frontContent.length}, Back length=${backContent.length}`);
                 } else {
                     // This handles cases like leading '::' (blocks[0] is empty) or trailing '::' (last block is empty)
                     console.warn(`Skipping block pair due to empty content at index ${i}. Front trimmed length=${frontContent.length}, Back length=${backContent.length}.`);
                 }
            }

            console.log("Parsed cards from text (final):", cards);
            return cards;
        }


        parseAndSaveBtn.addEventListener('click', () => {
             console.log("Process Input button clicked.");
            const text = textInput.value;
            const newDeckName = deckNameInput.value.trim(); // Name for a NEW deck
            let folderName = "";

            const selectedAddDeckName = addDeckSelect.value; // Name of deck to ADD TO
            const isAddingToExisting = selectedAddDeckName !== "";
             console.log("Selected deck to add to:", selectedAddDeckName, "Is adding to existing:", isAddingToExisting);


            const hasCreationImages = creationFrontImage || creationBackImage;
             console.log("Creation images present:", hasCreationImages);

            // --- Validation ---
            if (!text && !hasCreationImages) {
                alert("Please enter text for cards, or add at least one image.");
                 console.warn("Process Input failed: No text and no images.");
                return;
            }

            if (!isAddingToExisting && !newDeckName) {
                alert("Please enter a NEW deck name OR select an existing deck to add cards to.");
                 console.warn("Process Input failed: No new name and no existing deck selected.");
                return;
            }
             if (isAddingToExisting && newDeckName) {
                 alert("Please either enter a NEW deck name OR select an existing deck to add to, but not both.");
                  console.warn("Process Input failed: Both new name and existing deck selected.");
                  return;
             }


            const decks = getAllDecksFromStorage();
            let targetDeck = null; // The deck object we will modify or create

            if (isAddingToExisting) {
                 console.log(`Attempting to load existing deck "${selectedAddDeckName}" for adding.`);
                targetDeck = decks[selectedAddDeckName];
                if (!targetDeck) {
                     alert(`Error: Could not find deck "${selectedAddDeckName}" to add cards to. It may have been deleted.`);
                     console.error(`Process Input failed: Target deck "${selectedAddDeckName}" not found.`);
                     // Reset the select dropdown as the option is invalid
                     addDeckSelect.value = "";
                     populateAddDeckSelect(); // Repopulate to remove the invalid option
                     return;
                }
                 // Ensure it's not the special Favorites key or Merged key
                 if (targetDeck.name === ALL_FAVORITES_KEY || targetDeck.name === MERGED_DECKS_KEY) {
                      alert(`Error: Cannot add cards directly to the "${targetDeck.name}" view. This is a dynamic view.`);
                      console.error(`Process Input failed: Attempted to add cards to special view "${targetDeck.name}".`);
                       addDeckSelect.value = ""; // Reset the select
                       return;
                 }
                 console.log("Existing deck loaded successfully:", targetDeck.name);
            } else { // Creating a new deck
                 console.log(`Attempting to create or overwrite deck "${newDeckName}".`);
                if (decks[newDeckName]) {
                     if (!confirm(`Deck "${newDeckName}" already exists. Do you want to overwrite it? This will replace the cards and reset progress/favorites/highlights/images for this deck.`)) {
                         console.log("Overwrite cancelled by user.");
                         return;
                     }
                     console.log(`Overwriting existing deck "${newDeckName}".`);
                } else {
                     console.log(`Creating new deck "${newDeckName}".`);
                }
                 // Check if the new deck name is a reserved key
                 if (newDeckName === ALL_FAVORITES_KEY || newDeckName === MERGED_DECKS_KEY) {
                      alert(`Error: The deck name "${newDeckName}" is reserved. Please choose a different name.`);
                      console.error("Process Input failed: Reserved deck name used.");
                      return;
                 }

                // Get folder name if selected
                 const selectedFolderValue = folderSelect.value;
                 if (selectedFolderValue === 'new-folder-option') {
                      folderName = newFolderNameInput.value.trim();
                 } else if (selectedFolderValue !== "") {
                      folderName = selectedFolderValue;
                 } else {
                      folderName = undefined; // No folder selected
                 }
                 console.log("Folder for new deck:", folderName || "None");

                // Initialize a new deck object
                targetDeck = {
                    name: newDeckName,
                    folder: folderName || undefined,
                    cards: [] // Start with an empty array for new cards
                };
            }

            // --- Process Cards from Input ---
            const newCardsFromText = parseTextToCards(text);
            let cardsToProcess = []; // The list of new cards generated from this input action


            // Handle images and text input together
            if (newCardsFromText.length > 0) {
                // If there's text input, process those cards
                 console.log("Text input parsed. Processing new cards from text.");
                 cardsToProcess = newCardsFromText;
                 if (hasCreationImages) {
                     console.log("Adding creation images to the *first* new card from text.");
                     // Add images only to the first card created from text
                     cardsToProcess[0].frontImage = creationFrontImage || undefined; // Use undefined if null
                     cardsToProcess[0].backImage = creationBackImage || undefined;   // Use undefined if null
                 }
            } else if (hasCreationImages) {
                 // If no text but images exist, create a single card just for the images
                 console.log("No text input, but images present. Creating a single card for images.");
                 cardsToProcess.push({
                     front: "", // Empty text fields
                     back: "",
                     status: 'new', // New cards added start as new
                     isFavorite: false, // Default to not favorited
                     frontHighlighted: undefined,
                     backHighlighted: undefined,
                     frontHighlightHistory: [],
                     backHighlightHistory: [],
                     frontImage: creationFrontImage || undefined,
                     backImage: creationBackImage || undefined
                 });
            } else {
                // This case should be caught by the initial validation, but as a safeguard
                 console.error("Logic error: Reached processing without text or images.");
                 alert("An unexpected error occurred: no content to process.");
                 return;
            }

             if (cardsToProcess.length === 0) {
                 console.warn("Processing resulted in 0 cards to add. Stopping save.");
                 alert("No valid cards were generated from the input.");
                 return;
             }
             console.log("Cards generated from input:", cardsToProcess);


            // --- Save the Deck ---
             if (isAddingToExisting) {
                  console.log(`Adding ${cardsToProcess.length} new card(s) to existing deck "${targetDeck.name}".`);

                  // --- FIX: Improved duplicate check logic ---
                  const uniqueNewCards = cardsToProcess.filter(newCard => {
                      // A new card is a duplicate if *any* existing card is considered equivalent
                      const isDuplicate = targetDeck.cards.some(existingCard => {
                          // If the new card has non-empty front text...
                          if (newCard.front.trim() !== "") {
                              // ...it's a duplicate if *any* existing card has the exact same non-empty front text.
                              // Images are ignored for text-based duplication check.
                              return existingCard.front === newCard.front;
                          }
                          // If the new card has NO front text...
                          else {
                              // ...it's a duplicate ONLY if *any* existing card also has NO front text
                              // AND has the exact same front image (both undefined, or both the same data URL)
                              // We explicitly check for presence of frontImage on BOTH cards for image-based duplication.
                              // Using == handles both undefined==undefined and string==string comparisons correctly for data URLs.
                              return existingCard.front.trim() === "" && existingCard.frontImage == newCard.frontImage; // Use == for comparing undefined and string values
                          }
                      });
                      // Keep the new card only if it is NOT a duplicate
                      if (isDuplicate) {
                           console.warn(`Skipping duplicate card: Front Text="${newCard.front}", Front Image=${newCard.frontImage ? 'Present' : 'Absent'}`);
                      }
                      return !isDuplicate;
                  });
                   // --- End FIX ---


                  if (uniqueNewCards.length < cardsToProcess.length) {
                       alert(`Skipped ${cardsToProcess.length - uniqueNewCards.length} card(s) with duplicate fronts (text or image) already existing in "${targetDeck.name}".`);
                  }

                  targetDeck.cards = targetDeck.cards.concat(uniqueNewCards); // Append unique new cards
                  console.log(`Deck "${targetDeck.name}" now has ${targetDeck.cards.length} cards.`);

             } else { // Creating a new deck or overwriting
                  console.log(`Setting ${cardsToProcess.length} card(s) for deck "${targetDeck.name}".`);
                 targetDeck.cards = cardsToProcess; // Replace cards array (for new/overwrite)
             }


            saveDeck(targetDeck); // Save the modified or new deck


            // --- Cleanup and UI Update ---
            alert(`Successfully processed input! ${cardsToProcess.length} card(s) ${isAddingToExisting ? `processed for "${targetDeck.name}" (unique cards added)` : `saved as "${targetDeck.name}"`}.`);

            textInput.value = ''; // Clear text input
            clearCreationImageInputs(); // Clear image inputs

            if (!isAddingToExisting) {
                 // Only clear new deck name and folder controls if a NEW deck was created
                 deckNameInput.value = '';
                 folderSelect.value = "";
                 newFolderNameInput.value = '';
                 newFolderNameInput.style.display = 'none';
                 // Reset the "Add to Existing" select to default when creating a new deck
                 addDeckSelect.value = "";
            } else {
                 // If adding to existing, clear the new deck name field just in case
                 deckNameInput.value = '';
                 // Keep the "add to" select value, as the user might add more
            }


             // Repopulate dropdowns/checkboxes to reflect changes (new deck, updated deck list for adding)
            populateFolderSelect();
            populateDeckSelect(); // This repopulates main deck checkboxes and favorites checkboxes
             populateAddDeckSelect(); // Crucial to update the "Add to Existing" list

             resetLearningArea(); // Clear learning area - forces user to click Load


        });

        folderSelect.addEventListener('change', () => {
             const selectedValue = folderSelect.value;
             console.log("Folder select changed. Value:", selectedValue);
             if (selectedValue === 'new-folder-option') {
                 console.log("Selected 'New Folder' option. Showing new folder input.");
                 newFolderNameInput.style.display = 'block';
                 newFolderNameInput.focus();
             } else {
                  console.log("Selected existing or default option. Hiding new folder input.");
                 newFolderNameInput.style.display = 'none';
                 newFolderNameInput.value = '';
             }
             updateDeleteFolderButtonState();
        });

        // Add listeners to the creation section select and input to manage their state
        addDeckSelect.addEventListener('change', () => {
             console.log("addDeckSelect changed. Value:", addDeckSelect.value);
             // If a deck is selected to add to, clear the new deck name input
             if (addDeckSelect.value !== "") {
                 deckNameInput.value = "";
                  // Also visually deemphasize the new deck name input?
                  // deckNameInput.disabled = true; // Or just rely on user input
             } else {
                 // deckNameInput.disabled = false;
             }
             // Folder select/input state is linked to newDeckName input, not addDeckSelect
        });

         deckNameInput.addEventListener('input', () => {
              console.log("deckNameInput changed. Value:", deckNameInput.value);
             // If the new deck name input has text, clear the "add to" select
             if (deckNameInput.value.trim() !== "") {
                 addDeckSelect.value = "";
             }
         });


        // --- Learning Logic ---

        // Modified Load Deck button listener (now loads selected checkboxes)
        loadDeckBtn.addEventListener('click', () => {
            console.log("Load Selected Deck(s) button clicked.");
             loadMergedDecks(); // This function now handles single or multiple selections
        });


        // New listener for the Load Filtered Favorites button
        loadFilteredFavoritesBtn.addEventListener('click', () => {
             loadFilteredFavorites();
        });


         // Function to process text with **syntax** highlighting
        function processSyntaxHighlighting(text) {
            // Replace **text** with <span class="syntax-highlight">text</span>
            // Use a non-greedy match (.*?) and ensure we don't create empty highlights
            return text.replace(/\*\*(.*?)\*\*/g, (match, p1) => {
                 if (p1.trim() === '') {
                     return match; // Don't highlight empty strings between **
                 }
                 return `<span class="syntax-highlight">${p1}</span>`;
            });
        }

        // Function to display the current card from the shuffled/original order
        function displayCurrentCard() {
             console.log("Displaying card:", currentCardIndex);
            if (!currentDeck || !currentDeck.cards || currentDeck.cards.length === 0 || !currentDeck.shuffledIndices || currentDeck.shuffledIndices.length === 0) {
                 console.log("No cards to display or deck state invalid.");
                 // Clear card content elements
                 cardFrontImageContainer.innerHTML = "";
                 cardFrontTextContent.innerHTML = "No cards available in this deck/view.";
                 cardBackImageContainer.innerHTML = "";
                 cardBackTextContent.innerHTML = "";

                 cardBack.classList.add('hidden'); // Hide back
                 cardFront.classList.remove('hidden'); // Ensure front is visible
                 isAnswerShowing = false; // Reset state

                 // Hide and clear learning section image inputs
                 learningImageInputContainer.style.display = 'none';
                 clearLearningImageInputs(); // Clear the previews and controls

                 updateFavoriteButtonState(false); // Reset favorite button appearance
                 updateHighlightButtons(false); // Disable highlight buttons initially
                  updateResetStatusButtonState(); // Disable Reset Status button state
                 updateProgressDisplay(); // Clear progress display or show 0/0

                 // Disable ALL card interaction buttons
                 showAnswerBtn.disabled = true;
                 nextCardBtn.disabled = true;
                 previousCardBtn.disabled = true;
                 markKnownBtn.disabled = true;
                 markNeedsReviewBtn.disabled = true;
                 resetStatusBtn.disabled = true;
                 toggleFavoriteBtn.disabled = true;
                 highlighterBtn.disabled = true;
                 highlighterBtn.classList.remove('active');
                 highlighterBtn.textContent = 'Highlighter';
                 isHighlighterActive = false;

                 undoHighlightBtn.disabled = true;
                 resetHighlightBtn.disabled = true;

               // Ensure text selection is disabled on the card text elements
                   // Also remove any previously attached click listeners (images)
                  removeImageClickListeners(cardFrontImageContainer);
                   removeImageClickListeners(cardBackImageContainer);
                  cardFrontTextContent.style.userSelect = 'none';
                  cardFrontTextContent.style.webkitUserSelect = 'none';
                  cardFrontTextContent.style.cursor = 'default';
                  cardBackTextContent.style.userSelect = 'none';
                  cardBackTextContent.style.webkitUserSelect = 'none';
                  cardBackTextContent.style.cursor = 'default';


                 exportCurrentDeckBtn.disabled = true; // Export is disabled when no deck is loaded
                 // deleteDeckBtn state depends on selected checkboxes, not loaded deck state

                 return;
             }

            // Ensure currentCardIndex is within bounds
             currentCardIndex = Math.max(0, Math.min(currentCardIndex, currentDeck.shuffledIndices.length - 1));

            // Get the actual card index from the shuffled/ordered indices array
            const actualCardIndex = currentDeck.shuffledIndices[currentCardIndex];
             console.log(`Shuffled index: ${currentCardIndex}, Actual card index: ${actualCardIndex}`);

             // Ensure the actual index is valid
             if (actualCardIndex < 0 || actualCardIndex >= currentDeck.cards.length) {
                 console.error("Invalid shuffled index encountered:", actualCardIndex, "Deck:", currentDeck.name);
                 // This indicates a serious issue with the shuffledIndices array or cards array mismatch.
                 // In a real app, you might want to regenerate shuffledIndices here or force a deck reload.
                 // For now, we'll display an error and disable controls.
                 cardFrontImageContainer.innerHTML = "";
                 cardFrontTextContent.innerHTML = "Error displaying card (index mismatch).";
                 cardBackImageContainer.innerHTML = "";
                 cardBackTextContent.innerHTML = "";

                 cardBack.classList.add('hidden');
                 cardFront.classList.remove('hidden');
                 isAnswerShowing = false;

                 // Hide and clear learning section image inputs
                 learningImageInputContainer.style.display = 'none';
                 clearLearningImageInputs();

                 updateFavoriteButtonState(false);
                 updateHighlightButtons(false); // Disable highlight buttons
                  updateResetStatusButtonState(); // Disable Reset Status button state
                 updateProgressDisplay();
                 // Keep controls disabled
                 showAnswerBtn.disabled = true;
                 nextCardBtn.disabled = true;
                 previousCardBtn.disabled = true;
                 markKnownBtn.disabled = true;
                 markNeedsReviewBtn.disabled = true;
                  resetStatusBtn.disabled = true; // Disable Reset Status button explicitly
                 toggleFavoriteBtn.disabled = true;
                 highlighterBtn.disabled = true; // Disable highlighter button
                 highlighterBtn.classList.remove('active'); // Reset highlighter state
                 highlighterBtn.textContent = 'Highlighter'; // Reset text
                 isHighlighterActive = false; // Reset highlighter mode

                  // Ensure text selection is disabled
                  removeImageClickListeners(cardFrontImageContainer);
                  removeImageClickListeners(cardBackImageContainer);
                  cardFrontTextContent.style.userSelect = 'none';
                  cardFrontTextContent.style.webkitUserSelect = 'none';
                  cardFrontTextContent.style.cursor = 'default';
                  cardBackTextContent.style.userSelect = 'none';
                  cardBackTextContent.style.webkitUserSelect = 'none';
                  cardBackTextContent.style.cursor = 'default';


                 exportCurrentDeckBtn.disabled = true;
                 // deleteDeckBtn.disabled is managed by updateDeckButtonStates based on selection

                 return;
             }

            const card = currentDeck.cards[actualCardIndex];
             console.log("Current card object:", card);
             console.log("Current card source:", card.sourceDeckName ? `${card.sourceDeckName} (Original Front: "${card.sourceCardFront}")` : currentDeck.name);


             // --- Display Image on Card Faces ---
             // Clear image containers on both faces and remove old listeners
             removeImageClickListeners(cardFrontImageContainer);
             cardFrontImageContainer.innerHTML = "";
             removeImageClickListeners(cardBackImageContainer);
             cardBackImageContainer.innerHTML = "";


             if (card.frontImage) {
                 const img = document.createElement('img');
                 img.src = card.frontImage;
                 img.alt = "Front Image";
                 cardFrontImageContainer.appendChild(img);
                 // Add click listener to the new image element for modal zoom
                 img.addEventListener('click', () => openImageModal(card.frontImage, 'Front Image'));
             }
             if (card.backImage) {
                 const img = document.createElement('img');
                 img.src = card.backImage;
                 img.alt = "Back Image";
                 cardBackImageContainer.appendChild(img);
                 // Add click listener to the new image element for modal zoom
                 img.addEventListener('click', () => openImageModal(card.backImage, 'Back Image'));
             }


            // --- Display Text Content on Card Faces ---
            // Process text content, prioritizing saved highlighted versions
            cardFrontTextContent.innerHTML = card.frontHighlighted || processSyntaxHighlighting(card.front);
            cardBackTextContent.innerHTML = card.backHighlighted || processSyntaxHighlighting(card.back);


            // Always show front and hide back when a new card is displayed
            cardFront.classList.remove('hidden');
            cardBack.classList.add('hidden');
            isAnswerShowing = false; // Reset state to show front


            // --- Update Learning Section Image Inputs ---
             // Clear previous previews
             clearLearningImageInputs(); // This also hides controls

             // Display current card's images in the learning section input previews
             // We need to pass the image data (dataUrl) from the *current card* object
             // Image editing in the learning section is ONLY allowed for a *single regular* deck view.
             if (currentDeck.name !== ALL_FAVORITES_KEY && currentDeck.name !== MERGED_DECKS_KEY) {
                  // Only show and populate image inputs if it's a regular deck view
                 if (card.frontImage) {
                     console.log("Displaying front image in learning input preview.");
                     displayImage(card.frontImage, learningFrontImagePreviewContainer, learningFrontImageControls);
                 }
                 if (card.backImage) {
                     console.log("Displaying back image in learning input preview.");
                     displayImage(card.backImage, learningBackImagePreviewContainer, learningBackImageControls);
                 }
                 // Show the learning image input container
                 learningImageInputContainer.style.display = 'flex';
             } else {
                  // If in Favorites or Merged view, hide the image input section completely
                  learningImageInputContainer.style.display = 'none';
             }


             // Update favorite button state
             updateFavoriteButtonState(card.isFavorite);

             // Update highlight button states based on current card face (front is visible initially)
             updateHighlightButtons(isAnswerShowing);

             // Update Reset Status button state based on current deck type (Favorites vs regular vs Merged)
             updateResetStatusButtonState(); // This helper determines state based on currentDeck.name


             // Enable ALL card interaction buttons initially
             showAnswerBtn.disabled = false;
             nextCardBtn.disabled = false;
             previousCardBtn.disabled = false;
             toggleFavoriteBtn.disabled = false;
             highlighterBtn.disabled = false;


             // Disable specific buttons based on the current view type
             markKnownBtn.disabled = (currentDeck.name === ALL_FAVORITES_KEY || currentDeck.name === MERGED_DECKS_KEY); // Individual status enabled ONLY for single regular deck view
             markNeedsReviewBtn.disabled = (currentDeck.name === ALL_FAVORITES_KEY || currentDeck.name === MERGED_DECKS_KEY); // Individual status enabled ONLY for single regular deck view

             resetStatusBtn.disabled = (currentDeck.name === ALL_FAVORITES_KEY || currentDeck.name === MERGED_DECKS_KEY); // Bulk status disabled for temporary views

             // Highlighter is disabled for temporary views because highlights are not saved persistently there
             highlighterBtn.disabled = (currentDeck.name === ALL_FAVORITES_KEY || currentDeck.name === MERGED_DECKS_KEY);
             // Undo/Reset states will be updated by updateHighlightButtons (also disabled for temporary views)


             exportCurrentDeckBtn.disabled = (currentDeck.name === ALL_FAVORITES_KEY || currentDeck.name === MERGED_DECKS_KEY); // Export enabled ONLY for single regular deck view
             // deleteDeckBtn state depends on selected checkboxes, not loaded deck


            updateProgressDisplay(); // Update display with current card number and overall progress

             // Ensure text selection is disabled on both text content areas by default
             // Unless highlighter is active
             cardFrontTextContent.style.userSelect = 'none';
             cardFrontTextContent.style.webkitUserSelect = 'none';
             cardFrontTextContent.style.cursor = 'default';
             cardBackTextContent.style.userSelect = 'none';
             cardBackTextContent.style.webkitUserSelect = 'none';
             cardBackTextContent.style.cursor = 'default';


             // Ensure highlighter button reflects current state and updates text selection on active face
             // Highlighter is only enabled if not a temporary view (checked above and in updateHighlightButtons)
             if (isHighlighterActive && currentDeck.name !== ALL_FAVORITES_KEY && currentDeck.name !== MERGED_DECKS_KEY) {
                 highlighterBtn.classList.add('active');
                 highlighterBtn.textContent = 'Highlighter (ON)';
                 // Allow text selection when active
                 const activeTextContent = isAnswerShowing ? cardBackTextContent : cardFrontTextContent;
                 activeTextContent.style.userSelect = 'text';
                 activeTextContent.style.webkitUserSelect = 'text';
                 activeTextContent.style.cursor = 'text';
                 // Ensure inactive face remains non-selectable
                 const inactiveTextContent = isAnswerShowing ? cardFrontTextContent : cardBackTextContent;
                 inactiveTextContent.style.userSelect = 'none';
                 inactiveTextContent.style.webkitUserSelect = 'none';
                 inactiveTextContent.style.cursor = 'default';
                 // Disable undo/reset while actively highlighting
                 undoHighlightBtn.disabled = true;
                 resetHighlightBtn.disabled = true;
            } else { // Highlighter is off or in a temporary view
                  highlighterBtn.classList.remove('active');
                  highlighterBtn.textContent = 'Highlighter';
                  // Disable text selection when inactive on BOTH faces (current and other)
                  cardFrontTextContent.style.userSelect = 'none';
                  cardFrontTextContent.style.webkitUserSelect = 'none';
                  cardFrontTextContent.style.cursor = 'default';
                  cardBackTextContent.style.userSelect = 'none';
                  cardBackTextContent.style.webkitUserSelect = 'none';
                  cardBackTextContent.style.cursor = 'default';
                 // Re-enable undo/reset buttons based on state *only if not in temporary view*
                 updateHighlightButtons(isAnswerShowing); // This helper already checks for temporary views
            }


        }

         // Helper to update the state of the undo and reset highlight buttons
         function updateHighlightButtons(isBackFace) {
             // Disable buttons immediately if no deck loaded or in a temporary view
             if (!currentDeck || !currentDeck.cards || currentDeck.cards.length === 0 || currentDeck.shuffledIndices.length === 0 || currentDeck.name === ALL_FAVORITES_KEY || currentDeck.name === MERGED_DECKS_KEY) {
                  undoHighlightBtn.disabled = true;
                  resetHighlightBtn.disabled = true;
                  return;
             }
              const actualCardIndex = currentDeck.shuffledIndices[currentCardIndex];
              if (actualCardIndex < 0 || actualCardIndex >= currentDeck.cards.length) {
                 undoHighlightBtn.disabled = true;
                 resetHighlightBtn.disabled = true;
                 return;
              }
             const card = currentDeck.cards[actualCardIndex];

              // Check if there is saved highlighted content or history for the *current* face's text
              const hasSavedHighlight = isBackFace ? card.backHighlighted : card.frontHighlighted;
              const hasHistory = isBackFace ? (card.backHighlightHistory && card.backHighlightHistory.length > 0) : (card.frontHighlightHistory && card.frontHighlightHistory.length > 0);

             undoHighlightBtn.disabled = !hasHistory; // Enable undo only if there's history
             resetHighlightBtn.disabled = !hasSavedHighlight; // Enable reset only if there's saved highlighted content

              // Ensure undo/reset are disabled if highlighter mode is ON
              if (isHighlighterActive) {
                  undoHighlightBtn.disabled = true;
                  resetHighlightBtn.disabled = true;
              }
             // console.log(`Highlight buttons state updated (Back face: ${isBackFace}, Temporary View: ${currentDeck.name === ALL_FAVORITES_KEY || currentDeck.name === MERGED_DECKS_KEY}): Undo Disabled = ${undoHighlightBtn.disabled}, Reset Disabled = ${resetHighlightBtn.disabled}`);
         }

         // Helper to update the state of the Reset Status button
         function updateResetStatusButtonState() { // No longer needs currentCardStatus param
             // The button should be enabled if a regular deck is loaded (not temporary views)
             // The button performs a bulk action, so its state doesn't depend on the *current* card's status.
             // It's enabled if the deck is loaded and it's not a temporary view.
             resetStatusBtn.disabled = (!currentDeck || currentDeck.name === ALL_FAVORITES_KEY || currentDeck.name === MERGED_DECKS_KEY);
              // console.log(`Reset Status button state updated. Disabled: ${resetStatusBtn.disabled}`);
         }


        showAnswerBtn.addEventListener('click', () => {
             console.log("Show Answer button clicked. Current state:", isAnswerShowing);
            if (!currentDeck || currentDeck.cards.length === 0 || currentDeck.shuffledIndices.length === 0) {
                 console.warn("Show Answer button clicked but no cards loaded.");
                 return; // Should be disabled if no cards, but safety check
             }
            isAnswerShowing = !isAnswerShowing; // Toggle state
             console.log("New state:", isAnswerShowing);

            // Get the card faces and their containers
            const currentCardFaceElement = isAnswerShowing ? cardBack : cardFront;
            const otherCardFaceElement = isAnswerShowing ? cardFront : cardBack;

            const currentTextContentElement = isAnswerShowing ? cardBackTextContent : cardFrontTextContent;
             const otherTextContentElement = isAnswerShowing ? cardFrontTextContent : cardBackTextContent;

            // Update visibility
            otherCardFaceElement.classList.add('hidden');    // Hide the face that was showing
            currentCardFaceElement.classList.remove('hidden'); // Show the new face

             // Manage user-select on text content divs
             otherTextContentElement.style.userSelect = 'none'; // Disable select on the face that is now hidden
             otherTextContentElement.style.webkitUserSelect = 'none';
             otherTextContentElement.style.cursor = 'default';

             // Only enable text selection on the visible face IF highlighter is active AND not in a temporary view
             if (isHighlighterActive && currentDeck.name !== ALL_FAVORITES_KEY && currentDeck.name !== MERGED_DECKS_KEY) {
                 currentTextContentElement.style.userSelect = 'text';
                 currentTextContentElement.style.webkitUserSelect = 'text';
                 currentTextContentElement.style.cursor = 'text';
             } else {
                  currentTextContentElement.style.userSelect = 'none';
                  currentTextContentElement.style.webkitUserSelect = 'none';
                  currentTextContentElement.style.cursor = 'default';
             }


             // Update highlight button states based on the now visible face (and temporary view status)
             updateHighlightButtons(isAnswerShowing);
             // Reset Status button state is card-wide (based on the whole deck state), not face specific, no need to update here.

        });

         // --- Standard Navigation Button Logic ---

        nextCardBtn.addEventListener('click', () => {
            console.log("Next Card button clicked. Current index:", currentCardIndex);
            if (currentDeck && currentDeck.shuffledIndices.length > 0) {
                 currentCardIndex = (currentCardIndex + 1) % currentDeck.shuffledIndices.length; // Loop back to start
                 console.log("Moving to next card index:", currentCardIndex);
                displayCurrentCard(); // Display the next card (resets to front view)
            }
        });

        previousCardBtn.addEventListener('click', () => {
            console.log("Previous Card button clicked. Current index:", currentCardIndex);
             if (currentDeck && currentDeck.shuffledIndices.length > 0) {
                currentCardIndex = (currentCardIndex - 1 + currentDeck.shuffledIndices.length) % currentDeck.shuffledIndices.length; // Loop back to end
                 console.log("Moving to previous card index:", currentCardIndex);
                displayCurrentCard(); // Display the previous card (resets to front view)
            }
        });

        randomizeCheckbox.addEventListener('change', () => {
            console.log("Randomize checkbox changed. Checked:", randomizeCheckbox.checked);
            if (currentDeck && currentDeck.cards.length > 0) { // Only re-shuffle if a deck/view is loaded and has cards
                // Re-shuffle or reset order if randomization state changes while a deck is loaded
                const initialIndices = Array.from({length: currentDeck.cards.length}, (_, i) => i);
                if (randomizeCheckbox.checked) {
                     // Shuffle the original indices to get a new random order
                     currentDeck.shuffledIndices = shuffleArray(initialIndices);
                     console.log("Deck/View shuffled.");
                } else {
                     // If not random, reset to the original index order (0, 1, 2...)
                     // Note: For temporary views (Favorites/Merged), the original order isn't meaningful outside this session,
                     // but resetting to 0, 1, 2... is the predictable non-random order.
                     currentDeck.shuffledIndices = initialIndices;
                     console.log("Deck/View order reset to original.");
                }
                currentCardIndex = 0; // Start from the beginning of the new order
                 console.log("Resetting to card index 0 after reordering.");
                displayCurrentCard(); // Display the first card in the new order
                 // Note: shuffledIndices is NOT saved with the deck, it's session-specific.
            }
             // If no deck is loaded, the change just affects the setting for the *next* loaded deck/view
             console.log("Randomize setting updated.");
        });

        // Basic shuffling function (Fisher-Yates) - creates a new shuffled array
        function shuffleArray(array) {
            const shuffled = [...array]; // Work on a copy
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]]; // Swap elements
            }
            return shuffled;
        }


        // --- Favorite Logic ---

        function updateFavoriteButtonState(isFavorite) {
             if (isFavorite) {
                 toggleFavoriteBtn.textContent = 'Unmark Favorite';
                 toggleFavoriteBtn.classList.add('is-favorite');
             } else {
                 toggleFavoriteBtn.textContent = 'Mark as Favorite';
                 toggleFavoriteBtn.classList.remove('is-favorite');
             }
              // console.log(`Favorite button state updated. Is Favorite: ${isFavorite}, Class List: ${toggleFavoriteBtn.classList}`);
        }

        toggleFavoriteBtn.addEventListener('click', () => {
             console.log("Favorite button clicked.");
             if (!currentDeck || currentDeck.cards.length === 0 || currentDeck.shuffledIndices.length === 0) {
                  console.warn("Favorite button clicked but no cards loaded.");
                 return; // Should be disabled if no cards, but safety check
             }

             // Get the index in the shuffled array and the actual index in the cards array
             const currentShuffledIndex = currentCardIndex;
             const actualCardIndex = currentDeck.shuffledIndices[currentShuffledIndex];
             const card = currentDeck.cards[actualCardIndex]; // Get the current card object in the currentDeck array
             const wasFavorite = card.isFavorite;

             // Toggle favorite status in the in-memory object
             card.isFavorite = !card.isFavorite;
             console.log(`Toggling favorite for card (Actual Index ${actualCardIndex}). New state: ${card.isFavorite}`);


             // Update and save the original deck using the helper function
             // The helper function automatically copies favorite status from 'card' to 'originalCard'
             const updated = updateCardInOriginalDeck(card);


             if (!updated) {
                  console.error("Could not find original card to update favorite status. Reverting state.");
                  alert("Error updating favorite status. Could not find the original card in storage.");
                   // Revert the state in the temporary card object if we couldn't save
                  card.isFavorite = wasFavorite; // Revert in-memory change
                  updateFavoriteButtonState(card.isFavorite); // Revert button state
                   return; // Stop if save failed
             }

             console.log("Favorite status saved successfully.");

             // If we are in the ALL_FAVORITES_KEY view and just unmarked a card, remove it from the current session.
             // Check if the *currentDeck* object in memory is the special Favorites view
             if (currentDeck.name === ALL_FAVORITES_KEY && !card.isFavorite) {
                  console.log("Card unmarked as favorite in Favorites view. Removing from current session.");

                 // Remove the card from the *current temporary* shuffledIndices list
                 // Remove the element at the currentCardIndex in the shuffledIndices array
                 // This modifies the array in place
                 currentDeck.shuffledIndices.splice(currentShuffledIndex, 1);
                 console.log(`Removed index at shuffled position ${currentShuffledIndex} from shuffledIndices.`);
                 console.log(`shuffledIndices after removal: ${currentDeck.shuffledIndices.length} elements.`);

                 // We also need to remove the actual card object from the `currentDeck.cards` array
                 // to keep the in-memory temporary deck consistent.
                 // Find the index of the card object using its original source info
                 const cardToRemoveIndex = currentDeck.cards.findIndex(c =>
                      c.sourceDeckName === card.sourceDeckName && c.sourceCardFront === card.sourceCardFront
                 );
                  if (cardToRemoveIndex > -1) {
                       console.log(`Removing card object (original front "${card.sourceCardFront}" from deck "${card.sourceDeckName}") at index ${cardToRemoveIndex} from currentDeck.cards array.`);
                       currentDeck.cards.splice(cardToRemoveIndex, 1);
                       console.log(`currentDeck.cards after removal: ${currentDeck.cards.length} elements.`);
                  } else {
                       console.error("Could not find card object in currentDeck.cards array to remove after un-favoriting in Favorites view. This is inconsistent state.");
                  }


                  // --- Advance to the next card ---
                  if (currentDeck.shuffledIndices.length > 0) {
                       // The currentCardIndex variable represents the *position* in the `shuffledIndices` array.
                       // After splicing, the element that was previously at `currentShuffledIndex + 1` is now at `currentShuffledIndex`.
                       // So, the `currentCardIndex` variable naturally points to the next card in the sequence *unless*
                       // the card removed was the last one in the shuffled list.
                       // Correct wrap check: if the old `currentCardIndex` was >= the new length.
                       if (currentCardIndex >= currentDeck.shuffledIndices.length) {
                            console.log("Removed last card in shuffled list. Wrapping index to 0.");
                           currentCardIndex = 0; // Wrap around
                       }
                        // Otherwise, `currentCardIndex` remains the same and correctly points to the next card's position.
                        // It does NOT need to be incremented here because splice shifted the subsequent elements down.
                       console.log("Moving to next card after marking known. Current shuffled index remains:", currentCardIndex);
                       displayCurrentCard(); // Display the card at the (potentially wrapped) currentCardIndex
                  } else {
                       // No cards left in the session
                       console.log("No more favorite cards left in this view.");
                       alert("You've finished this learning session!");
                       resetLearningArea(); // Reset the learning area
                       populateDeckSelect(); // Refresh the deck list (which will also repopulate favorite sources)
                  }
             } else {
                  // If not in favorites view, or if favoriting, just update progress display and button state
                   console.log("Favorite status updated in regular/merged deck or card favorited. Updating UI.");
                  updateFavoriteButtonState(card.isFavorite); // Update button state visually
                  updateProgressDisplay(); // Update progress counts
             }

        });


        // --- Progress Tracking (Basic Status) ---

        // Helper function to find and update a card in its original deck in localStorage
        // updateFunc is an optional function that takes the original card object and modifies it
        // Returns true if successful, false otherwise.
        function updateCardInOriginalDeck(currentCard, updateFunc = null) { // updateFunc is now optional
             console.log("updateCardInOriginalDeck called.");
             if (!currentCard) {
                 console.error("updateCardInOriginalDeck called with null currentCard.");
                 return false;
             }

             let originalDeckName;
             let cardIdentifier; // Use original front text as identifier

             // Check if source info exists (it should for temporary views)
             if (currentCard.sourceDeckName && currentCard.sourceCardFront !== undefined) {
                 originalDeckName = currentCard.sourceDeckName;
                 cardIdentifier = currentCard.sourceCardFront; // Use original front text for lookup
                 console.log(`updateCardInOriginalDeck (Temporary View): Looking for card "${cardIdentifier || '(Empty Front)'}" in deck "${originalDeckName}".`);
             } else if (currentDeck.name && currentDeck.name !== ALL_FAVORITES_KEY && currentDeck.name !== MERGED_DECKS_KEY && currentCard.front !== undefined) {
                 // If it's a regular deck view, the original deck is the current deck
                 originalDeckName = currentDeck.name;
                 cardIdentifier = currentCard.front; // Use current front text for lookup
                  console.log(`updateCardInOriginalDeck (Regular View): Looking for card "${cardIdentifier || '(Empty Front)'}" in deck "${originalDeckName}".`);
             } else {
                 console.error("Could not determine original deck or card info for update. Card or currentDeck state is unexpected.");
                 console.log("currentCard:", currentCard);
                 console.log("currentDeck:", currentDeck);
                 return false;
             }


            if (originalDeckName && cardIdentifier !== undefined) {
                const decks = getAllDecksFromStorage();
                const originalDeck = decks[originalDeckName];

                if (originalDeck && Array.isArray(originalDeck.cards)) {
                     // Find the card in the original deck by its identifier (original front text)
                    const originalCardIndex = originalDeck.cards.findIndex(c => c.front === cardIdentifier);

                    if (originalCardIndex > -1) {
                        const originalCard = originalDeck.cards[originalCardIndex];
                         console.log("Original card found:", originalCard);

                        // Apply the provided update function if one was given
                         if (updateFunc && typeof updateFunc === 'function') {
                             console.log("Applying custom update function.");
                            updateFunc(originalCard); // This modifies the originalCard object
                         } else {
                              console.log("No custom update function provided, will copy properties.");
                         }

                         console.log("Original card after potential custom updateFunc:", originalCard);


                         // Copy highlight/image/status/favorite changes from the in-memory currentCard object
                         // (which might have been modified directly by highlight/image/favorite UI handlers)
                         // back to the originalCard object found in the decks array *before* saving.
                         // This ensures persistent changes from the learning UI are saved.
                         // Note: For regular decks, `currentCard` *is* the object from `currentDeck.cards[actualCardIndex]`.
                         // For temporary views, `currentCard` is a copy. This explicit copy makes the logic consistent.
                         // Only copy if currentCard has these properties (should always be the case now, but safe check).
                         if (currentCard.hasOwnProperty('status')) originalCard.status = currentCard.status;
                         if (currentCard.hasOwnProperty('isFavorite')) originalCard.isFavorite = currentCard.isFavorite;
                         if (currentCard.hasOwnProperty('frontHighlighted')) originalCard.frontHighlighted = currentCard.frontHighlighted;
                         if (currentCard.hasOwnProperty('backHighlighted')) originalCard.backHighlighted = currentCard.backHighlighted;
                         if (currentCard.hasOwnProperty('frontImage')) originalCard.frontImage = currentCard.frontImage;
                         if (currentCard.hasOwnProperty('backImage')) originalCard.backImage = currentCard.backImage;
                         // History is NOT copied.


                         console.log("Final original card state before saving:", originalCard);

                        // Save the modified original deck back to storage
                        saveDeck(originalDeck); // This calls the saveDeck that cleans history and temporary properties
                         console.log(`Original deck "${originalDeckName}" saved.`);

                        return true; // Success
                    } else {
                         console.error(`Could not find original card "${cardIdentifier || '(Empty Front)'}" in deck "${originalDeckName}" by front text for update.`);
                         // This could happen if the front text was edited *in the creation section* after the card was added.
                         // Or if the original deck was deleted after the session started.
                         // Attempting to find by other means (e.g., unique ID if we implemented one) would be more robust.
                         // For now, this is a limitation.
                    }
                } else {
                     console.error(`Could not find original deck "${originalDeckName}" in storage for update.`);
                     // Maybe the original deck was deleted?
                }
            } else {
                console.error("Missing information to find original card for update.");
            }
            return false; // Failure
        }


        // Helper function to apply a status to all cards in the current deck and save
         function applyStatusToAllCards(status) {
             console.log(`Attempting to apply status "${status}" to all cards.`);
             if (!currentDeck || !currentDeck.cards || currentDeck.cards.length === 0) {
                 console.warn("Cannot apply status to all cards: No deck loaded or deck is empty.");
                 alert("Please load a deck first.");
                 return false; // Indicate failure
             }

             // Disallow bulk status changes in temporary views
             if (currentDeck.name === ALL_FAVORITES_KEY || currentDeck.name === MERGED_DECKS_KEY) {
                 console.warn("Cannot apply status to all cards in Favorites or Merged views.");
                 alert("Cannot change status for all cards in this view. This view is a collection from one or more original decks.");
                 return false; // Indicate failure
             }

             // Confirmation for the action
             const confirmationMessage = `Are you sure you want to mark ALL ${currentDeck.cards.length} cards in deck "${currentDeck.name}" as "${status}"?`;
             if (!confirm(confirmationMessage)) {
                  console.log("Status change cancelled by user.");
                  return false; // Indicate cancellation
             }

             console.log(`Applying status "${status}" to all ${currentDeck.cards.length} cards in deck "${currentDeck.name}".`);

             // We need to update the status in the *original* decks in storage for this bulk action.
             // Fetch all decks first to ensure we have the latest state.
             const allDecks = getAllDecksFromStorage();

             let changesMade = false;
             // Bulk reset should ONLY apply to the deck currently loaded, if it's a regular deck.
             const deckToReset = allDecks[currentDeck.name];

             if (deckToReset && Array.isArray(deckToReset.cards)) {
                 console.log(`Applying bulk status "${status}" to all cards in original deck "${currentDeck.name}".`);
                  deckToReset.cards.forEach(card => {
                      card.status = status; // Update status
                  });
                  // Save the modified deck
                  saveDeck(deckToReset); // This updates the entry in the overall collection
                  changesMade = true;
                  console.log(`Bulk status change saved for deck "${currentDeck.name}".`);

                  // Also update the status in the *in-memory* currentDeck object if it's the same deck
                  // This ensures the UI immediately reflects the change without a full reload.
                   if (currentDeck.name === deckToReset.name) {
                       console.log("Updating in-memory currentDeck status to match bulk change.");
                       currentDeck.cards.forEach(card => {
                           card.status = status;
                       });
                       // Re-shuffle the session indices if randomization is on, or reset to original order
                        const initialIndices = Array.from({length: currentDeck.cards.length}, (_, i) => i);
                       currentDeck.shuffledIndices = randomizeCheckbox.checked ? shuffleArray(initialIndices) : initialIndices;
                        currentCardIndex = 0; // Reset index to 0 after reset
                         console.log("Resetting session order and index after bulk status change.");

                   }

             } else {
                  console.error(`Bulk status change failed: Could not find loaded deck "${currentDeck.name}" in storage.`);
                  alert("Error saving deck status changes. Deck not found in storage.");
                  return false; // Indicate failure
             }


             if (changesMade) {
                  // Update UI elements only if changes were made
                  updateProgressDisplay();
                   // Update the state of the Reset All button (it depends on deck type, not current card status anymore)
                  updateResetStatusButtonState();

                   // Re-display the current card based on the (potentially reordered) session
                  displayCurrentCard();


                  alert(`All cards in "${currentDeck.name}" have been marked as "${status}".`);

                  return true; // Indicate success
             } else {
                 console.warn("Bulk status change attempted but no deck was found or eligible.");
                 return false; // Indicate no changes were made
             }
         }

        // --- Mark Individual Card Known ---
        markKnownBtn.addEventListener('click', () => {
             console.log("Mark Known button clicked.");
             if (!currentDeck || currentDeck.cards.length === 0 || currentDeck.shuffledIndices.length === 0) {
                  console.warn("Mark Known button clicked but no cards loaded.");
                  alert("Please load a deck first.");
                 return;
             }
             // Disallow status changes in temporary views
             if (currentDeck.name === ALL_FAVORITES_KEY || currentDeck.name === MERGED_DECKS_KEY) {
                 console.warn("Cannot change status for individual cards in Favorites or Merged views.");
                 alert("Cannot change status for cards in this view. Change status from the original deck.");
                 return;
             }

             // Get the index in the shuffled array and the actual index in the cards array
             const currentShuffledIndex = currentCardIndex;
             const actualCardIndex = currentDeck.shuffledIndices[currentShuffledIndex];
             const card = currentDeck.cards[actualCardIndex]; // Get the in-memory card object

             console.log(`Marking card (Actual Index ${actualCardIndex}) as 'known'.`);

             // Update status in the in-memory object
             card.status = 'known';

             // Save the persistent change to localStorage using the helper
             // The helper function automatically copies status from 'card' to 'originalCard'
             const saved = updateCardInOriginalDeck(card);


             if (!saved) {
                  console.error("Failed to save 'known' status via updateCardInOriginalDeck.");
                  alert("Error saving card status.");
                  // Revert the change in memory if save failed? Complex, just log error for now.
                  // Card status in UI might be wrong now if save failed, but proceeding might break session.
                  // For simplicity, we'll proceed with UI change assuming save will usually work.
                  // The error is logged.
             } else {
                  console.log("Card status saved successfully.");

                  // --- Remove the card from the current session (shuffledIndices) ---
                   console.log(`Removing actual index ${actualCardIndex} from shuffled indices at current shuffled index ${currentShuffledIndex}.`);
                  // Remove the element at the currentCardIndex in the shuffledIndices array
                  currentDeck.shuffledIndices.splice(currentShuffledIndex, 1);
                   console.log(`shuffledIndices after removal: ${currentDeck.shuffledIndices.length} elements.`);


                  // --- Advance to the next card ---
                  if (currentDeck.shuffledIndices.length > 0) {
                       // The currentCardIndex variable represents the *position* in the `shuffledIndices` array.
                       // After splicing, the element that was previously at `currentShuffledIndex + 1` is now at `currentShuffledIndex`.
                       // So, the `currentCardIndex` variable naturally points to the next card in the sequence *unless*
                       // the card removed was the last one in the shuffled list.
                       // Correct wrap check: if the old `currentCardIndex` was >= the new length.
                       if (currentCardIndex >= currentDeck.shuffledIndices.length) {
                            console.log("Removed last card in shuffled list. Wrapping index to 0.");
                           currentCardIndex = 0; // Wrap around
                       }
                        // Otherwise, `currentCardIndex` remains the same and correctly points to the next card's position.
                        // It does NOT need to be incremented here because splice shifted the subsequent elements down.
                       console.log("Moving to next card after marking known. Current shuffled index remains:", currentCardIndex);
                       displayCurrentCard(); // Display the card at the (potentially wrapped) currentCardIndex
                  } else {
                       // No cards left in the session
                       console.log("No more cards left in this learning session.");
                       alert("You've finished this learning session!");
                       resetLearningArea(); // Reset the learning area
                       populateDeckSelect(); // Refresh the deck list (which also refreshes favorite sources)
                  }
             }


             // Update UI elements (always update progress display after a card status change)
             updateProgressDisplay(); // Update counts for the deck
             // Update the state of the Reset All button (it depends on deck state, not just current card)
             // updateResetStatusButtonState(); // No longer needed here, displayCurrentCard calls it or it's static for temporary views
        });

        // --- Mark Individual Card Needs Review ---
        markNeedsReviewBtn.addEventListener('click', () => {
             console.log("Mark Needs Review button clicked.");
             if (!currentDeck || currentDeck.cards.length === 0 || currentDeck.shuffledIndices.length === 0) {
                  console.warn("Mark Needs Review button clicked but no cards loaded.");
                   alert("Please load a deck first.");
                 return;
             }
             // Disallow status changes in temporary views
             if (currentDeck.name === ALL_FAVORITES_KEY || currentDeck.name === MERGED_DECKS_KEY) {
                 console.warn("Cannot change status for individual cards in Favorites or Merged views.");
                 alert("Cannot change status for cards in this view. Change status from the original deck.");
                 return;
             }

             const actualCardIndex = currentDeck.shuffledIndices[currentCardIndex];
             const card = currentDeck.cards[actualCardIndex]; // Get the in-memory card object

             console.log(`Marking card (Actual Index ${actualCardIndex}) as 'needsReview'.`);

             // Update status in the in-memory object
             card.status = 'needsReview';

              // Save the persistent change to localStorage using the helper
              // The helper function automatically copies status from 'card' to 'originalCard'
             const saved = updateCardInOriginalDeck(card);

             if (!saved) {
                  console.error("Failed to save 'needsReview' status via updateCardInOriginalDeck.");
                  alert("Error saving card status.");
                   // Revert the change in memory if save failed? Complex, just log error for now.
             } else {
                  console.log("Card status saved successfully.");
             }


             // Update UI elements
             updateProgressDisplay(); // Update counts for the deck
             updateResetStatusButtonState(); // Update the state of the Reset All button
             // Note: This button does NOT remove the card from the session or auto-advance.
             // The user explicitly requested this behavior only for "Mark Known".
        });


         // New Reset Status button listener (Bulk Action)
        resetStatusBtn.addEventListener('click', () => {
             // This button performs the bulk reset action using the existing applyStatusToAllCards helper
             applyStatusToAllCards('new');
        });


        function updateProgressDisplay() {
             console.log("Updating progress display.");
            if (currentDeck && currentDeck.cards && currentDeck.cards.length > 0) {

                const totalCardsInView = currentDeck.shuffledIndices ? currentDeck.shuffledIndices.length : currentDeck.cards.length; // Use cards.length if shuffledIndices is somehow missing/empty
                 const currentCardNumberDisplay = totalCardsInView > 0 ? currentCardIndex + 1 : 0;


                if (currentDeck.name === ALL_FAVORITES_KEY) {
                     // For Favorites view, just show count and current card number
                     const totalFavorites = currentDeck.cards.length; // Total cards currently in the favorite view
                     progressDisplay.innerHTML = `Card: ${currentCardNumberDisplay}/${totalCardsInView}<br>
                                                  Total Favorites in View: ${totalFavorites}`; // Clarify it's total in the view
                } else if (currentDeck.name === MERGED_DECKS_KEY) {
                     // For Merged view, show count and current card number, maybe total cards from original decks?
                     // Display deck names included? Title already shows this.
                     const totalCardsInMergedView = currentDeck.cards.length; // Total cards currently in the merged view
                     progressDisplay.innerHTML = `Card: ${currentCardNumberDisplay}/${totalCardsInView}<br>
                                                  Total Cards in Merged View: ${totalCardsInMergedView}`;
                     // Note: Status counts (known/review/new) and overall percentage are based on the ORIGINAL decks.
                     // Calculating these across multiple decks here would be complex and potentially slow on every update.
                     // Let's keep status/percentage display only for single regular decks.
                     // Or, if we show status, it's the status *of the card in its original deck*.
                     // Let's stick to simple counts for temporary views for now.

                } else {
                     // For regular decks, show standard progress counts
                     const knownCount = currentDeck.cards.filter(card => card.status === 'known').length;
                      const needsReviewCount = currentDeck.cards.filter(card => card.status === 'needsReview').length;
                      const newCount = currentDeck.cards.filter(card => card.status === 'new').length;
                     const totalCards = currentDeck.cards.length; // Total cards in the original deck
                     const knownPercentage = totalCards > 0 ? ((knownCount / totalCards) * 100).toFixed(0) : 0;


                    progressDisplay.innerHTML = `Card: ${currentCardNumberDisplay}/${totalCardsInView}<br>
                                                Deck Status: ${knownCount} Known / ${needsReviewCount} Review / ${newCount} New<br>
                                                Overall Progress: ${knownPercentage}% Known`;
                }
             console.log("Progress display updated.");
            } else {
                 progressDisplay.textContent = '';
                 console.log("Progress display cleared (no deck loaded).");
            }
        }


        // --- File Import/Export (Individual Deck Files) ---

        importDeckInput.addEventListener('change', (event) => {
             console.log("Import file selected.");
            const file = event.target.files[0];
            if (!file) {
                 console.log("No file selected for import.");
                return;
            }
             console.log("Import file:", file.name, "Type:", file.type, "Size:", file.size);
            const reader = new FileReader();

             reader.onloadstart = function() {
                  console.log("File read started for import.");
                  // Optional: Show loading indicator in UI
             };

            reader.onload = (e) => {
                 console.log("File read complete for import. Data size:", e.target.result ? e.target.result.length : 0);
                try {
                    const importedDeck = JSON.parse(e.target.result);
                    // Basic validation: Check if it looks like a deck object
                    if (importedDeck && typeof importedDeck.name === 'string' && Array.isArray(importedDeck.cards)) {
                         console.log("File appears to be a valid deck format.");

                         // Clean up and ensure necessary properties for imported cards
                         importedDeck.cards.forEach(card => {
                              if (!card || typeof card.front !== 'string' || typeof card.back !== 'string') { // Basic card structure check
                                   console.warn(`Card in imported deck "${importedDeck.name}" has invalid structure. Attempting to normalize.`);
                                   // Attempt to set defaults if missing, but this might indicate a corrupted file
                                   card.front = card.front || '';
                                   card.back = card.back || '';
                              }

                             // If importing from old format or SRS, set default status/favorite
                             if (!card.status || (card.status !== 'new' && card.status !== 'known' && card.status !== 'needsReview')) {
                                 card.status = 'new';
                             }
                              if (typeof card.isFavorite !== 'boolean') { // Add default favorite status if missing
                                 card.isFavorite = false;
                             }
                              // Initialize highlight properties if missing, or ensure they are strings/undefined
                              if (typeof card.frontHighlighted !== 'string' && typeof card.frontHighlighted !== 'undefined') card.frontHighlighted = undefined;
                              if (typeof card.backHighlighted !== 'string' && typeof card.backHighlighted !== 'undefined') card.backHighlighted = undefined;

                               // Initialize image properties if missing, or ensure they are strings/undefined
                               // Ensure data URLs are strings, otherwise set to undefined
                               if (typeof card.frontImage !== 'string' || (card.frontImage && !card.frontImage.startsWith('data:'))) card.frontImage = undefined; // Added check for null/empty string
                               if (typeof card.backImage !== 'string' || (card.backImage && !card.backImage.startsWith('data:'))) card.backImage = undefined; // Added check for null/empty string


                              // --- IMPORTANT for Import: Reset history, don't import it ---
                               // History is session/local state, not part of the permanent deck data.
                              card.frontHighlightHistory = [];
                              card.backHighlightHistory = [];


                             // Remove old SRS properties if they exist in the imported file
                             delete card.interval;
                             delete card.repetitions;
                             delete card.easeFactor;
                             delete card.dueDate;
                             // Also remove temporary source info if present from a favorited export (unlikely but safe)
                             delete card.sourceDeckName;
                             delete card.sourceCardFront;
                         });
                          // Ensure folder property exists (string or undefined)
                         if (typeof importedDeck.folder !== 'string' && typeof importedDeck.folder !== 'undefined') {
                            importedDeck.folder = undefined;
                         }


                         // We don't save shuffledIndices or display name with the deck file itself
                         delete importedDeck.shuffledIndices;
                         delete importedDeck.displayName; // Should not be on imported decks anyway, but safety


                         // Check if a deck with this name already exists and confirm overwrite
                         const existingDecks = getAllDecksFromStorage();
                         if (existingDecks[importedDeck.name]) {
                             if (!confirm(`A deck named "${importedDeck.name}" already exists in your browser. Do you want to overwrite it with the imported file? This will replace the existing deck and its progress/favorites/highlights/history/images.`)) {
                                 // User cancelled import
                                  console.log("Import cancelled by user (overwrite prompt).");
                                 event.target.value = ''; // Reset file input
                                 return;
                             }
                             console.log(`Overwriting existing deck "${importedDeck.name}" with imported data.`);
                         }

                         // Check if the imported deck name is a reserved key
                         if (importedDeck.name === ALL_FAVORITES_KEY || importedDeck.name === MERGED_DECKS_KEY) {
                              alert(`Error: The deck name "${importedDeck.name}" is reserved. Please choose a different name.`);
                              event.target.value = ''; // Reset file input
                               console.warn("Import failed: Reserved deck name used.");
                              return;
                         }

                         // Basic size checks for robustness
                         const maxDeckSize = 10000; // Example max cards
                         const maxCardFrontBackLength = 10000; // Increased example max chars per side text
                         const maxBase64Length = 5 * 1024 * 1024; // Increased example max length for base64 image data (approx 3.75MB binary)

                         if (importedDeck.cards.length > maxDeckSize) {
                             alert(`Imported deck "${importedDeck.name}" has too many cards (${importedDeck.cards.length}). Maximum allowed is ${maxDeckSize}. Import cancelled.`);
                             console.warn("Import failed: Deck size exceeds limit.");
                             event.target.value = '';
                             return;
                         }
                         for (const card of importedDeck.cards) {
                             if (card.front.length > maxCardFrontBackLength || card.back.length > maxCardFrontBackLength) {
                                 alert(`Card in imported deck "${importedDeck.name}" has text exceeding the character limit (${maxCardFrontBackLength} chars). Import cancelled.`);
                                 console.warn("Import failed: Card text size exceeds limit.");
                                 event.target.value = '';
                                 return;
                             }
                             if ((card.frontImage && card.frontImage.length > maxBase64Length) || (card.backImage && card.backImage.length > maxBase64Length)) {
                                  alert(`Card in imported deck "${importedDeck.name}" has images exceeding the size limit (${(maxBase64Length / 1024 / 1024).toFixed(1)} MB base64). Import cancelled.`);
                                 console.warn("Import failed: Card image size exceeds limit.");
                                 event.target.value = '';
                                 return;
                             }
                         }
                          console.log(`Imported deck "${importedDeck.name}" passed basic size validation.`);


                         // Save the imported deck to localStorage
                         saveDeck(importedDeck); // This updates the overall collection in localStorage

                         alert(`Deck "${importedDeck.name}" imported and saved to your browser successfully!`);
                         console.log(`Deck "${importedDeck.name}" imported successfully.`);

                         // Repopulate all dropdowns/checkboxes to include the newly imported deck
                         setTimeout(() => {
                              populateFolderSelect(); // Need to repopulate folders just in case
                              populateDeckSelect(); // This also calls populateFavoriteSourceSelect
                               populateAddDeckSelect(); // Update creation section select

                             // Don't automatically load, let the user click Load
                             resetLearningArea(); // Ensure current view is cleared
                         }, 50);


                    } else {
                        alert("Invalid flashcard deck file format. File must be a JSON object with 'name' (string) and 'cards' (array) properties.");
                         console.error("Import failed: Invalid file format.", importedDeck);
                    }
                } catch (error) {
                    alert("Error reading or parsing the file: " + error.message);
                    console.error("Error during file import:", error);
                } finally {
                    // Reset the file input so the same file can be selected again if needed
                    event.target.value = '';
                }
            };
             reader.onerror = function() {
                  alert("Error reading file: " + reader.error);
                   console.error("Error reading file during import:", reader.error);
                   event.target.value = ''; // Reset file input
             };
            reader.readAsText(file); // Read the file content as text
        });

        // Handle export current deck button click
        exportCurrentDeckBtn.addEventListener('click', () => {
            console.log("Export button clicked.");
            // Export is only allowed for a *single regular* deck that is currently LOADED
            if (!currentDeck || currentDeck.name === ALL_FAVORITES_KEY || currentDeck.name === MERGED_DECKS_KEY) {
                alert("Please load a single regular deck first before exporting.");
                 console.warn("Export attempted without a single regular deck loaded.");
                return;
            }

            // Ensure we export the current state of the deck from localStorage, not just the in-memory object
             const decks = getAllDecksFromStorage();
             const deckToExport = decks[currentDeck.name]; // Get the latest version

             if (!deckToExport) {
                 alert("Could not find the currently loaded deck in storage for export. Please try loading it again.");
                  console.error(`Could not find deck "${currentDeck.name}" in storage for export.`);
                 return;
             }
            console.log(`Preparing to export deck "${deckToExport.name}".`);

             // Clean up the deck object for export - remove temporary internal state
             const cleanedDeck = JSON.parse(JSON.stringify(deckToExport)); // Deep copy

             // --- IMPORTANT for Export: Remove history from exported file ---
              // History is session/local state, not part of the permanent deck data.
             cleanedDeck.cards.forEach(card => {
                 delete card.frontHighlightHistory;
                 delete card.backHighlightHistory;
                  // Ensure temporary source info is also removed, though shouldn't be on regular decks
                 delete card.sourceDeckName;
                 delete card.sourceCardFront;
             });

             delete cleanedDeck.shuffledIndices;
             delete cleanedDeck.displayName; // Should not be on regular decks anyway, but safety

            console.log("Cleaned deck object for export:", cleanedDeck);

            const dataStr = JSON.stringify(cleanedDeck, null, 2); // Pretty print JSON
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = `${deckToExport.name.replace(/[^a-z0-9]/gi, '_')}_flashcard_deck.json`; // Sanitize filename and add suffix
            document.body.appendChild(a); // Required for Firefox
            a.click(); // Trigger download
            document.body.removeChild(a); // Clean up
            URL.revokeObjectURL(url); // Free up the object URL

             console.log(`Deck "${deckToExport.name}" export initiated.`);
            // Optional: Inform user
            // alert(`Exported deck "${currentDeck.name}".`);
        });


        // --- Delete Deck(s) ---
        deleteDeckBtn.addEventListener('click', () => {
             console.log("Delete Selected Deck(s) button clicked.");
             const selectedDeckCheckboxes = deckCheckboxesContainer.querySelectorAll(`input[type="checkbox"]:checked`);
             // Only consider specific deck checkboxes, not the "All Decks" one for deletion
             const decksToDelete = Array.from(selectedDeckCheckboxes)
                                          .filter(cb => cb.value !== MERGED_DECKS_KEY)
                                          .map(cb => cb.value);

             console.log("Selected decks to delete:", decksToDelete);

            if (decksToDelete.length === 0) {
                 alert("Please select one or more decks to delete.");
                 console.warn("Delete attempted with no specific decks selected.");
                 return;
            }

             const confirmMessage = `Are you sure you want to delete the following ${decksToDelete.length} deck(s) from your browser's storage?\n\n- ${decksToDelete.join('\n- ')}\n\nFavorite status, progress, highlights, and images for cards in these decks will also be lost.\n\nThis action cannot be undone.`;

            if (confirm(confirmMessage)) {
                 console.log(`Deleting ${decksToDelete.length} deck(s).`);
                 const allDecks = getAllDecksFromStorage();
                 let currentDeckWasDeleted = false;

                 decksToDelete.forEach(deckName => {
                     if (allDecks[deckName]) {
                          console.log(`Deleting deck "${deckName}".`);
                         delete allDecks[deckName];
                         // Check if the currently loaded deck was among those being deleted
                         if (currentDeck && currentDeck.name === deckName) {
                             currentDeckWasDeleted = true;
                         }
                     } else {
                         console.warn(`Attempted to delete deck "${deckName}" but it was not found in storage.`);
                     }
                 });

                 saveAllDecksToStorage(allDecks);
                  console.log("Decks collection saved after deletion.");

                 // Reset learning area if the currently loaded deck was one of those deleted
                 if (currentDeckWasDeleted || (currentDeck && (currentDeck.name === ALL_FAVORITES_KEY || currentDeck.name === MERGED_DECKS_KEY))) {
                      // If a temporary view was loaded, it might contain cards from the deleted decks.
                      // Resetting is the safest approach.
                      console.log("Currently loaded view contained deleted decks. Resetting learning area.");
                      resetLearningArea();
                 }


                 alert(`Successfully deleted ${decksToDelete.length} deck(s).`);
                 // Re-populate dropdowns/checkboxes to reflect the deletion
                 populateFolderSelect();
                 populateDeckSelect(); // This repopulates main deck checkboxes and favorites checkboxes
                 populateAddDeckSelect(); // Update creation section select

            } else {
                 console.log("Deck deletion cancelled by user.");
            }
        });

        // --- Delete Folder ---
        deleteFolderBtn.addEventListener('click', () => {
             console.log("Delete Folder button clicked.");
             const selectedFolder = folderSelect.value;
             console.log("Selected folder to delete:", selectedFolder);

             if (selectedFolder === "" || selectedFolder === "new-folder-option") {
                 alert("Please select a specific folder to delete.");
                  console.warn("Delete folder attempted without selecting a specific folder.");
                 return;
             }

             const allDecks = getAllDecksFromStorage();
             const decksInFolder = Object.values(allDecks).filter(deck => (deck && typeof deck.folder === 'string' ? deck.folder.trim() : UNSORTED_FOLDER_KEY) === selectedFolder.trim());

             if (decksInFolder.length === 0) {
                  console.log(`Folder "${selectedFolder}" is empty.`);
                  if (confirm(`Folder "${selectedFolder}" appears empty. Do you want to delete it anyway?`)) {
                       // To delete an empty folder visually, we just need to repopulate the select boxes.
                       // The data structure implicitly doesn't store empty folders.
                       // Deleting the folder object itself from the storage is not necessary as it's derived from decks.
                       // Simply triggering repopulation is enough.
                       alert(`Folder "${selectedFolder}" removed from list.`);
                       console.log(`Empty folder "${selectedFolder}" removed from UI list.`);
                       populateFolderSelect(); // Repopulating removes the empty folder option
                       populateDeckSelect(); // Ensure deck select is also refreshed (and favorites source select)
                        populateAddDeckSelect(); // Update creation section select
                  } else {
                       console.log("Empty folder deletion cancelled by user.");
                  }
                  return;
             }


             const confirmMessage = `Are you sure you want to delete the folder "${selectedFolder}"?\n\nThis will also delete ${decksInFolder.length} deck(s) within this folder:\n- ${decksInFolder.map(d => d.name).join('\n- ')}\n\nFavorite status, progress, highlights, and images for cards in these decks will also be lost.\n\nThis action cannot be undone.`;

             if (confirm(confirmMessage)) {
                  console.log(`Deleting folder "${selectedFolder}" and its decks.`);
                  const decksAfterDeletion = {};
                  let currentDeckWasDeleted = false;

                  for (const deckName in allDecks) {
                       const deck = allDecks[deckName];
                       // Keep decks that are NOT in the selected folder and are not temporary views
                       if (deck && deck.name !== ALL_FAVORITES_KEY && deck.name !== MERGED_DECKS_KEY && (deck.folder || '').trim() !== selectedFolder.trim()) {
                           decksAfterDeletion[deckName] = deck;
                       } else if (deck && deck.name !== ALL_FAVORITES_KEY && deck.name !== MERGED_DECKS_KEY) {
                           // This deck IS in the folder being deleted
                            console.log(`Deleting deck "${deckName}" as part of folder deletion.`);
                           // Check if the currently loaded deck was this one
                           if (currentDeck && currentDeck.name === deckName) {
                                currentDeckWasDeleted = true;
                           }
                       } else {
                            // This is a temporary view or invalid deck, just keep it out of the save
                       }
                  }

                  saveAllDecksToStorage(decksAfterDeletion);
                   console.log("Decks collection saved after folder deletion.");

                  // Reset learning area if the currently loaded deck was in the deleted folder
                   if (currentDeckWasDeleted || (currentDeck && (currentDeck.name === ALL_FAVORITES_KEY || currentDeck.name === MERGED_DECKS_KEY))) {
                       // If a temporary view was loaded, it might contain cards from the deleted decks.
                       // Resetting is the safest approach.
                        console.log("Currently loaded view contained decks from the deleted folder. Resetting learning area.");
                       resetLearningArea();
                   }


                  alert(`Folder "${selectedFolder}" and its ${decksInFolder.length} deck(s) deleted.`);
                  populateFolderSelect(); // Refresh dropdowns
                  populateDeckSelect(); // This repopulates main deck checkboxes and favorites checkboxes
                   populateAddDeckSelect(); // Update creation section select
             } else {
                  console.log("Folder deletion cancelled by user.");
             }
        });


        // --- Highlighter Feature ---

        highlighterBtn.addEventListener('click', () => {
             console.log("Highlighter button clicked. Current state:", isHighlighterActive);
            // Disable highlighter functionality if no deck loaded or in a temporary view
            if (!currentDeck || currentDeck.cards.length === 0 || currentDeck.shuffledIndices.length === 0 || currentDeck.name === ALL_FAVORITES_KEY || currentDeck.name === MERGED_DECKS_KEY) {
                 console.warn("Highlighter button clicked but no cards loaded or in a temporary view. Ignoring.");
                 return;
            }

            isHighlighterActive = !isHighlighterActive; // Toggle highlighter mode
             console.log("Highlighter new state:", isHighlighterActive);

             // Determine which text content element is currently visible
             const activeTextContent = isAnswerShowing ? cardBackTextContent : cardFrontTextContent;
             const inactiveTextContent = isAnswerShowing ? cardFrontTextContent : cardBackTextContent;


            if (isHighlighterActive) {
                highlighterBtn.classList.add('active');
                highlighterBtn.textContent = 'Highlighter (ON)';
                 // Allow text selection when active
                 activeTextContent.style.userSelect = 'text';
                 activeTextContent.style.webkitUserSelect = 'text';
                 activeTextContent.style.cursor = 'text';
                 // Ensure inactive face remains non-selectable
                 inactiveTextContent.style.userSelect = 'none';
                 inactiveTextContent.style.webkitUserSelect = 'none';
                 inactiveTextContent.style.cursor = 'default';
                 // Disable undo/reset while actively highlighting
                 undoHighlightBtn.disabled = true;
                 resetHighlightBtn.disabled = true;
            } else {
                highlighterBtn.classList.remove('active');
                highlighterBtn.textContent = 'Highlighter';
                 // Disable text selection when inactive on BOTH faces (current and other)
                 activeTextContent.style.userSelect = 'none';
                 activeTextContent.style.webkitUserSelect = 'none';
                 activeTextContent.style.cursor = 'default';
                  inactiveTextContent.style.userSelect = 'none';
                  inactiveTextContent.style.webkitUserSelect = 'none';
                  inactiveTextContent.style.cursor = 'default';
                 // Re-enable undo/reset buttons based on state
                 updateHighlightButtons(isAnswerShowing); // This helper already checks for temporary views
            }
        });

        // Function to handle text selection and highlighting via mouseup on card faces
        function handleCardSelection(event) {
            // This listener is on the text-content divs now
            console.log("Mouseup on card text content.");
            // Only process when highlighter is active AND not in a temporary view
            if (!isHighlighterActive || !currentDeck || currentDeck.name === ALL_FAVORITES_KEY || currentDeck.name === MERGED_DECKS_KEY) {
                console.log("Highlighter is not active or in a temporary view. Ignoring selection.");
                return;
            }

            const selection = window.getSelection();
            const selectedText = selection.toString().trim();
            if (!selectedText) {
                console.log("No text selected or selection is just whitespace. Ignoring.");
                return; // No text selected
            }
            console.log("Selected text:", selectedText);

            // Check if selection is within the text content element it was triggered on
            const textContentElement = event.currentTarget;
            if (!textContentElement.classList.contains('card-text-content')) {
                console.warn("Mouseup target is not a text content element? Ignoring.", event.currentTarget);
                return; // Should not happen with the current listeners, but safety
            }

            // --- History: Save current state before applying highlight ---
            const actualCardIndex = currentDeck.shuffledIndices[currentCardIndex];
            const card = currentDeck.cards[actualCardIndex];
            const isBackFace = textContentElement.parentElement.classList.contains('back'); // Check parent (.card-face)
            const history = isBackFace ? card.backHighlightHistory : card.frontHighlightHistory;

            // Store the current HTML state of the text content element
            const currentHTML = textContentElement.innerHTML;

            // Check if the current HTML is different from the last history state to avoid duplicates
            if (history.length === 0 || history[history.length - 1] !== currentHTML) {
                // Add the current HTML to history, limiting the size
                history.push(currentHTML);
                if (history.length > MAX_HIGHLIGHT_HISTORY) {
                    history.shift(); // Remove the oldest state
                }
                console.log("Added current HTML to history. History size:", history.length);
            } else {
                console.log("Current HTML is same as last history state. Not adding.");
            }
            // --- End History ---

            try {
                // Get the range from the selection
                if (selection.rangeCount === 0) {
                    console.warn("No range in selection.");
                    return;
                }
                let range = selection.getRangeAt(0); // Use let so we can reassign

                // Ensure the selection is entirely within the current text content element
                if (!textContentElement.contains(range.startContainer) || !textContentElement.contains(range.endContainer)) {
                    console.warn("Selection spans outside the current text content element. Trying to normalize.");

                    // Create a new range that's contained within the text content element
                    const newRange = document.createRange();

                    // If start is outside, set it to the beginning of the text content
                    if (!textContentElement.contains(range.startContainer)) {
                        newRange.setStart(textContentElement, 0);
                    } else {
                        newRange.setStart(range.startContainer, range.startOffset);
                    }

                    // If end is outside, set it to the end of the text content
                    if (!textContentElement.contains(range.endContainer)) {
                        newRange.setEnd(textContentElement, textContentElement.childNodes.length);
                    } else {
                        newRange.setEnd(range.endContainer, range.endOffset);
                    }

                    // Replace the selection with our normalized range
                    selection.removeAllRanges();
                    selection.addRange(newRange);

                    // Update the range reference
                    range = newRange;
                    console.log("Selection normalized to fit within text content element.");
                     // If normalization resulted in no selected text, stop
                     if (range.toString().trim() === '') {
                         console.log("Normalized selection is empty. Ignoring.");
                         selection.removeAllRanges(); // Ensure it's cleared
                         return;
                     }
                }
                console.log("Selection is within the target text content element.");


                // Create a highlight span element (using the dedicated user-highlight class)
                const highlightSpan = document.createElement('span');
                highlightSpan.className = 'user-highlight'; // Use the specific class for user highlights
                highlightSpan.style.display = 'inline'; // Ensure inline display

                try {
                    // Try the standard surroundContents approach
                     console.log("Attempting standard surroundContents...");
                    range.surroundContents(highlightSpan);
                    console.log("Standard highlight span applied.");
                } catch (surroundError) {
                    console.warn("surroundContents failed, trying alternative approach:", surroundError);

                    // Alternative approach for complex selections (like across HTML nodes)
                    // This is a simplified version; more robust range manipulation is complex.
                    // For now, a basic fallback that wraps the *entire content* of the selected range
                    // might suffice for simple cases, but could break complex HTML.
                    // A better approach would involve iterating range contents.
                    // Given the current simple syntax highlighting (spans), surroundContents should usually work if the selection is valid.
                    // Let's just log the error and potentially fail gracefully for complex selections.
                    console.error('Alternative highlighting approach not fully implemented for complex selections. Error:', surroundError);
                    alert('Could not apply highlight to this complex selection. Please try selecting a single block of text.');
                     selection.removeAllRanges(); // Clear selection on error
                    return; // Stop processing
                }

                // Clear the selection after highlighting
                selection.removeAllRanges();
                console.log("Selection cleared.");

                // Save the new highlighted content of the text element persistently
                // The updateCardInOriginalDeck helper will handle copying the HTML from the in-memory card to the original
                saveHighlightedContent(isBackFace, textContentElement.innerHTML); // Pass the actual HTML content

            } catch (e) {
                console.error('Unexpected error during highlight application:', e);
                alert('An error occurred while applying the highlight: ' + e.message);
                selection.removeAllRanges(); // Attempt to clear selection even on error
                console.log("Error caught and selection cleared.");
            } finally {
                // Always update button states after a highlight attempt
                updateHighlightButtons(isAnswerShowing); // This helper already checks for temporary views
                console.log("Highlight button states updated.");
            }
        }

        // Function to save highlighted content back to the card object in storage
        // Pass the updated HTML content of the text area explicitly
        function saveHighlightedContent(isBackFace, updatedTextHTML) {
             console.log("saveHighlightedContent called (Back face:", isBackFace, ")");
            // Disallow saving changes if no deck loaded or in a temporary view
            if (!currentDeck || currentDeck.cards.length === 0 || currentDeck.shuffledIndices.length === 0 || currentDeck.name === ALL_FAVORITES_KEY || currentDeck.name === MERGED_DECKS_KEY) {
                 console.error("saveHighlightedContent called but no deck/card loaded or in a temporary view. Cannot save.");
                 // Revert the highlight in the UI visually if it was applied
                 displayCurrentCard();
                 return;
             }

            const actualCardIndex = currentDeck.shuffledIndices[currentCardIndex];
             if (actualCardIndex < 0 || actualCardIndex >= currentDeck.cards.length) {
                 console.error("Invalid actual card index during highlight save:", actualCardIndex);
                 // Revert the highlight in the UI visually
                 displayCurrentCard();
                 return;
             }

            const card = currentDeck.cards[actualCardIndex]; // This is the card object in the currentDeck array
             console.log("Updating in-memory card object for highlight.");
            // Update the highlighted property with the new HTML in the in-memory card object
            if (isBackFace) {
                card.backHighlighted = updatedTextHTML;
            } else {
                card.frontHighlighted = updatedTextHTML;
            }

            // Save the persistent change to the *original* card in storage using the helper
            // The helper updateCardInOriginalDeck copies the highlighted properties from 'card' to 'originalCard'
             const saved = updateCardInOriginalDeck(card);


             if (!saved) {
                  console.error("Failed to save highlight via updateCardInOriginalDeck.");
                  alert("Error saving highlight changes.");
                   // Revert the highlight in the UI if save failed?
                   displayCurrentCard(); // Attempt to revert visual change by re-displaying
             } else {
                  console.log("Highlight saved persistently.");
             }
             // No alert here, saving is implicit with highlighting
        }

        // --- Undo and Reset Highlight Logic ---

        undoHighlightBtn.addEventListener('click', () => {
             console.log("Undo Highlight button clicked.");
             // Disable changes if no deck or in a temporary view
             if (!currentDeck || currentDeck.cards.length === 0 || currentDeck.shuffledIndices.length === 0 || currentDeck.name === ALL_FAVORITES_KEY || currentDeck.name === MERGED_DECKS_KEY) {
                 console.warn("Cannot undo highlight changes if no deck loaded or in a temporary view.");
                 return;
             }


              const actualCardIndex = currentDeck.shuffledIndices[currentCardIndex];
              if (actualCardIndex < 0 || actualCardIndex >= currentDeck.cards.length) return;
              const card = currentDeck.cards[actualCardIndex]; // Get the card object in the currentDeck array


             const isBackFace = isAnswerShowing;
             const history = isBackFace ? card.backHighlightHistory : card.frontHighlightHistory;
             const textContentElement = isBackFace ? cardBackTextContent : cardFrontTextContent;

             if (history && history.length > 0) {
                 // Pop the last state from history
                 const previousHTML = history.pop();
                 console.log(`Popped state from history. History size: ${history.length}. Restoring HTML:`, previousHTML);

                 // Update the card face's text content HTML
                 textContentElement.innerHTML = previousHTML;

                 // Update the saved highlighted property in the in-memory card object
                 if (isBackFace) {
                     // If history is now empty, reset saved highlight to undefined, otherwise set to the state we just restored
                     card.backHighlighted = history.length > 0 ? previousHTML : undefined;
                 } else {
                      // If history is now empty, reset saved highlight to undefined, otherwise set to the state we just restored
                     card.frontHighlighted = history.length > 0 ? previousHTML : undefined;
                 }
                 console.log("In-memory card highlighted state updated after undo:", isBackFace ? card.backHighlighted : card.frontHighlighted);


                 // Save the updated state persistently
                 // The helper updateCardInOriginalDeck copies the highlighted properties from 'card' to 'originalCard'
                 const saved = updateCardInOriginalDeck(card);


                 if (!saved) {
                      console.error("Failed to save undo highlight via updateCardInOriginalDeck.");
                      alert("Error saving undo changes.");
                      // Revert undo in UI? Complex, just log error.
                 } else {
                     console.log("Undo highlight saved persistently.");
                 }

                 // Update button states
                 updateHighlightButtons(isBackFace); // This helper checks for temporary views
                  console.log("Highlight button states updated after undo.");

             } else {
                 console.log("Undo button clicked but highlight history is empty.");
                 // History is empty, nothing to undo
                 updateHighlightButtons(isBackFace); // Ensure button is disabled
             }
             // No alert here, undo is implicit
        });

        resetHighlightBtn.addEventListener('click', () => {
             console.log("Reset Highlight button clicked.");
             // Disable changes if no deck or in a temporary view
             if (!currentDeck || currentDeck.cards.length === 0 || currentDeck.shuffledIndices.length === 0 || currentDeck.name === ALL_FAVORITES_KEY || currentDeck.name === MERGED_DECKS_KEY) {
                 console.warn("Cannot reset highlight changes if no deck loaded or in a temporary view.");
                 return;
             }


              const actualCardIndex = currentDeck.shuffledIndices[currentCardIndex];
              if (actualCardIndex < 0 || actualCardIndex >= currentDeck.cards.length) return;
              const card = currentDeck.cards[actualCardIndex]; // Get the card object in the currentDeck array


             const isBackFace = isAnswerShowing;
             const textContentElement = isBackFace ? cardBackTextContent : cardFrontTextContent;

             // --- History: Save current state before resetting ---
              const history = isBackFace ? card.backHighlightHistory : card.frontHighlightHistory;
              const currentHTML = textContentElement.innerHTML;
              // Only push to history if it's a different state
              if (history.length === 0 || history[history.length - 1] !== currentHTML) {
                  history.push(currentHTML);
                  if (history.length > MAX_HIGHLIGHT_HISTORY) {
                      history.shift();
                  }
                   console.log("Added current HTML to history before reset. History size:", history.length);
              } else {
                   console.log("Current HTML is same as last history state before reset. Not adding.");
              }
             // --- End History ---


             // Get the original text for the current face
             const originalText = isBackFace ? card.back : card.front;
              console.log("Original text for reset:", originalText);

             // Process the original text to re-apply ** syntax highlighting only
             const cleanHTML = processSyntaxHighlighting(originalText);
             console.log("Clean HTML after processing original text:", cleanHTML);


             // Update the card face's text content HTML
             textContentElement.innerHTML = cleanHTML;

             // Clear the saved user-applied highlighted property in the in-memory card object
             if (isBackFace) {
                 card.backHighlighted = undefined; // Reset saved user highlight
                 // History is NOT cleared on reset, so undo can still revert to the state before reset.
             } else {
                 card.frontHighlighted = undefined; // Reset saved user highlight
             }
             console.log("In-memory card highlighted state set to undefined after reset.");


             // Save the updated state persistently
             // The helper updateCardInOriginalDeck copies the highlighted properties from 'card' to 'originalCard'
             const saved = updateCardInOriginalDeck(card);

              if (!saved) {
                   console.error("Failed to save reset highlight via updateCardInOriginalDeck.");
                   alert("Error saving reset changes.");
                    // Revert reset in UI?
                   displayCurrentCard(); // Attempt to revert visual change by re-displaying
              } else {
                   console.log("Reset highlight saved persistently.");
              }


             // Update button states
             updateHighlightButtons(isBackFace); // This helper checks for temporary views
             console.log("Highlight button states updated after reset.");
             // No alert here, reset is implicit
        });


        // Add event listeners for highlighting to the *text content* elements
        cardFrontTextContent.addEventListener('mouseup', handleCardSelection);
        cardBackTextContent.addEventListener('mouseup', handleCardSelection);


        // --- Generic Image Handling Helpers ---

        // Helper function to prevent default drag behaviors
        function preventDefaults(e) {
             e.preventDefault();
             e.stopPropagation();
        }

        // Helper function to display an image preview and show controls
         function displayImage(dataUrl, previewContainer, controlsElement) {
              console.log("Displaying image in preview container:", previewContainer.id);
              // Clear previous content
              previewContainer.innerHTML = '';

              const img = document.createElement('img');
              img.src = dataUrl;
              img.alt = "Image Preview";
              previewContainer.appendChild(img);
              controlsElement.style.display = 'flex'; // Show controls
              console.log("Image element created and appended. Controls displayed.");
         }


        // Helper function to handle dropped files (specifically images)
        // This function is generic and calls the specific callback with the dataUrl
        function handleDrop(e, previewContainer, controlsElement, onImageLoadCallback) {
             console.log("Drop event handled on target:", e.target.id);
             const dt = e.dataTransfer;
             const files = dt.files;

             if (files.length) {
                 const file = files[0]; // Only process the first file
                  console.log("Dropped file:", file.name, file.type, "size:", file.size);
                 if (file.type.match('image.*')) {
                     handleImageFile(file, previewContainer, controlsElement, onImageLoadCallback); // Pass the specific callback
                 } else {
                     alert('Please drop an image file.');
                      console.warn("Dropped file is not an image (type:", file.type, ").");
                      // Clear any temporary loading indicator if shown by dragenter handler
                      previewContainer.innerHTML = '';
                      controlsElement.style.display = 'none';
                 }
             } else {
                  console.log("No files dropped.");
                  // Clear any temporary loading indicator if shown by dragenter handler
                  previewContainer.innerHTML = '';
                  controlsElement.style.display = 'none';
             }
        }

        // Helper function to handle image files (reads as Data URL)
        function handleImageFile(file, previewContainer, controlsElement, onImageLoadCallback) {
             console.log("Handling image file:", file.name);

             // Optional: Add size limit check
              const MAX_FILE_SIZE_MB = 5; // Example limit for images
              const MAX_FILE_SIZE_BYTES = MAX_FILE_SIZE_MB * 1024 * 1024;
              if (file.size > MAX_FILE_SIZE_BYTES) {
                   alert(`Image file is too large (${(file.size / 1024 / 1024).toFixed(2)} MB). Please select an image smaller than ${MAX_FILE_SIZE_MB} MB.`);
                   previewContainer.innerHTML = ''; // Clear any loading indicator
                   controlsElement.style.display = 'none';
                   if (onImageLoadCallback) { // Call callback with null to indicate removal or failure
                       onImageLoadCallback(null); // Pass null to indicate image removal/failure
                       console.log("Image file too large, calling onImageLoadCallback(null)");
                   } else {
                       console.log("Image file too large, no onImageLoadCallback provided.");
                   }
                   console.warn("Image file too large.");
                   return; // Stop processing
              }


             const reader = new FileReader();

             reader.onloadstart = function() {
                  console.log("FileReader loading started.");
                 previewContainer.innerHTML = 'Loading image...'; // Show loading indicator
                 controlsElement.style.display = 'none'; // Hide controls during load
             }

             reader.onload = function(e) {
                  console.log("FileReader loading complete. Result type:", typeof e.target.result, "Size:", e.target.result ? e.target.result.length : 0);
                 // Call the callback first with the data URL
                 if (onImageLoadCallback) {
                      console.log("Calling onImageLoadCallback with Data URL.");
                      onImageLoadCallback(e.target.result); // Pass the data URL
                 } else {
                     console.warn("FileReader loaded image, but no onImageLoadCallback provided.");
                 }
                 // Then display the image in the preview using the Data URL
                 displayImage(e.target.result, previewContainer, controlsElement);
                  console.log("Image displayed in preview.");
             };

             reader.onerror = function() {
                 previewContainer.innerHTML = 'Error loading image.';
                 console.error("Error reading image file:", reader.error);
                 alert("Error loading image.");
                 // Call callback with null to signify failure? Depends on desired behavior.
                 // For now, just log/alert and leave previous state. If the callback clears state on null, it will work.
                 if (onImageLoadCallback) {
                      console.warn("FileReader error, calling onImageLoadCallback with null.");
                      onImageLoadCallback(null); // Pass null to indicate removal/failure
                 }
             }

             try {
                 reader.readAsDataURL(file); // Read the file as a Data URL
                  console.log("Calling readAsDataURL.");
             } catch (e) {
                 console.error("Error calling readAsDataURL:", e);
                 previewContainer.innerHTML = 'Error starting image load.';
                 alert("Error preparing image file.");
                 if (onImageLoadCallback) {
                      console.warn("Error starting readAsDataURL, calling onImageLoadCallback with null.");
                      onImageLoadCallback(null); // Pass null to indicate removal/failure
                 }
             }
        }

        // Helper function to handle image blobs (e.g., from clipboard)
         function handleImageBlob(blob, previewContainer, controlsElement, onImageLoadCallback) {
              console.log("Handling image blob (type:", blob.type, ", size:", blob.size, ")");
             // Treat blob like a file for reading purposes
             handleImageFile(blob, previewContainer, controlsElement, onImageLoadCallback);
         }


        // Helper function to handle items from clipboard read() - primarily for button paste
        // FIX: Added a check for item.types and item.type being defined before calling startsWith.
        function handleClipboardItems(items, previewContainer, controlsElement, onImageChangeCallback) {
             console.log("Handling clipboard items from button click:", items);
             let imageFound = false;
             // Iterate through items to find an image
             for (const item of items) {
                  console.log("Clipboard item:", item); // Log the item object itself

                  // Check if the item has a 'types' property and it's an array
                  if (item.types && Array.isArray(item.types)) {
                       console.log("Clipboard item types:", item.types); // Log the array of types

                       for (const type of item.types) { // Iterate through the types for the current item
                           // Ensure 'type' is a string before calling startsWith
                           if (typeof type === 'string' && type.startsWith('image/')) {
                                console.log("Found image type:", type);
                                // Get the blob for this specific image type
                                item.getType(type).then(blob => {
                                     console.log("Got image blob from clipboard item:", blob);
                                    handleImageBlob(blob, previewContainer, controlsElement, onImageChangeCallback); // Process the blob
                                }).catch(err => {
                                     console.warn(`Failed to get image data from clipboard type ${type} using navigator.clipboard.read():`, err); // Use 'type' variable here
                                     // Log the specific error name/message
                                    alert(`Failed to read from clipboard using the button. Error: ${err.message || 'Unknown error'}\n\nThis paste method often requires browser permissions or HTTPS. Please try pasting directly using Ctrl+V (or Cmd+V).`);
                                    // If reading failed, we should probably reset the preview state
                                    previewContainer.innerHTML = '';
                                    controlsElement.style.display = 'none';
                                    onImageChangeCallback(null); // Indicate removal or failure
                                });
                                imageFound = true; // Mark as found
                                // Break the inner loop (types) as we've found and are processing an image type for this item
                                break;
                           } else {
                                console.log(`Skipping clipboard item type "${type}" from button click.`);
                           }
                       }
                  } else if (item.type && typeof item.type === 'string' && item.type.startsWith('image/')) { // Fallback for older/different implementations? Unlikely for read() but safe.
                        console.log("Found image type on item:", item.type);
                         // For items with item.type directly (less common with modern async clipboard API read())
                          const blob = item.getAsFile(); // Attempt to get as File/Blob
                         if (blob) {
                              console.log("Got image blob from clipboard item (getAsFile):", blob);
                             handleImageBlob(blob, previewContainer, controlsElement, onImageChangeCallback);
                             imageFound = true;
                             break;
                         } else {
                              console.warn(`Clipboard item type is image/* but getAsFile() returned null during button paste.`);
                         }

                  } else {
                       console.log("Clipboard item does not have image types or valid structure from button click.", item);
                  }

                  // If an image was found in the current item, we can stop processing subsequent items too
                  if (imageFound) {
                       break; // Break the outer loop (items)
                  }
             }
             if (!imageFound) {
                 alert('No image found in clipboard.');
                 console.log("No image type found in clipboard items from button click.");
             }
        }


        // --- Setup Functions for Image Inputs (Creation & Learning) ---

        // Function to set up drag/drop, remove, and paste button listeners for a specific input zone
        function setupImageInput(dropZone, previewContainer, controlsElement, removeBtn, pasteBtn, onImageChangeCallback) {
             console.log(`Setting up image input listeners for dropZone ID: ${dropZone.id}`);

             // Prevent default drag behaviors
             ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                  dropZone.addEventListener(eventName, preventDefaults, false);
             });

             // Highlight drop zone on drag over
             ['dragenter', 'dragover'].forEach(eventName => {
                  dropZone.addEventListener(eventName, () => {
                       dropZone.classList.add('active');
                  }, false);
             });

             // Remove highlight on drag leave or drop
             ['dragleave', 'drop'].forEach(eventName => {
                  dropZone.addEventListener(eventName, () => {
                       dropZone.classList.remove('active');
                  }, false);
             });

             // Handle dropped files
             dropZone.addEventListener('drop', (e) => {
                  console.log("Drop event on drop zone:", dropZone.id);
                   // Check if the deck is a temporary view before allowing drop in the learning section
                   if (dropZone.closest('.learning-section') && currentDeck && (currentDeck.name === ALL_FAVORITES_KEY || currentDeck.name === MERGED_DECKS_KEY)) {
                       console.warn("Attempted to drop image in a temporary view. Not allowed.");
                       alert("Cannot add/update images in this view. Add/update images in the original deck.");
                       preventDefaults(e); // Prevent browser default handling
                       // Re-display the current card to revert the temporary UI state (preview might have been cleared already by handleImageFile(null))
                       displayCurrentCard();
                       return; // Stop the drop process
                   }
                   // If allowed, handle the drop
                  handleDrop(e, previewContainer, controlsElement, onImageChangeCallback); // Pass the specific callback
             }, false);

             // Handle remove button click
             if (removeBtn) { // Ensure remove button exists
                 removeBtn.addEventListener('click', () => {
                      console.log("Remove button clicked for:", dropZone.id);

                       // Check if the deck is a temporary view before allowing removal in the learning section
                       if (dropZone.closest('.learning-section') && currentDeck && (currentDeck.name === ALL_FAVORITES_KEY || currentDeck.name === MERGED_DECKS_KEY)) {
                           console.warn("Attempted to remove image in a temporary view. Not allowed.");
                           alert("Cannot remove images in this view. Remove images from the original deck.");
                           // Re-display the current card to show the state before the attempted change
                            displayCurrentCard();
                           return; // Stop the removal process
                       }

                      previewContainer.innerHTML = ''; // Clear preview
                      controlsElement.style.display = 'none'; // Hide controls
                      onImageChangeCallback(null); // Call the specific callback with null to remove image
                      console.log("Image removed and callback executed for:", dropZone.id);
                 });
             } else {
                 console.warn("Remove button not found for dropZone ID:", dropZone.id);
             }


             // Handle paste button click (uses navigator.clipboard.read - may need permissions/HTTPS)
             if (pasteBtn) { // Ensure paste button exists
                 pasteBtn.addEventListener('click', () => {
                      console.log("Paste button clicked for:", dropZone.id);

                       // Check if the deck is a temporary view before allowing paste in the learning section
                       if (dropZone.closest('.learning-section') && currentDeck && (currentDeck.name === ALL_FAVORITES_KEY || currentDeck.name === MERGED_DECKS_KEY)) {
                           console.warn("Paste attempted to add image in a temporary view via button. Not allowed.");
                           alert("Cannot add/update images in this view. Add/update images in the original deck.");
                            // Reset preview state as we can't proceed
                            previewContainer.innerHTML = '';
                            controlsElement.style.display = 'none';
                            onImageChangeCallback(null); // Indicate removal or failure
                           return; // Stop the paste process
                       }


                      // Use clipboard.read() if available (secure contexts/permissions)
                      if (navigator.clipboard && navigator.clipboard.read) {
                           console.log("Using navigator.clipboard.read()...");
                           navigator.clipboard.read().then(items => {
                               handleClipboardItems(items, previewContainer, controlsElement, onImageChangeCallback); // Pass the specific callback
                           }).catch(err => {
                               console.error('Failed to read clipboard using navigator.clipboard.read(): ', err);
                                // Log the specific error name/message
                               alert(`Failed to read from clipboard using the button. Error: ${err.message || 'Unknown error'}\n\nThis paste method often requires browser permissions or HTTPS. Please try pasting directly using Ctrl+V (or Cmd+V).`);
                                // Reset preview state if read failed
                                previewContainer.innerHTML = '';
                                controlsElement.style.display = 'none';
                                onImageChangeCallback(null); // Indicate removal or failure
                           });
                      } else {
                           // Fallback for contexts where clipboard.read is not available
                           alert('Clipboard reading using the button is not supported in this browser or context. Please try pasting directly using Ctrl+V.');
                           console.warn("navigator.clipboard.read() not supported.");
                           // Reset preview state as we can't proceed
                            previewContainer.innerHTML = '';
                            controlsElement.style.display = 'none';
                            onImageChangeCallback(null); // Indicate removal or failure
                      }
                 });
             } else {
                  console.warn("Paste button not found for dropZone ID:", pasteBtn ? pasteBtn.id : 'N/A', " for dropZone:", dropZone.id);
             }
        }


        // Global paste listener for the document (handles Ctrl+V, browser's paste command)
        document.addEventListener('paste', (e) => {
             console.log('Global Paste event detected:', e);
             // Check if paste is happening in a text input or textarea - if so, let the default happen
             const activeElement = document.activeElement;
             if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
                 console.log('Paste event inside input or textarea. Allowing default.');
                 return; // Let the browser handle text paste
             }


             if (e.clipboardData && e.clipboardData.items) {
                  console.log('ClipboardData available on paste event.');
                 // Determine which drop zone (if any) is focused or the closest ancestor
                 console.log('Active Element:', activeElement);

                 // Use closest() on the active element to find if it's inside one of our specific drop zones
                 const closestCreationFront = activeElement.closest('#creationFrontImageDropZone');
                 const closestCreationBack = activeElement.closest('#creationBackImageDropZone');
                 const closestLearningFront = activeElement.closest('#learningFrontImageDropZone');
                 const closestLearningBack = activeElement.closest('#learningBackImageDropZone');

                 console.log("Closest drop zones found:", { closestCreationFront, closestCreationBack, closestLearningFront, closestLearningBack });

                 let previewContainer = null;
                 let controlsElement = null;
                 let onImageChangeCallback = null;
                 let handled = false; // Flag to indicate if the paste was handled by our logic

                 if (closestCreationFront) {
                      previewContainer = creationFrontImagePreviewContainer;
                      controlsElement = creationFrontImageControls;
                      onImageChangeCallback = (dataUrl) => { creationFrontImage = dataUrl; }; // Simple assignment for creation
                      handled = true;
                      console.log("Paste target: Creation Front Image Drop Zone (via global paste)");
                 } else if (closestCreationBack) {
                      previewContainer = creationBackImagePreviewContainer;
                      controlsElement = creationBackImageControls;
                      onImageChangeCallback = (dataUrl) => { creationBackImage = dataUrl; }; // Simple assignment for creation
                      handled = true;
                      console.log("Paste target: Creation Back Image Drop Zone (via global paste)");
                 } else if (closestLearningFront) {
                    // Handle paste in learning section front drop zone
                     if (!currentDeck || currentDeck.cards.length === 0 || currentDeck.shuffledIndices.length === 0) {
                          console.warn("Paste attempted in learning section image input without a loaded card. Not handling.");
                          handled = false; // Ensure handled is false
                          // Do NOT prevent default, let browser handle if focus is elsewhere
                          return; // Exit listener
                     }
                     // Disallow changes in temporary views
                     if (currentDeck.name === ALL_FAVORITES_KEY || currentDeck.name === MERGED_DECKS_KEY) {
                         console.warn("Paste attempted to add image in a temporary view. Not allowed.");
                         alert("Cannot add/update images in this view. Add/update images in the original deck.");
                         handled = false; // Ensure handled is false
                         e.preventDefault(); // Prevent browser from pasting anything if in a temporary view
                         return; // Exit listener
                     }
                      const actualCardIndex = currentDeck.shuffledIndices[currentCardIndex];
                      const card = currentDeck.cards[actualCardIndex]; // Get the current card object


                      previewContainer = learningFrontImagePreviewContainer;
                      controlsElement = learningFrontImageControls;
                       // Define the callback logic specifically for learning section images
                      onImageChangeCallback = (dataUrl) => {
                           console.log("Learning Front Image Paste Callback (Global Paste):", dataUrl ? "Image received" : "Image removed (null)");
                           if (dataUrl === null) {
                                card.frontImage = undefined; // Set to undefined in-memory
                           } else {
                                card.frontImage = dataUrl; // Update in-memory card object
                           }

                          // Save the change persistently using the helper
                          // updateCardInOriginalDeck copies image properties from the in-memory card
                          const saved = updateCardInOriginalDeck(card);

                          if (saved) {
                               console.log("Learning front image saved successfully. Re-displaying card.");
                              // If save successful, re-render the main card face to show the image
                              displayCurrentCard(); // This will update the main card display
                              // UI preview is already updated by handleImageFile/Blob via displayImage()
                          } else {
                              console.error("Failed to save learning front image after paste.");
                              alert("Error saving image to deck after paste.");
                               // Revert the change in memory and UI preview if save failed
                              card.frontImage = undefined; // Revert in-memory change
                              learningFrontImagePreviewContainer.innerHTML = ""; // Clear preview
                              learningFrontImageControls.style.display = 'none'; // Hide controls
                              displayCurrentCard(); // Re-display to revert the main card image if it was changed visually before save failed
                          }
                      };
                      handled = true;
                      console.log("Paste target: Learning Front Image Drop Zone (via global paste)");

                 } else if (closestLearningBack) {
                     // Handle paste in learning section back drop zone
                     if (!currentDeck || currentDeck.cards.length === 0 || currentDeck.shuffledIndices.length === 0) {
                          console.warn("Paste attempted in learning section image input without a loaded card. Not handling.");
                          handled = false; // Ensure handled is false
                          // Do NOT prevent default, let browser handle if focus is elsewhere
                          return; // Exit listener
                     }
                      // Disallow changes in temporary views
                     if (currentDeck.name === ALL_FAVORITES_KEY || currentDeck.name === MERGED_DECKS_KEY) {
                         console.warn("Paste attempted to add image in a temporary view. Not allowed.");
                         alert("Cannot add/update images in this view. Add/update images from the original deck.");
                         handled = false; // Ensure handled is false
                         e.preventDefault(); // Prevent browser from pasting anything if in a temporary view
                         return; // Exit listener
                     }
                      const actualCardIndex = currentDeck.shuffledIndices[currentCardIndex];
                      const card = currentDeck.cards[actualCardIndex]; // Get the current card object


                      previewContainer = learningBackImagePreviewContainer;
                      controlsElement = learningBackImageControls;
                       // Define the callback logic specifically for learning section images
                      onImageChangeCallback = (dataUrl) => {
                           console.log("Learning Back Image Input Callback (Global Paste):", dataUrl ? "Image received" : "Image removed (null)");
                           if (dataUrl === null) {
                                card.backImage = undefined; // Set to undefined in-memory
                           } else {
                                card.backImage = dataUrl; // Update in-memory card object
                           }

                          // Save the change persistently using the helper
                          // updateCardInOriginalDeck copies image properties from the in-memory card
                          const saved = updateCardInOriginalDeck(card);

                          if (saved) {
                               console.log("Learning back image saved successfully. Re-displaying card.");
                              // If save successful, re-render the main card face to show the image
                              displayCurrentCard(); // This will update the main card display
                               // UI preview is already updated by handleImageFile/Blob via displayImage()
                          } else {
                              console.error("Failed to save learning back image after paste.");
                              alert("Error saving image to deck after paste.");
                               // Revert the change in memory and UI preview if save failed
                              card.backImage = undefined; // Revert in-memory change
                              learningBackImagePreviewContainer.innerHTML = ""; // Clear preview
                              learningBackImageControls.style.display = 'none'; // Hide controls
                              displayCurrentCard(); // Re-display to revert the main card image if it was changed visually before save failed
                          }
                      };
                      handled = true;
                      console.log("Paste target: Learning Back Image Drop Zone (via global paste)");
                 }


                 if (handled && previewContainer && controlsElement && onImageChangeCallback) {
                     console.log("Attempting to handle global paste data as image for the detected target.");
                     let imageFoundAndHandled = false;
                     for (let i = 0; i < e.clipboardData.items.length; i++) {
                         const item = e.clipboardData.items[i];
                          // Look for any image type
                         if (item.type && typeof item.type === 'string' && item.type.startsWith('image/')) { // Added check for item.type existence
                             const blob = item.getAsFile();
                              if (blob) {
                                   console.log("Image blob found via global paste. Processing with handleImageBlob.");
                                   handleImageBlob(blob, previewContainer, controlsElement, onImageChangeCallback);
                                   e.preventDefault(); // Prevent the default paste action only if an image is found and handled by our logic
                                   imageFoundAndHandled = true;
                                   break; // Stop processing items after finding and handling an image
                              } else {
                                   console.warn("Clipboard item type is image/* but getAsFile() returned null during global paste.");
                              }
                         } else {
                             console.log(`Skipping clipboard item type "${item.type}" as it's not an image.`);
                         }
                     }
                      if (!imageFoundAndHandled) {
                           console.log("Global paste event detected with items, but no image was found or handled by the specific target. Allowing default paste.");
                           // Do NOT prevent default if nothing was handled, let browser handle text paste etc.
                      } else {
                           console.log("Global paste event successfully handled as image.");
                      }
                 } else {
                     // This case means no relevant drop zone was targeted.
                      console.log("Global paste event did not target a specific image drop zone. Allowing default paste.");
                 }
             } else {
                  console.log('ClipboardData not available on paste event.');
             }
        });


         // --- Image Modal Logic ---

         function openImageModal(imageUrl, captionText) {
              console.log("Opening image modal:", { imageUrl, captionText });
              modalImage.src = imageUrl;
              modalCaption.textContent = captionText || '';
              imageModal.classList.add('visible'); // Use class to show/hide
         }

         function closeImageModal() {
              console.log("Closing image modal.");
              imageModal.classList.remove('visible');
              modalImage.src = ''; // Clear src when hidden
              modalCaption.textContent = ''; // Clear caption
         }

         // Close the modal when the close button is clicked
         modalClose.addEventListener('click', closeImageModal);

         // Close the modal when clicking anywhere on the overlay (but not the image itself)
         imageModal.addEventListener('click', (e) => {
             if (e.target === imageModal) { // Check if the click target is the modal background itself
                 closeImageModal();
             }
         });
         // Optional: Close with Escape key
         document.addEventListener('keydown', (e) => {
             if (e.key === 'Escape' && imageModal.classList.contains('visible')) {
                 closeImageModal();
             }
         });

        // Helper function to remove previous click listeners from images within a container
        // This is called *before* adding the image element in displayCurrentCard
        function removeImageClickListeners(containerElement) {
             console.log("Removing image click listeners (if any) from:", containerElement.id);
            // Find all img elements within the container
            const images = containerElement.querySelectorAll('img');
            images.forEach(img => {
                // To reliably remove listeners attached via addEventListener
                // without having access to the *specific* listener function instance,
                // cloning and replacing the node is a common technique.
                // However, since displayCurrentCard clears the container's innerHTML anyway,
                // the old elements (and their listeners) are removed from the DOM.
                // We just need to ensure we add the *new* listeners *after* creating the new img elements.
                // This function is primarily for safety/clarity before clearing.
                // Let's ensure the container is cleared in displayCurrentCard before appending new elements.
                 if (img && img.parentNode === containerElement) {
                      // We are replacing the content fully in displayCurrentCard, so removing explicitly here is less critical
                      // than ensuring new listeners are added. However, if we were just *updating* the src,
                      // explicit removal or using event delegation would be better.
                      // Given the current display approach (clear and rebuild), just ensuring the container is empty before appending is key.
                      // This function can remain minimal or serve as a reminder.
                      // The clearing of innerHTML happens in displayCurrentCard. No need to explicitly remove here.
                 }
            });
        }


        // --- Initialization ---

        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM fully loaded.");

            // Initialize app state - show main menu by default
            document.getElementById('mainMenu').style.display = 'flex';
            document.getElementById('creationSection').style.display = 'none';
            document.getElementById('learningSection').style.display = 'none';

            // Connect dark mode toggle to existing functionality
            document.getElementById('toggleDarkModeBtn').addEventListener('click', function() {
                document.body.classList.toggle('dark-mode');
            });

            populateFolderSelect();
            populateDeckSelect(); // This now populates main deck checkboxes and calls populateFavoriteSourceSelect
             populateAddDeckSelect(); // Populate the new dropdown

             resetLearningArea(); // Ensure learning UI is hidden initially

             // Set up image handling in the creation section
             setupImageInput(creationFrontImageDropZone, creationFrontImagePreviewContainer, creationFrontImageControls, removeCreationFrontImageBtn, creationFrontImagePasteBtn, (dataUrl) => { creationFrontImage = dataUrl; });
             setupImageInput(creationBackImageDropZone, creationBackImagePreviewContainer, creationBackImageControls, removeCreationBackImageBtn, creationBackImagePasteBtn, (dataUrl) => { creationBackImage = dataUrl; });

             // Set up image handling in the learning section
             // These callbacks now rely on updateCardInOriginalDeck to save changes
             setupImageInput(learningFrontImageDropZone, learningFrontImagePreviewContainer, learningFrontImageControls, removeLearningFrontImageBtn, learningFrontImagePasteBtn, (dataUrl) => {
                  // Callback for learning section front image input
                  console.log("Learning Front Image Input Callback:", dataUrl ? "Image received" : "Image removed (null)");
                   // The image input section is only visible for single regular decks,
                   // so currentDeck.name should not be a temporary key here.
                   // Safety check:
                   if (!currentDeck || currentDeck.name === ALL_FAVORITES_KEY || currentDeck.name === MERGED_DECKS_KEY) {
                       console.error("Image change attempted in learning section for unexpected deck type.");
                        alert("Error: Cannot set image on current card in this view.");
                        // Revert UI preview if it was changed temporarily
                       learningFrontImagePreviewContainer.innerHTML = "";
                       learningFrontImageControls.style.display = 'none';
                       displayCurrentCard(); // Re-display to sync main card image
                       return;
                   }


                   const actualCardIndex = currentDeck.shuffledIndices[currentCardIndex];
                   const card = currentDeck.cards[actualCardIndex]; // Get the in-memory card object (from the original deck in this case)

                  card.frontImage = dataUrl === null ? undefined : dataUrl; // Update the in-memory object (undefined if removed)

                  // Save the persistent change to localStorage
                  // updateCardInOriginalDeck will find the card by its front text in the original deck (currentDeck.name)
                   // and copy the updated frontImage property.
                  const saved = updateCardInOriginalDeck(card);

                  if (saved) {
                       console.log("Learning front image saved successfully. Re-displaying card.");
                       // If save successful, re-render the main card face to show the image
                       displayCurrentCard(); // This will update the main card display
                       // UI preview is already updated by handleImageFile/Blob via displayImage()
                  } else {
                       // If save failed, revert the in-memory change and the UI preview
                       console.error("Failed to save learning front image.");
                       alert("Error saving image to deck.");
                       card.frontImage = undefined; // Revert in-memory change
                       learningFrontImagePreviewContainer.innerHTML = ""; // Clear preview
                       learningFrontImageControls.style.display = 'none'; // Hide controls
                       displayCurrentCard(); // Re-display to revert the main card image if it was changed visually before save failed
                  }
             });

             setupImageInput(learningBackImageDropZone, learningBackImagePreviewContainer, learningBackImageControls, removeLearningBackImageBtn, learningBackImagePasteBtn, (dataUrl) => {
                  // Callback for learning section back image input
                   console.log("Learning Back Image Input Callback:", dataUrl ? "Image received" : "Image removed (null)");
                    // The image input section is only visible for single regular decks,
                   // so currentDeck.name should not be a temporary key here.
                    // Safety check:
                   if (!currentDeck || currentDeck.name === ALL_FAVORITES_KEY || currentDeck.name === MERGED_DECKS_KEY) {
                       console.error("Image change attempted in learning section for unexpected deck type.");
                        alert("Error: Cannot set image on current card in this view.");
                         // Revert UI preview if it was changed temporarily
                       learningBackImagePreviewContainer.innerHTML = "";
                       learningBackImageControls.style.display = 'none';
                       displayCurrentCard(); // Re-display to sync main card image
                       return;
                   }

                   const actualCardIndex = currentDeck.shuffledIndices[currentCardIndex];
                   const card = currentDeck.cards[actualCardIndex]; // Get the in-memory card object (from the original deck)

                  card.backImage = dataUrl === null ? undefined : dataUrl; // Update the in-memory object (undefined if removed)

                  // Save the persistent change to localStorage
                  // updateCardInOriginalDeck will find the card by its front text in the original deck (currentDeck.name)
                  // and copy the updated backImage property.
                  const saved = updateCardInOriginalDeck(card);

                  if (saved) {
                       console.log("Learning back image saved successfully. Re-displaying card.");
                       // If save successful, re-render the main card face to show the image
                       displayCurrentCard(); // This will update the main card display
                        // UI preview is already updated by handleImageFile/Blob via displayImage()
                  } else {
                       // If save failed, revert the in-memory change and the UI preview
                       console.error("Failed to save learning back image.");
                       alert("Error saving image to deck.");
                       card.backImage = undefined; // Revert in-memory change
                       learningBackImagePreviewContainer.innerHTML = ""; // Clear preview
                       learningBackImageControls.style.display = 'none'; // Hide controls
                       displayCurrentCard(); // Re-display to revert the main card image if it was changed visually before save failed
                  }
             });


        });

        // Add listener for deck checkboxes container changes to update button states
        deckCheckboxesContainer.addEventListener('change', updateDeckButtonStates);

         // Add listener for favorite source checkboxes container changes to update button states
         favoriteSourceCheckboxesContainer.addEventListener('change', updateFavoriteButtonStates);


    </script>
</body>
</html>
