<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flashcard App</title>

    <style>
        /* --- Base Styles (Light Mode Defaults) --- */
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px; /* Original padding */
            background-color: #f4f4f4; /* Light background default */
            color: #333; /* Dark text default */
            transition: background-color 0.3s ease, color 0.3s ease; /* Smooth transition */
        }

        h2 {
            color: #333; /* Dark headings */
            transition: color 0.3s ease; /* Smooth transition */
             margin-top: 0; /* Keep h2 margin */
             margin-bottom: 15px;
        }

        .container {
            display: flex; /* Keep flex for side-by-side sections */
            gap: 20px;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
             /* Centralize the container */
            max-width: 1200px; /* Maximum width for the content */
            margin: 20px auto; /* 20px top/bottom margin, auto left/right for centering */
            padding: 0 10px; /* Add some padding inside the container, just in case */
             box-sizing: border-box; /* Include padding in max-width */
        }

        .creation-section, .learning-section {
            flex: 1; /* Share width equally */
            min-width: 300px; /* Minimum width before wrapping */
            border: 1px solid #ccc; /* Light border */
            padding: 20px;
            border-radius: 8px;
            background-color: #fff; /* Light background */
            box-shadow: 0 0 10px rgba(0,0,0,0.05);
            transition: background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;

             /* No display: flex or flex-direction here */
        }

        textarea, input[type="text"], select {
            display: block; /* Still block for structure */
            width: calc(100% - 22px); /* Account for padding and border */
            margin-bottom: 10px;
            padding: 10px;
            border: 1px solid #ccc; /* Light border */
            border-radius: 4px;
            font-size: 1em;
            background-color: #fff;
            color: #333;
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
             box-sizing: border-box; /* Ensure padding/border included */
             width: 100%; /* Fill container width */
        }

         /* Specific width adjustments for folder dropdown and new folder input */
        .folder-controls select, .folder-controls input[type="text"] {
             width: 100%; /* Fill parent width */
             margin-bottom: 10px;
             box-sizing: border-box; /* Include padding/border in width */
             display: block; /* Ensure they stack */
        }
        .folder-controls label {
             display: block; /* Label above the dropdown */
             margin-bottom: 5px;
             font-weight: bold;
             font-size: 0.9em;
             color: #555; /* Slightly lighter dark text */
             transition: color 0.3s ease; /* Smooth transition */
        }
        .folder-controls {
             margin-bottom: 10px; /* Space below folder controls */
        }

        /* Style for folder delete button */
        .folder-controls button {
             margin-top: 5px; /* Space above delete button */
             margin-left: 0;
        }


        /* Make textarea and learning area scroll if content overflows */
        textarea {
            height: auto; /* Auto height based on content/rows */
            min-height: 150px; /* Ensure a minimum height */
            overflow-y: auto; /* Add scrollbar if content overflows */
            margin-bottom: 15px; /* Space below textarea */
        }

        #learningArea {
             /* No flex-grow here */
             overflow-y: auto; /* Add scrollbar if content overflows */
             min-height: 150px; /* Ensure a minimum height */
             margin-top: 20px; /* Keep original margin */
             text-align: center; /* Keep original text alignment */
             display: flex; /* Keep inner flex for card centering */
             flex-direction: column; /* Stack inner contents */
             align-items: center;
             justify-content: flex-start; /* Align to start now that it grows */
        }


        button {
            padding: 10px 15px;
            background-color: #007bff; /* Blue primary button */
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
            font-size: 1em;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        button:hover {
            background-color: #0056b3;
        }

         button:last-child {
             margin-right: 0;
         }

        /* Style for the Import Deck Label (made to look like a button) */
        input[type="file"] {
            display: none;
        }

        .button-like-label {
            display: inline-block;
            padding: 10px 15px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
             margin-bottom: 10px;
            font-size: 1em;
             transition: background-color 0.3s ease, color 0.3s ease;
        }

         .button-like-label:hover {
            background-color: #218838;
        }

        /* Text/Paragraphs related to file management */
        .creation-section p {
            margin-top: 15px;
             margin-bottom: 10px;
             font-weight: bold;
             color: #555;
        }


        /* Flashcard styling */
        .card {
            border: 1px solid #ddd; /* Light border */
            padding: 40px 20px;
            min-height: 150px;
            width: 90%;
            max-width: 500px;
             display: flex;
             align-items: center;
             justify-content: center;
            margin-bottom: 20px; /* Add margin below card */
            background-color: #fff; /* Light background */
            border-radius: 8px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
            font-size: 1.4em;
            white-space: pre-wrap;
            text-align: center;
             transition: background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
        }


         .card-face {
            width: 100%;
            height: 100%;
             display: flex;
             align-items: center;
             justify-content: center;
             padding: 0;
             box-sizing: border-box;
        }

        .hidden {
            display: none;
        }


        .controls, .progress-controls {
            margin-top: 15px;
            text-align: center;
            width: 100%;
        }

        .controls button, .progress-controls button {
            margin: 5px;
        }

         /* Specific styles for basic progress buttons (Mark Known/Needs Review) */
         .progress-controls button {
             padding: 10px 15px; /* Default button size */
             font-size: 1em; /* Default font size */
         }
         /* Ensure Mark Known/Needs Review buttons have appropriate colors */
         #markKnownBtn { background-color: #28a745; } /* Green */
         #markKnownBtn:hover { background-color: #218838; }
         #markNeedsReviewBtn { background-color: #ffc107; color: #333; } /* Yellow/Warning */
         #markNeedsReviewBtn:hover { background-color: #e0a800; }


         .progress-controls {
             border-top: 1px solid #eee; /* Light border */
             padding-top: 15px;
             margin-top: 15px;
              transition: border-color 0.3s ease;
         }


        #progressDisplay {
            margin-top: 10px;
            font-weight: bold;
            color: #555;
             transition: color 0.3s ease;
        }

        /* Optional preview area styles */
        /*
        .preview {
            border: 1px dashed #ccc;
            margin-top: 15px;
            padding: 10px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.9em;
            background-color: #f9f9f9;
            border-radius: 4px;
             transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        */


        /* --- Dark Mode Styles (Override Defaults) --- */
        body.dark-mode {
            background-color: #1e1e1e;
            color: #e0e0e0;
        }

        body.dark-mode h2 {
            color: #cccccc;
        }

        body.dark-mode .creation-section,
        body.dark-mode .learning-section {
            border-color: #333;
            background-color: #2d2d2d;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
        }

        body.dark-mode textarea,
        body.dark-mode input[type="text"],
        body.dark-mode select {
            border-color: #555;
            background-color: #3c3c3c;
            color: #e0e0e0;
        }

         body.dark-mode .folder-controls label {
             color: #b0b0b0;
         }
         body.dark-mode .creation-section p {
              color: #b0b0b0;
         }


        /* Adjust button colors for dark mode if desired, or keep them consistent */
        body.dark-mode button {
             background-color: #556cd6; /* Example: Darker primary button */
        }
        body.dark-mode button:hover {
            background-color: #4257b2;
        }
         /* Override specific button types in dark mode */
        body.dark-mode #markKnownBtn { background-color: #218838; } /* Darker Green */
        body.dark-mode #markKnownBtn:hover { background-color: #19742d; }
        body.dark-mode #markNeedsReviewBtn { background-color: #e0a800; color: #1e1e1e;} /* Darker Yellow */
        body.dark-mode #markNeedsReviewBtn:hover { background-color: #c49000; }


        body.dark-mode .button-like-label {
             background-color: #48a65f;
        }
         body.dark-mode .button-like-label:hover {
             background-color: #3a8c4e;
         }


        body.dark-mode .card {
             border-color: #555;
             background-color: #3c3c3c;
             box-shadow: 2px 2px 5px rgba(0,0,0,0.4);
        }

         body.dark-mode .progress-controls {
             border-top-color: #555;
         }

         body.dark-mode #progressDisplay {
             color: #b0b0b0;
         }

         /* Optional dark mode preview styles */
         /*
         body.dark-mode .preview {
            border-color: #555;
            background-color: #444;
            color: #e0e0e0;
         }
         */


        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                flex-direction: column; /* Stack creation/learning sections vertically */
                gap: 10px; /* Reduce gap on small screens */
                margin: 10px auto; /* Adjust margin on small screens */
                padding: 0 5px; /* Reduce padding inside container */
                max-width: 100%; /* Allow container to be full width */
            }
            .creation-section, .learning-section {
                min-width: auto;
                width: 100%; /* Ensure they take full width */
                padding: 15px; /* Reduce padding */
            }
             /* Adjust button/input stacking for small screens */
             .controls button, .progress-controls button, .file-controls button, .file-controls label,
             .folder-controls select, .folder-controls input[type="text"],
             .folder-controls button, /* Include folder button */
             textarea, input[type="text"]
             {
                 display: block;
                 width: 100%;
                 margin: 5px 0; /* Stack vertically */
                 box-sizing: border-box;
             }
              /* Override specific margins if necessary */
              /*
              button:last-child { margin-right: 0; }
              .button-like-label { margin-right: 0; }
              textarea { margin-bottom: 15px; }
              */

             .creation-section p {
                 text-align: left; /* Align file management text to left */
             }
             .card {
                 width: 100%; /* Card fills section width */
                 padding: 20px 10px; /* Adjust card padding */
                 font-size: 1.2em; /* Slightly smaller font on cards */
             }
             #progressDisplay {
                 text-align: center; /* Keep progress centered */
             }
        }

        /* Add styles for disabled buttons */
        button:disabled, .button-like-label:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Optional: Style for danger button */
        .danger-button {
             background-color: #dc3545;
        }
        .danger-button:hover {
             background-color: #c82333;
        }
        body.dark-mode .danger-button {
             background-color: #c82333;
        }
        body.dark-mode .danger-button:hover {
             background-color: #a71d2a;
        }

    </style>
</head>
<body class="dark-mode"> <!-- Starting in dark mode -->

    <div class="container">

        <section class="creation-section">
            <h2>Create/Update Deck</h2>
            <textarea id="textInput" rows="10" placeholder="Paste your text here. Use '::' to separate front and back, one card per line. Example: Apple :: A fruit"></textarea>

            <div class="folder-controls">
                <label for="folderSelect">Folder:</label>
                <select id="folderSelect">
                    <option value="">-- Select or Create Folder --</option>
                    <option value="new-folder-option">-- New Folder --</option>
                    <!-- Existing folders populated by JS -->
                </select>
                 <input type="text" id="newFolderNameInput" placeholder="Enter new folder name" style="display: none;">
                 <button id="deleteFolderBtn" class="danger-button">Delete Selected Folder</button>
            </div>

            <input type="text" id="deckNameInput" placeholder="Enter deck name">
            <button id="parseAndSaveBtn">Parse Text & Save/Update Deck</button>

            <p>Manage Files (Single Deck):</p>

             <input type="file" id="importDeckInput" accept=".json">
             <label for="importDeckInput" class="button-like-label">Import Deck File</label>
             <button id="exportCurrentDeckBtn">Export Loaded Deck File</button>
             <!-- Export All Decks Button is not included -->


            <!-- Optional: Preview Area -->
            <!-- <div id="previewArea" class="preview"> -->
                <!-- Parsed cards could be listed here temporarily -->
            <!-- </div> -->


        </section>

        <section class="learning-section">
            <h2>Learn Decks</h2>
            <select id="deckSelect">
                <option value="">-- Select a Deck --</option>
                <!-- Options populated by JavaScript from stored decks, grouped by folder -->
            </select>
            <button id="loadDeckBtn">Load Selected Deck</button>
             <button id="deleteDeckBtn" class="danger-button">Delete Selected Deck</button>

            <div id="learningArea" class="flashcard-area" style="display: none;">
                 <!-- <p id="sessionInfo"></p> --> <!-- Removed session info display -->
                <div id="flashcard" class="card">
                     <!-- Card content will be injected here by JS -->
                    <div id="cardFront" class="card-face front"></div>
                    <div id="cardBack" class="card-face back hidden"></div>
                </div>

                <div class="controls">
                    <button id="showAnswerBtn">Show Answer</button>
                     <!-- Navigation buttons are standard in this mode -->
                     <button id="previousCardBtn">Previous Card</button>
                     <button id="nextCardBtn">Next Card</button>
                </div>

                 <!-- Removed SRS Rating Controls -->
                 <!--
                 <div class="srs-controls" style="display: none;">
                      <button id="rateAgainBtn" class="again-button">Again</button>
                      <button id="rateGoodBtn" class="good-button">Good</button>
                      <button id="rateEasyBtn" class="easy-button">Easy</button>
                 </div>
                 -->


                <div class="progress-controls">
                     <!-- Basic progress tracking buttons -->
                     <button id="markKnownBtn">Mark as Known</button>
                     <button id="markNeedsReviewBtn">Needs Review</button>
                     <div>
                        <label>
                            <input type="checkbox" id="randomizeCheckbox"> Randomize Order
                        </label>
                     </div>
                     <div id="progressDisplay"></div>
                     <!-- <div id="sessionProgressDisplay"></div> --> <!-- Removed session progress display -->
                </div>
            </div>
        </section>
    </div>

    <script>
        // --- JavaScript Logic ---

        // Get references to HTML elements
        const textInput = document.getElementById('textInput');
        const folderSelect = document.getElementById('folderSelect');
        const newFolderNameInput = document.getElementById('newFolderNameInput');
        const deckNameInput = document.getElementById('deckNameInput');
        const parseAndSaveBtn = document.getElementById('parseAndSaveBtn');
        const deckSelect = document.getElementById('deckSelect');
        const loadDeckBtn = document.getElementById('loadDeckBtn');
        const flashcard = document.getElementById('flashcard');
        const cardFront = document.getElementById('cardFront');
        const cardBack = document.getElementById('cardBack');
        const showAnswerBtn = document.getElementById('showAnswerBtn');
        const nextCardBtn = document.getElementById('nextCardBtn');
        const previousCardBtn = document.getElementById('previousCardBtn');
        const randomizeCheckbox = document.getElementById('randomizeCheckbox');
        const markKnownBtn = document.getElementById('markKnownBtn'); // Re-added
        const markNeedsReviewBtn = document.getElementById('markNeedsReviewBtn'); // Re-added
        const progressDisplay = document.getElementById('progressDisplay');
        // const sessionProgressDisplay = document.getElementById('sessionProgressDisplay'); // Removed
        const importDeckInput = document.getElementById('importDeckInput');
        const exportCurrentDeckBtn = document.getElementById('exportCurrentDeckBtn');
        const deleteDeckBtn = document.getElementById('deleteDeckBtn');
        const learningArea = document.getElementById('learningArea');
        const deleteFolderBtn = document.getElementById('deleteFolderBtn');
        // const sessionInfoDisplay = document.getElementById('sessionInfo'); // Removed

         // Removed SRS Button References
         // const srsControls = document.getElementById('srs-controls');
         // const rateAgainBtn = document.getElementById('rateAgainBtn');
         // const rateGoodBtn = document.getElementById('rateGoodBtn');
         // const rateEasyBtn = document.getElementById('rateEasyBtn');


        let currentDeck = null; // { name: '...', folder: '...', cards: [{front:'...', back:'...', status:'...'}, ...], shuffledIndices: [...] }
        // let reviewQueue = []; // Removed review queue
        let currentCardIndex = 0; // Index within the shuffled/original order
        let isAnswerShowing = false;

        const DECK_STORAGE_KEY = 'flashcardsDecksCollection';
        const UNSORTED_FOLDER_KEY = "__UNSORTED__";


         // --- Deck Management (Collection in localStorage) ---

         // Helper to get all decks from localStorage
         function getAllDecksFromStorage() {
             try {
                return JSON.parse(localStorage.getItem(DECK_STORAGE_KEY) || '{}');
             } catch (e) {
                 console.error("Error parsing decks from localStorage:", e);
                 alert("Error loading your saved decks. Your local storage might be corrupted. Clearing storage to prevent further issues.");
                 localStorage.removeItem(DECK_STORAGE_KEY); // Clear corrupted data
                 return {};
             }
         }

         // Helper to save the entire decks collection to localStorage
         function saveAllDecksToStorage(allDecks) {
              localStorage.setItem(DECK_STORAGE_KEY, JSON.stringify(allDecks));
         }

        // Function to save a single deck (updates the collection in localStorage)
        function saveDeck(deck) {
            const decks = getAllDecksFromStorage();
            decks[deck.name] = deck; // Store/update by name
            saveAllDecksToStorage(decks); // Save the entire updated collection
            populateFolderSelect(); // Refresh folder dropdown
            populateDeckSelect(); // Refresh deck dropdown
        }

        // Function to load a deck by name
        function loadDeck(deckName) {
            const decks = getAllDecksFromStorage();
            const deckToLoad = decks[deckName];
            if (deckToLoad) {
                currentDeck = deckToLoad;
                currentCardIndex = 0; // Start at the beginning of the loaded deck

                // Ensure necessary properties exist for compatibility
                 if (!Array.isArray(currentDeck.cards)) {
                     console.error("Loaded deck has invalid cards array:", deckName);
                     alert("Error loading deck. Cards data is invalid.");
                     resetLearningArea();
                     return;
                 }
                 // Ensure basic status property exists (for compatibility with older saves or imported SRS decks)
                 currentDeck.cards.forEach(card => {
                     if (!card.status) card.status = 'new';
                     // Remove old SRS properties if they exist
                     delete card.interval;
                     delete card.repetitions;
                     delete card.easeFactor;
                     delete card.dueDate;
                 });
                 // Ensure folder property exists (even if undefined)
                 if (typeof currentDeck.folder !== 'string' && typeof currentDeck.folder !== 'undefined') {
                      currentDeck.folder = undefined;
                 }


                // Ensure shuffledIndices exists and is correct length, or create/recreate it
                if (!currentDeck.shuffledIndices || currentDeck.shuffledIndices.length !== currentDeck.cards.length) {
                     console.warn(`Deck "${deckName}" shuffled indices mismatch or missing. Re-generating original order.`);
                     currentDeck.shuffledIndices = Array.from({length: currentDeck.cards.length}, (_, i) => i);
                }

                // Apply randomization if checked (shuffles the indices)
                if (randomizeCheckbox.checked) {
                     currentDeck.shuffledIndices = shuffleArray(Array.from({length: currentDeck.cards.length}, (_, i) => i)); // Shuffle fresh indices
                } else {
                     // If not random, ensure it's in original order (0, 1, 2...)
                     currentDeck.shuffledIndices = Array.from({length: currentDeck.cards.length}, (_, i) => i);
                }

                displayCurrentCard(); // Display the first card in the chosen order
                updateProgressDisplay();
                // updateSessionProgressDisplay(); // Removed session progress
                // sessionInfoDisplay.textContent = ""; // Clear session info
                learningArea.style.display = 'flex';
                deckSelect.value = deckName; // Keep deck dropdown in sync

                 // Enable learning buttons (standard navigation)
                showAnswerBtn.disabled = false;
                nextCardBtn.disabled = false; // Navigation buttons enabled
                previousCardBtn.disabled = false; // Navigation buttons enabled
                 // srsControls.style.display = 'none'; // Hide SRS buttons (already removed from HTML)
                 markKnownBtn.disabled = false; // Basic progress buttons enabled
                 markNeedsReviewBtn.disabled = false; // Basic progress buttons enabled


                exportCurrentDeckBtn.disabled = false;


            } else {
                console.error("Deck not found in storage:", deckName);
                alert("Error loading deck. It might have been deleted or corrupted.");
                 resetLearningArea();
            }
        }

        function populateFolderSelect() {
             folderSelect.innerHTML = ''; // Clear current options

             const defaultOption = document.createElement('option');
             defaultOption.value = "";
             defaultOption.textContent = "-- Select or Create Folder --";
             folderSelect.appendChild(defaultOption);

             const newFolderOption = document.createElement('option');
             newFolderOption.value = "new-folder-option";
             newFolderOption.textContent = "-- New Folder --";
             folderSelect.appendChild(newFolderOption);

            const decks = getAllDecksFromStorage();
            const folders = new Set();

            Object.values(decks).forEach(deck => {
                if (deck.folder && typeof deck.folder === 'string' && deck.folder.trim()) {
                    folders.add(deck.folder.trim());
                }
            });

            Array.from(folders).sort().forEach(folderName => {
                const option = document.createElement('option');
                option.value = folderName;
                option.textContent = folderName;
                folderSelect.appendChild(option);
            });

            newFolderNameInput.style.display = 'none';
            newFolderNameInput.value = '';

            updateDeleteFolderButtonState();
        }


        function populateDeckSelect() {
            deckSelect.innerHTML = '<option value="">-- Select a Deck --</option>';
            const decks = getAllDecksFromStorage();
            const deckNames = Object.keys(decks);

            const groupedDecks = {};
            const UNSORTED_FOLDER_LABEL = "Unsorted Decks";

            deckNames.forEach(deckName => {
                const deck = decks[deckName];
                const folder = (deck.folder && typeof deck.folder === 'string' && deck.folder.trim()) || UNSORTED_FOLDER_KEY;
                if (!groupedDecks[folder]) {
                    groupedDecks[folder] = [];
                }
                groupedDecks[folder].push(deck);
            });

            const sortedFolders = Object.keys(groupedDecks).sort((a, b) => {
                if (a === UNSORTED_FOLDER_KEY) return 1;
                if (b === UNSORTED_FOLDER_KEY) return -1;
                return a.localeCompare(b);
            });

            sortedFolders.forEach(folderKey => {
                const folderDecks = groupedDecks[folderKey];
                folderDecks.sort((a, b) => a.name.localeCompare(b.name));

                const optgroup = document.createElement('optgroup');
                optgroup.label = (folderKey === UNSORTED_FOLDER_KEY) ? UNSORTED_FOLDER_LABEL : folderKey;

                folderDecks.forEach(deck => {
                    const option = document.createElement('option');
                    option.value = deck.name;
                    option.textContent = deck.name;
                    optgroup.appendChild(option);
                });

                deckSelect.appendChild(optgroup);
            });

             if(currentDeck && decks[currentDeck.name]) {
                 deckSelect.value = currentDeck.name;
             } else {
                 resetLearningArea();
                 deckSelect.value = "";
             }

             const hasDecks = deckNames.length > 0;
             loadDeckBtn.disabled = !hasDecks;
             deleteDeckBtn.disabled = !hasDecks;
             exportCurrentDeckBtn.disabled = !currentDeck; // Only enable if a deck is loaded
        }

         function resetLearningArea() {
              currentDeck = null;
              // reviewQueue = []; // Removed review queue
              currentCardIndex = 0; // Reset index

              learningArea.style.display = 'none';
              cardFront.textContent = "";
              cardBack.textContent = "";
              progressDisplay.textContent = "";
              // sessionProgressDisplay.textContent = ""; // Removed session progress
              // sessionInfoDisplay.textContent = ""; // Removed session info


              showAnswerBtn.disabled = true;
              nextCardBtn.disabled = true; // Navigation buttons disabled
              previousCardBtn.disabled = true; // Navigation buttons disabled
              // srsControls.style.display = 'none'; // Removed

              markKnownBtn.disabled = true; // Basic progress buttons disabled
              markNeedsReviewBtn.disabled = true; // Basic progress buttons disabled


              exportCurrentDeckBtn.disabled = true;
         }

         function updateDeleteFolderButtonState() {
             const selectedValue = folderSelect.value;
             deleteFolderBtn.disabled = (selectedValue === "" || selectedValue === "new-folder-option");
         }


        // --- Creation Logic ---

        parseAndSaveBtn.addEventListener('click', () => {
            const text = textInput.value;
            const deckName = deckNameInput.value.trim();
            let folderName = "";

            const selectedFolderValue = folderSelect.value;
            if (selectedFolderValue === 'new-folder-option') {
                folderName = newFolderNameInput.value.trim();
            } else {
                folderName = selectedFolderValue;
            }

            if (!text || !deckName) {
                alert("Please enter text for cards and a deck name.");
                return;
            }
            if (selectedFolderValue === 'new-folder-option' && !folderName) {
                 alert("Please enter a name for the new folder.");
                 newFolderNameInput.focus();
                 return;
            }


            const existingDecks = getAllDecksFromStorage();
            if (existingDecks[deckName]) {
                 if (!confirm(`Deck "${deckName}" already exists. Do you want to overwrite it? This will replace the cards and reset progress for this deck.`)) { // Reverted message
                     return;
                 }
            }


            const lines = text.split('\n');
            const cards = [];
            lines.forEach(line => {
                const parts = line.match(/^(.*?)::(.*)$/);
                if (parts && parts.length === 3 && parts[1].trim() && parts[2].trim()) {
                     cards.push({
                         front: parts[1].trim(),
                         back: parts[2].trim(),
                         status: 'new', // Start as new
                          // Removed SRS properties: interval, repetitions, easeFactor, dueDate
                      });
                } else if (line.trim() !== '') {
                    console.warn(`Skipping malformed or empty line: "${line.trim()}"`);
                }
            });

            if (cards.length > 0) {
                const newDeck = {
                    name: deckName,
                    folder: folderName || undefined,
                    cards: cards,
                    shuffledIndices: Array.from({length: cards.length}, (_, i) => i) // Initial order is unshuffled
                };

                saveDeck(newDeck);

                alert(`Deck "${deckName}" saved/updated with ${cards.length} cards${folderName ? ` in folder "${folderName}"` : ''}.`);
                textInput.value = '';
                 folderSelect.value = "";
                 newFolderNameInput.value = '';
                 newFolderNameInput.style.display = 'none';

                deckNameInput.value = '';

                 deckSelect.value = deckName;
                 resetLearningArea(); // Clear learning area - force user to click Load

            } else {
                alert("No valid flashcards found in the text. Ensure each line has a '::' separator and non-empty front/back sides.");
            }
        });

        folderSelect.addEventListener('change', () => {
             if (folderSelect.value === 'new-folder-option') {
                 newFolderNameInput.style.display = 'block';
                 newFolderNameInput.focus();
             } else {
                 newFolderNameInput.style.display = 'none';
                 newFolderNameInput.value = '';
             }
             updateDeleteFolderButtonState();
        });


        // --- Learning Logic ---

        loadDeckBtn.addEventListener('click', () => {
            const selectedDeckName = deckSelect.value;
            if (selectedDeckName) {
                loadDeck(selectedDeckName);
            } else {
                resetLearningArea();
                alert("Please select a deck to load.");
            }
        });

         // Function to display the current card from the shuffled/original order
        function displayCurrentCard() {
            if (!currentDeck || !currentDeck.cards || currentDeck.cards.length === 0 || !currentDeck.shuffledIndices || currentDeck.shuffledIndices.length === 0) {
                 cardFront.textContent = "No cards available in this deck.";
                 cardBack.textContent = "";
                 cardBack.classList.add('hidden'); // Hide back
                 cardFront.classList.remove('hidden'); // Ensure front is visible (or just show "No cards")
                 isAnswerShowing = false; // Reset state
                  updateProgressDisplay(); // Clear progress display or show 0/0
                 // Disable card controls if no cards
                 showAnswerBtn.disabled = true;
                 nextCardBtn.disabled = true; // Navigation buttons disabled
                 previousCardBtn.disabled = true; // Navigation buttons disabled
                 markKnownBtn.disabled = true; // Basic progress buttons disabled
                 markNeedsReviewBtn.disabled = true; // Basic progress buttons disabled
                 return;
            }

            // Ensure currentCardIndex is within bounds
             currentCardIndex = Math.max(0, Math.min(currentCardIndex, currentDeck.shuffledIndices.length - 1));


            // Get the actual card index from the shuffled/ordered indices array
            const actualCardIndex = currentDeck.shuffledIndices[currentCardIndex];
             // Ensure the actual index is valid
             if (actualCardIndex < 0 || actualCardIndex >= currentDeck.cards.length) {
                 console.error("Invalid shuffled index encountered:", actualCardIndex, "Deck:", currentDeck.name);
                 cardFront.textContent = "Error displaying card.";
                 cardBack.textContent = "";
                 cardBack.classList.add('hidden');
                 cardFront.classList.remove('hidden');
                 isAnswerShowing = false;
                 updateProgressDisplay();
                 return;
             }

            const card = currentDeck.cards[actualCardIndex];

            cardFront.textContent = card.front;
            cardBack.textContent = card.back;

            // Always show front and hide back when a new card is displayed
            cardFront.classList.remove('hidden'); // Make front visible
            cardBack.classList.add('hidden');     // Hide back
            isAnswerShowing = false; // Reset state to show front

             // Show/Enable relevant controls
             showAnswerBtn.disabled = false;
             nextCardBtn.disabled = false; // Navigation buttons enabled
             previousCardBtn.disabled = false; // Navigation buttons enabled
             markKnownBtn.disabled = false; // Basic progress buttons enabled
             markNeedsReviewBtn.disabled = false; // Basic progress buttons enabled


            updateProgressDisplay(); // Update display with current card number and overall progress
        }

        showAnswerBtn.addEventListener('click', () => {
            if (currentDeck && currentDeck.cards.length > 0) {
                if (!isAnswerShowing) {
                    // Currently showing front, show back
                    cardFront.classList.add('hidden');    // Hide front
                    cardBack.classList.remove('hidden'); // Show back
                    isAnswerShowing = true;

                     // Re-enable marking buttons after answer is shown (optional - could be always enabled)
                     // markKnownBtn.disabled = false;
                     // markNeedsReviewBtn.disabled = false;

                } else {
                    // Currently showing back, show front
                    cardBack.classList.add('hidden');    // Hide back
                    cardFront.classList.remove('hidden'); // Show front
                    isAnswerShowing = false;

                     // Maybe disable marking buttons again? Depends on desired flow.
                     // markKnownBtn.disabled = true;
                     // markNeedsReviewBtn.disabled = true;
                }
            }
        });

         // --- Standard Navigation Button Logic ---

        nextCardBtn.addEventListener('click', () => {
            if (currentDeck && currentDeck.shuffledIndices.length > 0) {
                 currentCardIndex = (currentCardIndex + 1) % currentDeck.shuffledIndices.length; // Loop back to start
                displayCurrentCard(); // Display the next card (resets to front view)
            }
        });

        previousCardBtn.addEventListener('click', () => {
             if (currentDeck && currentDeck.shuffledIndices.length > 0) {
                currentCardIndex = (currentCardIndex - 1 + currentDeck.shuffledIndices.length) % currentDeck.shuffledIndices.length; // Loop back to end
                displayCurrentCard(); // Display the previous card (resets to front view)
            }
        });

        randomizeCheckbox.addEventListener('change', () => {
            if (currentDeck) {
                // Re-shuffle or reset order if randomization state changes while a deck is loaded
                if (randomizeCheckbox.checked) {
                     // Shuffle the *original* indices to get a new random order
                     currentDeck.shuffledIndices = shuffleArray(Array.from({length: currentDeck.cards.length}, (_, i) => i));
                } else {
                     // If not random, reset to the original index order (0, 1, 2...)
                     currentDeck.shuffledIndices = Array.from({length: currentDeck.cards.length}, (_, i) => i);
                }
                currentCardIndex = 0; // Start from the beginning of the new order
                displayCurrentCard(); // Display the first card in the new order
                 // Save the current state including the new shuffled/unshuffled indices for this deck
                 saveDeck(currentDeck); // This saves the whole deck object, including the new shuffledIndices
            }
             // If no deck is loaded, the change just affects the setting for the *next* loaded deck
        });

        // Basic shuffling function (Fisher-Yates) - creates a new shuffled array
        function shuffleArray(array) {
            const shuffled = [...array]; // Work on a copy
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]]; // Swap elements
            }
            return shuffled;
        }

        // --- Progress Tracking (Basic Status) ---

        markKnownBtn.addEventListener('click', () => {
             if (currentDeck && currentDeck.cards.length > 0 && currentDeck.shuffledIndices.length > 0) {
                 const actualCardIndex = currentDeck.shuffledIndices[currentCardIndex];
                  if (actualCardIndex >= 0 && actualCardIndex < currentDeck.cards.length) {
                     currentDeck.cards[actualCardIndex].status = 'known';
                     saveDeck(currentDeck); // Save progress (saves the whole deck with updated status)
                     updateProgressDisplay();
                      // Optional: Move to the next card automatically after marking
                      // nextCardBtn.click();
                  }
             }
        });

        markNeedsReviewBtn.addEventListener('click', () => {
             if (currentDeck && currentDeck.cards.length > 0 && currentDeck.shuffledIndices.length > 0) {
                 const actualCardIndex = currentDeck.shuffledIndices[currentCardIndex];
                  if (actualCardIndex >= 0 && actualCardIndex < currentDeck.cards.length) {
                     currentDeck.cards[actualCardIndex].status = 'needsReview';
                     saveDeck(currentDeck); // Save progress
                     updateProgressDisplay();
                      // Optional: Move to the next card automatically after marking
                      // nextCardBtn.click();
                  }
             }
        });


        function updateProgressDisplay() {
            if (currentDeck && currentDeck.cards && currentDeck.cards.length > 0) {
                const knownCount = currentDeck.cards.filter(card => card.status === 'known').length;
                 const needsReviewCount = currentDeck.cards.filter(card => card.status === 'needsReview').length;
                 const newCount = currentDeck.cards.filter(card => card.status === 'new').length;
                const totalCards = currentDeck.cards.length;
                const knownPercentage = totalCards > 0 ? ((knownCount / totalCards) * 100).toFixed(0) : 0;

                 // Display current card number based on the *display* order (shuffled/unshuffled indices)
                 const currentCardNumberDisplay = currentDeck.shuffledIndices && currentDeck.shuffledIndices.length > 0 ? currentCardIndex + 1 : 0;
                 const totalCardsInView = currentDeck.shuffledIndices ? currentDeck.shuffledIndices.length : 0; // This should be the same as totalCards

                progressDisplay.innerHTML = `Card: ${currentCardNumberDisplay}/${totalCardsInView}<br>
                                            Deck Status: ${knownCount} Known / ${needsReviewCount} Review / ${newCount} New<br>
                                            Overall Progress: ${knownPercentage}% Known`;

            } else {
                 progressDisplay.textContent = '';
            }
        }


        // --- File Import/Export (Individual Deck Files) ---

        importDeckInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) {
                return;
            }
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedDeck = JSON.parse(e.target.result);
                    // Basic validation: Check if it looks like a deck object
                    if (importedDeck && typeof importedDeck.name === 'string' && Array.isArray(importedDeck.cards)) {

                         // Add default status and folder if missing from imported data (for compatibility)
                         importedDeck.cards.forEach(card => {
                             // If importing a file from the SRS version, preserve status if possible, otherwise default
                             if (!card.status || (card.status !== 'new' && card.status !== 'known' && card.status !== 'needsReview')) {
                                 card.status = 'new';
                             }
                             // Remove old SRS properties if they exist in the imported file
                             delete card.interval;
                             delete card.repetitions;
                             delete card.easeFactor;
                             delete card.dueDate;
                         });
                         if (typeof importedDeck.folder !== 'string' && typeof importedDeck.folder !== 'undefined') {
                            importedDeck.folder = undefined; // Ensure folder is string or undefined
                         }


                         // Re-generate shuffledIndices based on the cards array length
                         importedDeck.shuffledIndices = Array.from({length: importedDeck.cards.length}, (_, i) => i);


                         // Check if a deck with this name already exists and confirm overwrite
                         const existingDecks = getAllDecksFromStorage();
                         if (existingDecks[importedDeck.name]) {
                             if (!confirm(`A deck named "${importedDeck.name}" already exists in your browser. Do you want to overwrite it with the imported file? This will replace the existing deck and its progress.`)) {
                                 // User cancelled import
                                 event.target.value = ''; // Reset file input
                                 return;
                             }
                         }


                         // Save the imported deck to localStorage
                         saveDeck(importedDeck); // This updates the overall collection in localStorage

                         alert(`Deck "${importedDeck.name}" imported and saved to your browser successfully!`);

                         // Select the newly imported deck in the dropdown
                         deckSelect.value = importedDeck.name;
                         resetLearningArea(); // Clear learning area - force user to click Load

                    } else {
                        alert("Invalid flashcard deck file format. File must be a JSON object with 'name' (string) and 'cards' (array) properties.");
                    }
                } catch (error) {
                    alert("Error reading or parsing the file: " + error.message);
                    console.error(error);
                } finally {
                    // Reset the file input so the same file can be selected again if needed
                    event.target.value = '';
                }
            };
            reader.readAsText(file); // Read the file content as text
        });

        // Handle export current deck button click
        exportCurrentDeckBtn.addEventListener('click', () => {
            if (!currentDeck) {
                alert("Please load a deck first before exporting.");
                return;
            }

            // Ensure we export the current state of the deck from localStorage, not just the in-memory object
             const decks = getAllDecksFromStorage();
             const deckToExport = decks[currentDeck.name]; // Get the latest version

             if (!deckToExport) {
                 alert("Could not find the currently loaded deck in storage for export. Please try loading it again.");
                 return;
             }

             // Clean up the deck object slightly for export - remove shuffledIndices as it's internal state
             const cleanedDeck = JSON.parse(JSON.stringify(deckToExport)); // Deep copy
             delete cleanedDeck.shuffledIndices;


            const dataStr = JSON.stringify(cleanedDeck, null, 2); // Pretty print JSON
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = `${deckToExport.name.replace(/[^a-z0-9]/gi, '_')}_flashcard_deck.json`; // Sanitize filename and add suffix
            document.body.appendChild(a); // Required for Firefox
            a.click(); // Trigger download
            document.body.removeChild(a); // Clean up
            URL.revokeObjectURL(url); // Free up the object URL

            // Optional: Inform user
            // alert(`Exported deck "${currentDeck.name}".`);
        });


        // --- Delete Deck ---
        deleteDeckBtn.addEventListener('click', () => {
             const selectedDeckName = deckSelect.value;
            if (selectedDeckName) {
                const decks = getAllDecksFromStorage();
                const deckToDelete = decks[selectedDeckName];
                const folderDisplay = deckToDelete && deckToDelete.folder ? ` in folder "${deckToDelete.folder}"` : "";

                if (confirm(`Are you sure you want to delete the deck "${selectedDeckName}"${folderDisplay} from your browser's storage? This action cannot be undone.`)) {
                    delete decks[selectedDeckName];
                    saveAllDecksToStorage(decks);

                    if (currentDeck && currentDeck.name === selectedDeckName) {
                         resetLearningArea();
                    }

                    alert(`Deck "${selectedDeckName}" deleted.`);
                    populateFolderSelect();
                    populateDeckSelect();
                }
            } else {
                 alert("Please select a deck to delete.");
            }
        });

        // --- Delete Folder ---
        deleteFolderBtn.addEventListener('click', () => {
             const selectedFolder = folderSelect.value;

             if (selectedFolder === "" || selectedFolder === "new-folder-option") {
                 alert("Please select a specific folder to delete.");
                 return;
             }

             const allDecks = getAllDecksFromStorage();
             const decksInFolder = Object.values(allDecks).filter(deck => (deck.folder || '').trim() === selectedFolder.trim());

             if (decksInFolder.length === 0) {
                  if (confirm(`Folder "${selectedFolder}" appears empty. Do you want to delete it anyway?`)) {
                       alert(`Folder "${selectedFolder}" deleted.`);
                       populateFolderSelect(); // Repopulating removes the empty folder option
                       populateDeckSelect();
                  }
                  return;
             }


             const confirmMessage = `Are you sure you want to delete the folder "${selectedFolder}"?\n\nThis will also delete ${decksInFolder.length} deck(s) within this folder:\n- ${decksInFolder.map(d => d.name).join('\n- ')}\n\nThis action cannot be undone.`;

             if (confirm(confirmMessage)) {
                  const decksAfterDeletion = {};
                  for (const deckName in allDecks) {
                       const deck = allDecks[deckName];
                       if ((deck.folder || '').trim() !== selectedFolder.trim()) {
                           decksAfterDeletion[deckName] = deck;
                       }
                  }

                  saveAllDecksToStorage(decksAfterDeletion);

                  // Check if the currently loaded deck was in the deleted folder
                  if (currentDeck && (currentDeck.folder || '').trim() === selectedFolder.trim()) {
                       resetLearningArea();
                  }

                  alert(`Folder "${selectedFolder}" and its ${decksInFolder.length} deck(s) deleted.`);
                  populateFolderSelect();
                  populateDeckSelect();
             }
        });


        // --- Initialization ---

        document.addEventListener('DOMContentLoaded', () => {
            populateFolderSelect();
            populateDeckSelect();

             resetLearningArea(); // Ensure learning UI is hidden initially
        });

    </script>
</body>
</html>