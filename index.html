<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flashcard App</title>

    <style>
        /* --- Base Styles (Light Mode Defaults) --- */
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px; /* Original padding */
            background-color: #f4f4f4; /* Light background default */
            color: #333; /* Dark text default */
            transition: background-color 0.3s ease, color 0.3s ease; /* Smooth transition */
        }

        h2 {
            color: #333; /* Dark headings */
            transition: color 0.3s ease; /* Smooth transition */
             margin-top: 0; /* Keep h2 margin */
             margin-bottom: 15px;
        }

        .container {
            display: flex; /* Keep flex for side-by-side sections */
            gap: 20px;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
             /* Centralize the container */
            max-width: 1200px; /* Maximum width for the content */
            margin: 20px auto; /* 20px top/bottom margin, auto left/right for centering */
            padding: 0 10px; /* Add some padding inside the container, just in case */
             box-sizing: border-box; /* Include padding in max-width */
        }

        .creation-section, .learning-section {
            flex: 1; /* Share width equally */
            min-width: 300px; /* Minimum width before wrapping */
            border: 1px solid #ccc; /* Light border */
            padding: 20px;
            border-radius: 8px;
            background-color: #fff; /* Light background */
            box-shadow: 0 0 10px rgba(0,0,0,0.05);
            transition: background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;

             /* No display: flex or flex-direction here */
        }

        textarea, input[type="text"], select {
            display: block; /* Still block for structure */
            width: calc(100% - 22px); /* Account for padding and border */
            margin-bottom: 10px;
            padding: 10px;
            border: 1px solid #ccc; /* Light border */
            border-radius: 4px;
            font-size: 1em;
            background-color: #fff;
            color: #333;
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
             box-sizing: border-box; /* Ensure padding/border included */
             width: 100%; /* Fill container width */
        }

         /* Specific width adjustments for folder dropdown and new folder input */
        .folder-controls select, .folder-controls input[type="text"] {
             width: 100%; /* Fill parent width */
             margin-bottom: 10px;
             box-sizing: border-box; /* Include padding/border in width */
             display: block; /* Ensure they stack */
        }
        .folder-controls label {
             display: block; /* Label above the dropdown */
             margin-bottom: 5px;
             font-weight: bold;
             font-size: 0.9em;
             color: #555; /* Slightly lighter dark text */
             transition: color 0.3s ease; /* Smooth transition */
        }
        .folder-controls {
             margin-bottom: 10px; /* Space below folder controls */
        }

        /* Style for folder delete button */
        .folder-controls button {
             margin-top: 5px; /* Space above delete button */
             margin-left: 0;
        }


        /* Make textarea and learning area scroll if content overflows */
        textarea {
            height: auto; /* Auto height based on content/rows */
            min-height: 150px; /* Ensure a minimum height */
            overflow-y: auto; /* Add scrollbar if content overflows */
            margin-bottom: 15px; /* Space below textarea */
        }

        #learningArea {
             /* No flex-grow here */
             overflow-y: auto; /* Add scrollbar if content overflows */
             min-height: 150px; /* Ensure a minimum height */
             margin-top: 20px; /* Keep original margin */
             text-align: center; /* Keep original text alignment */
             display: flex; /* Keep inner flex for card centering */
             flex-direction: column; /* Stack inner contents */
             align-items: center;
             justify-content: flex-start; /* Align to start now that it grows */
        }


        button {
            padding: 10px 15px;
            background-color: #007bff; /* Blue primary button */
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
            font-size: 1em;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        button:hover {
            background-color: #0056b3;
        }

         button:last-child {
             margin-right: 0;
         }

        /* Style for the Import Deck Label (made to look like a button) */
        input[type="file"] {
            display: none;
        }

        .button-like-label {
            display: inline-block;
            padding: 10px 15px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
             margin-bottom: 10px;
            font-size: 1em;
             transition: background-color 0.3s ease, color 0.3s ease;
        }

         .button-like-label:hover {
            background-color: #218838;
        }

        /* Text/Paragraphs related to file management */
        .creation-section p {
            margin-top: 15px;
             margin-bottom: 10px;
             font-weight: bold;
             color: #555;
        }


        /* Flashcard styling */
        .card {
            border: 1px solid #ddd; /* Light border */
            padding: 20px; /* Adjusted padding to accommodate image/text */
            min-height: 150px;
            width: 90%;
            max-width: 500px;
             display: flex; /* Use flexbox for vertical stacking of image/text */
             flex-direction: column;
             align-items: center;
             justify-content: flex-start; /* Changed to flex-start to avoid centering empty space */
            margin-bottom: 20px; /* Add margin below card */
            background-color: #fff; /* Light background */
            border-radius: 8px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
            font-size: 1.4em;
            white-space: pre-wrap; /* Allows wrapping but preserves manual line breaks */
            text-align: center;
             transition: background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
             /* user-select state is controlled by JS on card-text-content */
             user-select: none; /* Default disabled on card container */
             -webkit-user-select: none;
             box-sizing: border-box; /* Include padding in width/height */
             overflow-y: auto; /* Add scrollbar if content overflows */
        }


         .card-face {
            width: 100%;
            /* No explicit height here, let content define it */
             display: flex; /* Use flex to stack image and text vertically within the face */
             flex-direction: column;
             align-items: center; /* Center image and text horizontally */
             /* justify-content: center; /* Vertically center image/text within the face - removed to align content to top if overflows */ */
             padding: 0;
             box-sizing: border-box;
             /* Inherit user-select from .card or set here if needed */
             user-select: inherit;
             -webkit-user-select: inherit;
        }

         .card-image-container {
             margin-bottom: 10px; /* Space between image and text */
             /* Ensure image container doesn't take up more space than needed */
             flex-shrink: 0;
             max-width: 100%; /* Ensure image container doesn't exceed face width */
             display: flex; /* Use flex to center image */
             justify-content: center;
         }

         .card-image-container img {
             max-width: 100%; /* Ensure image fits within container */
             max-height: 150px; /* Limit image height in learning view */
             border-radius: 4px;
              /* Ensure user-select doesn't apply to image itself */
             user-select: none;
             -webkit-user-select: none;
             object-fit: contain; /* Ensure image is not distorted */
             cursor: zoom-in; /* Indicate that it's clickable for zoom */
         }

         .card-text-content {
             flex-grow: 1; /* Allow text content to take available space */
             width: 100%; /* Ensure text content takes full width */
             /* Allow text alignment set on .card to apply */
              /* This div is where highlighting happens and user-select is managed */
             overflow-y: auto; /* Add scrollbar for text content if it overflows */
             padding: 0; /* No padding here, padding is on .card */
              box-sizing: border-box;
         }


        .hidden {
            display: none;
        }


        .controls, .progress-controls, .image-input-learning-container {
            margin-top: 15px; /* Standard margin top */
            text-align: center;
            width: 100%;
        }
         /* Specific margin for the image input section */
         .image-input-learning-container {
             margin-top: 20px; /* Extra space above this section */
             padding-top: 15px; /* Space inside with border */
             border-top: 1px solid #eee; /* Separator line */
             transition: border-color 0.3s ease;
         }
         body.dark-mode .learning-section .image-input-learning-container {
             border-top-color: #555;
         }


        .controls button, .progress-controls button, .image-input-learning-container button {
            margin: 5px;
        }

         /* Specific styles for basic progress buttons (Mark Known/Needs Review) */
         .progress-controls button {
             padding: 10px 15px; /* Default button size */
             font-size: 1em; /* Default font size */
         }
         /* Ensure Mark Known/Needs Review buttons have appropriate colors */
         #markKnownBtn { background-color: #28a745; } /* Green */
         #markKnownBtn:hover { background-color: #218838; }
         #markNeedsReviewBtn { background-color: #ffc107; color: #333; } /* Yellow/Warning */
         #markNeedsReviewBtn:hover { background-color: #e0a800; }

         /* Style for the Favorite button */
         #toggleFavoriteBtn {
            background-color: #ff7f00; /* Orange */
            margin-left: 5px; /* Space it from the navigation buttons */
            display: inline-block; /* Ensure it sits next to others */
         }
         #toggleFavoriteBtn:hover {
            background-color: #cc6600;
         }
         #toggleFavoriteBtn.is-favorite {
             background-color: #e74c3c; /* Red when favorited */
         }
         #toggleFavoriteBtn.is-favorite:hover {
            background-color: #c0392b;
         }

         /* Styles for new highlight action buttons */
         #undoHighlightBtn {
             background-color: #6c757d; /* Gray */
         }
         #undoHighlightBtn:hover {
             background-color: #5a6268;
         }
         #resetHighlightBtn {
             background-color: #dc3545; /* Red/Danger */
         }
         #resetHighlightBtn:hover {
             background-color: #c82333;
         }


         .progress-controls {
             border-top: 1px solid #eee; /* Light border */
             padding-top: 15px;
             margin-top: 15px;
              transition: border-color 0.3s ease;
         }


        #progressDisplay {
            margin-top: 10px;
            font-weight: bold;
            color: #555;
             transition: color 0.3s ease;
        }


        /* --- Highlighting Styles --- */
        /* Style for **syntax** processed highlighting */
        .syntax-highlight {
             background-color: #ffff00; /* Bright yellow */
             padding: 0 2px;
             border-radius: 2px;
             color: #000; /* Ensure text is black for readability */
             /* Prevents user-select interfering with highlighting itself */
             user-select: text;
             -webkit-user-select: text;
        }

         /* Style for user-applied highlighting - NOW YELLOW */
         .user-highlight {
            background-color: #ffff00; /* Bright yellow */ /* Changed from light blue */
            padding: 0 2px;
            border-radius: 2px;
            color: #000; /* Ensure text is black */
             user-select: text;
             -webkit-user-select: text;
        }

        /* Dark mode highlight adjustment */
        body.dark-mode .syntax-highlight {
            background-color: #ffd700; /* Darker yellow for dark mode */
            color: #000; /* Keep text black for contrast */
        }

         body.dark-mode .user-highlight {
             background-color: #ffd700; /* Darker yellow in dark mode */ /* Changed from royal blue */
             color: #000; /* Ensure text is black for readability on yellow */ /* Changed from lighter text */
         }

        /* Highlighter button styles */
        #highlighterBtn {
            background-color: #ffff00; /* Yellow background */
            color: #000; /* Black text */
        }

        #highlighterBtn.active {
            background-color: #ffd700; /* Darker yellow when active */
            box-shadow: 0 0 5px rgba(255, 215, 0, 0.7); /* Glow effect when active */
        }

        body.dark-mode #highlighterBtn {
            background-color: #ffd700; /* Darker yellow for dark mode */
            color: #000;
        }

        body.dark-mode #highlighterBtn.active {
            background-color: #ffcc00; /* Even darker yellow when active in dark mode */
            box-shadow: 0 0 5px rgba(255, 204, 0, 0.7); /* Glow effect when active */
        }


        /* --- Dark Mode Styles (Override Defaults) --- */
        body.dark-mode {
            background-color: #1e1e1e;
            color: #e0e0e0;
        }

        body.dark-mode h2 {
            color: #cccccc;
        }

        body.dark-mode .creation-section,
        body.dark-mode .learning-section {
            border-color: #333;
            background-color: #2d2d2d;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
        }

        body.dark-mode textarea,
        body.dark-mode input[type="text"],
        body.dark-mode select {
            border-color: #555;
            background-color: #3c3c3c;
            color: #e0e0e0;
        }

         body.dark-mode .folder-controls label {
             color: #b0b0b0;
         }
         body.dark-mode .creation-section p {
              color: #b0b0b0;
         }


        /* Adjust button colors for dark mode if desired, or keep them consistent */
        body.dark-mode button {
             background-color: #556cd6; /* Example: Darker primary button */
        }
        body.dark-mode button:hover {
            background-color: #4257b2;
        }
         /* Override specific button types in dark mode */
        body.dark-mode #markKnownBtn { background-color: #218838; } /* Darker Green */
        body.dark-mode #markKnownBtn:hover { background-color: #19742d; }
        body.dark-mode #markNeedsReviewBtn { background-color: #e0a800; color: #1e1e1e;} /* Darker Yellow */
        body.dark-mode #markNeedsReviewBtn:hover { background-color: #c49000; }

         /* Dark mode favorite button styles */
         body.dark-mode #toggleFavoriteBtn {
             background-color: #d66c2c; /* Darker Orange */
         }
         body.dark-mode #toggleFavoriteBtn:hover {
             background-color: #b35823;
         }
          body.dark-mode #toggleFavoriteBtn.is-favorite {
             background-color: #e74c3c; /* Red stays similar, or slightly adjusted */
         }
         body.dark-mode #toggleFavoriteBtn.is-favorite:hover {
            background-color: #c0392b;
         }

         /* Dark mode styles for new highlight action buttons */
         body.dark-mode #undoHighlightBtn {
             background-color: #5a6268; /* Darker Gray */
         }
         body.dark-mode #undoHighlightBtn:hover {
             background-color: #495056;
         }
         body.dark-mode #resetHighlightBtn {
             background-color: #c82333; /* Darker Red */
         }
         body.dark-mode #resetHighlightBtn:hover {
             background-color: #a71d2a;
         }


        body.dark-mode .button-like-label {
             background-color: #48a65f;
        }
         body.dark-mode .button-like-label:hover {
             background-color: #3a8c4e;
         }


        body.dark-mode .card {
             border-color: #555;
             background-color: #3c3c3c;
             box-shadow: 2px 2px 5px rgba(0,0,0,0.4);
        }

         body.dark-mode .progress-controls {
             border-top-color: #555;
         }

         body.dark-mode #progressDisplay {
             color: #b0b0b0;
         }

         /* --- Image handling styles (Creation Section) --- */
         /* (These were largely copied from the previous version) */
         .creation-section .drop-zone {
             border: 2px dashed #ccc;
             border-radius: 4px;
             padding: 15px; /* Increased padding */
             text-align: center;
             margin-bottom: 10px;
             transition: border-color 0.3s ease, background-color 0.3s ease;
             cursor: pointer; /* Indicate it's interactive */
         }

         .creation-section .drop-zone.active {
             border-color: #007bff;
             background-color: rgba(0, 123, 255, 0.1);
         }

         .creation-section .drop-zone p {
             margin: 0;
             font-weight: normal; /* Override p style */
             color: #555; /* Lighter text */
             display: flex; /* Use flex to align button */
             align-items: center;
             justify-content: center;
             gap: 10px; /* Space between text and button */
             flex-wrap: wrap; /* Allow wrapping on small screens */
         }
         body.dark-mode .creation-section .drop-zone p {
              color: #b0b0b0;
         }
         .creation-section .drop-zone p button { /* Style the paste button inside p */
             padding: 5px 10px;
             font-size: 0.9em;
             margin: 0; /* Reset button margins */
             display: inline-block; /* Keep inline */
         }


         .creation-section .image-preview-container { /* Container for image in drop zone */
             margin-top: 10px;
             margin-bottom: 0;
             max-height: 200px; /* Limit preview height */
             overflow: hidden; /* Hide parts of image exceeding max height */
             display: flex; /* Center image horizontally */
             justify-content: center;
         }

         .creation-section .image-preview-container img { /* Image style in drop zone preview */
             max-width: 100%; /* Ensure image fits container */
             max-height: 200px; /* Limit preview height */
             border-radius: 4px;
             box-shadow: 0 2px 4px rgba(0,0,0,0.1);
             object-fit: contain; /* Ensure image is not distorted */
         }
          body.dark-mode .creation-section .image-preview-container img {
               box-shadow: 0 2px 4px rgba(0,0,0,0.3);
          }


         .creation-section .image-controls {
             display: flex;
             justify-content: center; /* Center the controls below the image */
             margin-top: 10px; /* Space above controls */
         }

         .creation-section .image-controls button {
             padding: 5px 10px;
             font-size: 0.9em;
             margin: 0 5px; /* Space between buttons */
         }
          .creation-section .image-controls button:first-child { margin-left: 0; }
          .creation-section .image-controls button:last-child { margin-right: 0; }


         /* --- Image Handling Styles (Learning Section) --- */
         .learning-section .image-input-learning-container {
             width: 100%; /* Take full width of learning section */
             display: flex;
             flex-direction: column;
             align-items: center;
             margin-top: 20px; /* Space above image inputs */
             padding-top: 15px;
             border-top: 1px solid #eee; /* Separator line */
              transition: border-color 0.3s ease;
         }
         body.dark-mode .learning-section .image-input-learning-container {
             border-top-color: #555;
         }


         .learning-section .image-input-learning-container h4 {
              margin: 0 0 10px 0; /* Space below heading */
              color: #555; /* Lighter color */
               transition: color 0.3s ease;
         }
         body.dark-mode .learning-section .image-input-learning-container h4 {
              color: #b0b0b0;
         }

          .learning-section .image-input-learning-container .drop-zone {
             width: 90%; /* Match card width */
             max-width: 500px; /* Match card max-width */
             border: 2px dashed #ccc;
             border-radius: 4px;
             padding: 15px;
             text-align: center;
             margin-bottom: 10px; /* Space between drop zones */
             transition: border-color 0.3s ease, background-color 0.3s ease;
             cursor: pointer;
          }
          .learning-section .image-input-learning-container .drop-zone.active {
               border-color: #007bff;
               background-color: rgba(0, 123, 255, 0.1);
          }
          body.dark-mode .learning-section .image-input-learning-container .drop-zone {
               border-color: #555;
          }
           body.dark-mode .learning-section .image-input-learning-container .drop-zone.active {
               border-color: #556cd6;
               background-color: rgba(85, 108, 214, 0.2);
           }

         .learning-section .image-input-learning-container .drop-zone p {
             margin: 0;
             font-weight: normal;
             color: #555;
              transition: color 0.3s ease;
              display: flex;
              align-items: center;
              justify-content: center;
              gap: 10px;
              flex-wrap: wrap;
         }
          body.dark-mode .learning-section .image-input-learning-container .drop-zone p {
               color: #b0b0b0;
          }

          .learning-section .image-input-learning-container .drop-zone p button { /* Style the paste button */
               padding: 5px 10px;
               font-size: 0.9em;
               margin: 0;
               display: inline-block;
          }


         .learning-section .image-input-learning-container .image-preview-container { /* Preview image in learning section inputs */
             margin-top: 10px;
             margin-bottom: 0;
             max-height: 120px; /* Smaller preview height */
             overflow: hidden;
             display: flex;
             justify-content: center;
         }
         .learning-section .image-input-learning-container .image-preview-container img {
              max-width: 100%;
              max-height: 120px; /* Match container max-height */
              border-radius: 4px;
              box-shadow: 0 1px 3px rgba(0,0,0,0.1);
              object-fit: contain;
         }
          body.dark-mode .learning-section .image-input-learning-container .image-preview-container img {
               box-shadow: 0 1px 3px rgba(0,0,0,0.3);
          }


         .learning-section .image-input-learning-container .image-controls {
             display: flex;
             justify-content: center;
             margin-top: 10px;
         }
         .learning-section .image-input-learning-container .image-controls button {
              padding: 5px 10px;
              font-size: 0.9em;
              margin: 0 5px;
         }
          .learning-section .image-input-learning-container .image-controls button:first-child { margin-left: 0; }
          .learning-section .image-input-learning-container .image-controls button:last-child { margin-right: 0; }


         /* --- Modal Styles for Image Zoom --- */
         .modal {
             display: none; /* Hidden by default */
             position: fixed; /* Stay in place */
             z-index: 1000; /* Sit on top */
             left: 0;
             top: 0;
             width: 100%; /* Full width */
             height: 100%; /* Full height */
             overflow: auto; /* Enable scroll if needed */
             background-color: rgba(0,0,0,0.9); /* Black background with opacity */
             align-items: center; /* Center vertically */
             justify-content: center; /* Center horizontally */
             flex-direction: column; /* Stack image and caption */
             padding: 20px; /* Add some padding */
             box-sizing: border-box;
         }

         .modal.visible {
             display: flex; /* Show when active */
         }

         .modal-content {
             margin: auto; /* Center the image */
             display: block;
             max-width: 95%; /* Max width */
             max-height: 95%; /* Max height */
             object-fit: contain; /* Ensure image fits without distortion */
         }

         #modalCaption {
             margin-top: 15px;
             display: block;
             color: #ccc;
             font-size: 1.2em;
             text-align: center;
             max-width: 95%;
         }

         /* Close button */
         .modal-close {
             position: absolute;
             top: 15px;
             right: 35px;
             color: #f1f1f1;
             font-size: 40px;
             font-weight: bold;
             transition: 0.3s;
             cursor: pointer;
             z-index: 1001; /* Ensure close button is above image */
         }

         .modal-close:hover,
         .modal-close:focus {
             color: #bbb;
             text-decoration: none;
             cursor: pointer;
         }

         /* Dark mode for modal */
         body.dark-mode .modal-close {
             color: #ccc;
         }
         body.dark-mode .modal-close:hover,
         body.dark-mode .modal-close:focus {
             color: #aaa;
         }
         body.dark-mode #modalCaption {
             color: #bbb;
         }


        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                flex-direction: column; /* Stack creation/learning sections vertically */
                gap: 10px; /* Reduce gap on small screens */
                margin: 10px auto; /* Adjust margin on small screens */
                padding: 0 5px; /* Reduce padding inside container */
                max-width: 100%; /* Allow container to be full width */
            }
            .creation-section, .learning-section {
                min-width: auto;
                width: 100%; /* Ensure they take full width */
                padding: 15px; /* Reduce padding */
            }
             /* Adjust button/input stacking for small screens */
             .controls button, .progress-controls button, .file-controls button, .file-controls label,
             .folder-controls select, .folder-controls input[type="text"],
             .folder-controls button, /* Include folder button */
             textarea, input[type="text"]
             {
                 display: block;
                 width: 100%;
                 margin: 5px 0; /* Stack vertically */
                 box-sizing: border-box;
             }
              /* Override specific margins if necessary */
              /*
              button:last-child { margin-right: 0; }
              .button-like-label { margin-right: 0; }
              textarea { margin-bottom: 15px; }
              */

             .creation-section p {
                 text-align: left; /* Align file management text to left */
             }
             .card {
                 width: 100%; /* Card fills section width */
                 padding: 20px 10px; /* Adjust card padding */
                 font-size: 1.2em; /* Slightly smaller font on cards */
             }
              .card-image-container img { /* Adjust image height on small screens */
                  max-height: 120px;
              }
             #progressDisplay {
                 text-align: center; /* Keep progress centered */
             }

             /* Adjust button margins for stacking on small screens */
             .controls button, .progress-controls button, .file-controls button, .button-like-label {
                 margin-right: 0 !important; /* Override inline/previous margin */
                 margin-bottom: 5px; /* Space between stacked buttons */
             }
             .controls button:last-child, .progress-controls button:last-child, .file-controls button:last-child {
                 margin-bottom: 0;
             }
             #toggleFavoriteBtn { /* Separate favorite button margin */
                 margin-top: 5px;
                 margin-bottom: 5px;
                 margin-left: 0 !important; /* Ensure left margin is also removed */
             }
             /* Adjust new highlight buttons for stacking */
             #undoHighlightBtn, #resetHighlightBtn {
                 margin-right: 0 !important;
                 margin-bottom: 5px;
             }

             /* Image controls stacking on small screens (Creation & Learning) */
              .creation-section .image-controls,
              .learning-section .image-input-learning-container .image-controls
               {
                  flex-direction: column;
                  align-items: center;
              }
             .creation-section .image-controls button,
             .learning-section .image-input-learning-container .image-controls button
              {
                  width: 100%;
                  margin: 5px 0; /* Stack vertically */
             }

            /* Stack paste button and text in drop zones */
            .drop-zone p {
                 flex-direction: column;
                 gap: 5px;
            }
            .drop-zone p button {
                margin: 0 !important; /* Ensure no residual margin */
            }

            /* Ensure drop zones stack */
            .learning-section .image-input-learning-container .drop-zone {
                 width: 100%; /* Use full width on small screens */
            }

            /* Responsive adjustments for modal close button */
            .modal-close {
                top: 10px;
                right: 20px;
                font-size: 30px;
            }
             #modalCaption {
                font-size: 1em;
             }
        }

        /* Add styles for disabled buttons */
        button:disabled, .button-like-label:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Optional: Style for danger button */
        .danger-button {
             background-color: #dc3545;
        }
        .danger-button:hover {
             background-color: #c82333;
        }
        body.dark-mode .danger-button {
             background-color: #c82333;
        }
        body.dark-mode .danger-button:hover {
             background-color: #a71d2a;
        }

    </style>
</head>
<body class="dark-mode"> <!-- Starting in dark mode -->

    <div class="container">

        <section class="creation-section">
            <h2>Create/Update Deck</h2>

            <!-- Front side image drop zone (Creation) -->
            <div id="creationFrontImageDropZone" class="drop-zone">
                <p>Drag & drop image for front side or <button id="creationFrontImagePasteBtn" type="button">Paste from clipboard</button></p>
                <div id="creationFrontImagePreviewContainer" class="image-preview-container"></div>
                <div class="image-controls" id="creationFrontImageControls" style="display: none;">
                    <button id="removeCreationFrontImageBtn" class="danger-button" type="button">Remove Image</button>
                </div>
            </div>

            <textarea id="textInput" rows="10" placeholder="Paste your text here. Use '::' to separate front and back, one card per line. Example: Apple :: A fruit"></textarea>

            <!-- Back side image drop zone (Creation) -->
            <div id="creationBackImageDropZone" class="drop-zone">
                <p>Drag & drop image for back side or <button id="creationBackImagePasteBtn" type="button">Paste from clipboard</button></p>
                 <div id="creationBackImagePreviewContainer" class="image-preview-container"></div>
                <div class="image-controls" id="creationBackImageControls" style="display: none;">
                    <button id="removeCreationBackImageBtn" class="danger-button" type="button">Remove Image</button>
                </div>
            </div>


            <div class="folder-controls">
                <label for="folderSelect">Folder:</label>
                <select id="folderSelect">
                    <option value="">-- Select or Create Folder --</option>
                    <option value="new-folder-option">-- New Folder --</option>
                    <!-- Existing folders populated by JS -->
                </select>
                 <input type="text" id="newFolderNameInput" placeholder="Enter new folder name" style="display: none;">
                 <button id="deleteFolderBtn" class="danger-button" type="button">Delete Selected Folder</button>
            </div>

            <input type="text" id="deckNameInput" placeholder="Enter deck name">
            <button id="parseAndSaveBtn" type="button">Parse Text & Save/Update Deck</button>

            <p>Manage Files (Single Deck):</p>

             <input type="file" id="importDeckInput" accept=".json">
             <label for="importDeckInput" class="button-like-label">Import Deck File</label>
             <button id="exportCurrentDeckBtn" type="button">Export Loaded Deck File</button>


        </section>

        <section class="learning-section">
            <h2>Learn Decks</h2>
            <select id="deckSelect">
                <option value="">-- Select a Deck --</option>
                <!-- Options populated by JavaScript from stored decks, grouped by folder -->
                <!-- Including a special option for Favorites -->
            </select>
            <button id="loadDeckBtn" type="button">Load Selected Deck</button>
             <button id="deleteDeckBtn" class="danger-button" type="button">Delete Selected Deck</button>

            <div id="learningArea" class="flashcard-area" style="display: none;">
                 <!-- <p id="sessionInfo"></p> --> <!-- Removed session info display -->
                <div id="flashcard" class="card">
                     <!-- Card content will be injected here by JS -->
                    <div id="cardFront" class="card-face front">
                        <!-- Image and Text content will be dynamically added here by JS -->
                        <div class="card-image-container"></div>
                        <div class="card-text-content"></div>
                    </div>
                    <div id="cardBack" class="card-face back hidden">
                        <!-- Image and Text content will be dynamically added here by JS -->
                        <div class="card-image-container"></div>
                        <div class="card-text-content"></div>
                    </div>
                </div>


                <div class="controls">
                    <button id="showAnswerBtn" type="button">Show Answer</button>
                     <!-- Navigation buttons are standard in this mode -->
                     <button id="previousCardBtn" type="button">Previous Card</button>
                     <button id="nextCardBtn" type="button">Next Card</button>
                     <!-- New button to toggle favorite status -->
                     <button id="toggleFavoriteBtn" type="button">Mark as Favorite</button>
                     <!-- New highlighter button -->
                     <button id="highlighterBtn" type="button">Highlighter</button>
                     <!-- New buttons for undo/reset highlight -->
                     <button id="undoHighlightBtn" disabled type="button">Undo Highlight</button>
                     <button id="resetHighlightBtn" disabled type="button">Reset Highlight</button>
                </div>

                 <!-- Removed SRS Rating Controls -->
                 <!--
                 <div class="srs-controls" style="display: none;">
                      <button id="rateAgainBtn" class="again-button">Again</button>
                      <button id="rateGoodBtn" class="good-button">Good</button>
                      <button id="rateEasyBtn" class="easy-button">Easy</button>
                 </div>
                 -->


                <div class="progress-controls">
                     <!-- Basic progress tracking buttons -->
                     <button id="markKnownBtn" type="button">Mark as Known</button>
                     <button id="markNeedsReviewBtn" type="button">Needs Review</button>
                     <div>
                        <label>
                            <input type="checkbox" id="randomizeCheckbox"> Randomize Order
                        </label>
                     </div>
                     <div id="progressDisplay"></div>
                     <!-- <div id="sessionProgressDisplay"></div> --> <!-- Removed session progress display -->
                </div>

                 <!-- --- Image Input Controls for Learning Section (Moved) --- -->
                 <div class="image-input-learning-container">
                      <h4>Add/Update Card Images</h4>
                      <!-- Front side image input (Learning) -->
                       <div id="learningFrontImageDropZone" class="drop-zone">
                           <p>Front Image: Drag & drop or <button id="learningFrontImagePasteBtn" type="button">Paste from clipboard</button></p>
                           <div id="learningFrontImagePreviewContainer" class="image-preview-container"></div>
                           <div class="image-controls" id="learningFrontImageControls" style="display: none;">
                               <button id="removeLearningFrontImageBtn" class="danger-button" type="button">Remove Front Image</button>
                           </div>
                       </div>
                      <!-- Back side image input (Learning) -->
                       <div id="learningBackImageDropZone" class="drop-zone">
                           <p>Back Image: Drag & drop or <button id="learningBackImagePasteBtn" type="button">Paste from clipboard</button></p>
                           <div id="learningBackImagePreviewContainer" class="image-preview-container"></div>
                           <div class="image-controls" id="learningBackImageControls" style="display: none;">
                               <button id="removeLearningBackImageBtn" class="danger-button" type="button">Remove Back Image</button>
                           </div>
                       </div>
                 </div>
                 <!-- --- End Image Input Controls for Learning Section --- -->

            </div>
        </section>
    </div>

    <!-- The Modal for image zoom -->
    <div id="imageModal" class="modal">
      <span class="modal-close">&times;</span>
      <img class="modal-content" id="modalImage">
      <div id="modalCaption"></div>
    </div>
    <!-- End Modal -->


    <script>
        // --- JavaScript Logic ---

        // Get references to HTML elements (Creation Section)
        const textInput = document.getElementById('textInput');
        const folderSelect = document.getElementById('folderSelect');
        const newFolderNameInput = document.getElementById('newFolderNameInput');
        const deckNameInput = document.getElementById('deckNameInput');
        const parseAndSaveBtn = document.getElementById('parseAndSaveBtn');

        const creationFrontImageDropZone = document.getElementById('creationFrontImageDropZone');
        const creationFrontImagePreviewContainer = document.getElementById('creationFrontImagePreviewContainer');
        const creationFrontImageControls = document.getElementById('creationFrontImageControls');
        const removeCreationFrontImageBtn = document.getElementById('removeCreationFrontImageBtn');
        const creationFrontImagePasteBtn = document.getElementById('creationFrontImagePasteBtn');

        const creationBackImageDropZone = document.getElementById('creationBackImageDropZone');
        const creationBackImagePreviewContainer = document.getElementById('creationBackImagePreviewContainer');
        const creationBackImageControls = document.getElementById('creationBackImageControls');
        const removeCreationBackImageBtn = document.getElementById('removeCreationBackImageBtn');
        const creationBackImagePasteBtn = document.getElementById('creationBackImagePasteBtn');


        // Get references to HTML elements (Learning Section)
        const deckSelect = document.getElementById('deckSelect');
        const loadDeckBtn = document.getElementById('loadDeckBtn');
        const flashcard = document.getElementById('flashcard');
        const cardFront = document.getElementById('cardFront');
        const cardBack = document.getElementById('cardBack');
         // Get references to inner image and text containers within card faces
         const cardFrontImageContainer = cardFront.querySelector('.card-image-container');
         const cardFrontTextContent = cardFront.querySelector('.card-text-content');
         const cardBackImageContainer = cardBack.querySelector('.card-image-container');
         const cardBackTextContent = cardBack.querySelector('.card-text-content');


        const showAnswerBtn = document.getElementById('showAnswerBtn');
        const nextCardBtn = document.getElementById('nextCardBtn');
        const previousCardBtn = document.getElementById('previousCardBtn');
        const randomizeCheckbox = document.getElementById('randomizeCheckbox');
        const markKnownBtn = document.getElementById('markKnownBtn');
        const markNeedsReviewBtn = document.getElementById('markNeedsReviewBtn');
        const toggleFavoriteBtn = document.getElementById('toggleFavoriteBtn'); // New button
        const highlighterBtn = document.getElementById('highlighterBtn'); // Highlighter button
        const undoHighlightBtn = document.getElementById('undoHighlightBtn'); // Undo button
        const resetHighlightBtn = document.getElementById('resetHighlightBtn'); // Reset button
        const progressDisplay = document.getElementById('progressDisplay');
        const importDeckInput = document.getElementById('importDeckInput');
        const exportCurrentDeckBtn = document.getElementById('exportCurrentDeckBtn');
        const deleteDeckBtn = document.getElementById('deleteDeckBtn');
        const learningArea = document.getElementById('learningArea');
        const deleteFolderBtn = document.getElementById('deleteFolderBtn');

        // Get references to Image Input Elements in Learning Section
        const learningImageInputContainer = document.querySelector('.image-input-learning-container');
        const learningFrontImageDropZone = document.getElementById('learningFrontImageDropZone');
        const learningFrontImagePreviewContainer = document.getElementById('learningFrontImagePreviewContainer');
        const learningFrontImageControls = document.getElementById('learningFrontImageControls');
        const removeLearningFrontImageBtn = document.getElementById('removeLearningFrontImageBtn');
        const learningFrontImagePasteBtn = document.getElementById('learningFrontImagePasteBtn');

        const learningBackImageDropZone = document.getElementById('learningBackImageDropZone');
        const learningBackImagePreviewContainer = document.getElementById('learningBackImagePreviewContainer');
        const learningBackImageControls = document.getElementById('learningBackImageControls');
        const removeLearningBackImageBtn = document.getElementById('removeLearningBackImageBtn');
        const learningBackImagePasteBtn = document.getElementById('learningBackImagePasteBtn');

        // Get references to Modal elements
        const imageModal = document.getElementById('imageModal');
        const modalImage = document.getElementById('modalImage');
        const modalCaption = document.getElementById('modalCaption');
        const modalClose = document.querySelector('.modal-close');


        let currentDeck = null; // { name: '...', folder: '...', cards: [{front:'...', back:'...', status:'...', isFavorite: boolean, sourceDeckName?: string, sourceCardFront?: string, frontHighlighted?: string, backHighlighted?: string, frontHighlightHistory?: string[], backHighlightHistory?: string[], frontImage?: string, backImage?: string}], shuffledIndices: [...] }
        let currentCardIndex = 0; // Index within the shuffled/original order
        let isAnswerShowing = false;
        let isHighlighterActive = false; // Track if highlighter mode is active

        // Image handling variables (for Creation Section ONLY)
        let creationFrontImage = null; // Stores Data URL for the image added in the creation section front
        let creationBackImage = null; // Stores Data URL for the image added in the creation section back


        const DECK_STORAGE_KEY = 'flashcardsDecksCollection';
        const UNSORTED_FOLDER_KEY = "__UNSORTED__";
        const ALL_FAVORITES_KEY = "__ALL_FAVORITES__"; // Special key for the Favorites view
        const MAX_HIGHLIGHT_HISTORY = 10; // Limit history depth


         // --- Deck Management (Collection in localStorage) ---

         // Helper to get all decks from localStorage
         function getAllDecksFromStorage() {
             try {
                const decks = JSON.parse(localStorage.getItem(DECK_STORAGE_KEY) || '{}');
                // Ensure basic properties exist for compatibility with older saves and add new ones
                 for (const deckName in decks) {
                     const deck = decks[deckName];
                     if (!Array.isArray(deck.cards)) {
                          console.warn(`Deck "${deckName}" has invalid cards array. Skipping.`);
                          delete decks[deckName]; // Remove invalid deck
                          continue;
                     }
                      deck.cards.forEach(card => {
                          if (!card.status || (card.status !== 'new' && card.status !== 'known' && card.status !== 'needsReview')) {
                             card.status = 'new'; // Default status
                         }
                          if (typeof card.isFavorite !== 'boolean') card.isFavorite = false; // Add default favorite status if missing
                          // Ensure highlight properties are undefined or string
                          if (typeof card.frontHighlighted !== 'string' && typeof card.frontHighlighted !== 'undefined') card.frontHighlighted = undefined;
                          if (typeof card.backHighlighted !== 'string' && typeof card.backHighlighted !== 'undefined') card.backHighlighted = undefined;

                           // Add image properties if missing (initialize as undefined)
                           if (typeof card.frontImage !== 'string' && typeof card.frontImage !== 'undefined') card.frontImage = undefined;
                           if (typeof card.backImage !== 'string' && typeof card.backImage !== 'undefined') card.backImage = undefined;


                           // Initialize history arrays if missing or not arrays. History is NOT persisted from storage.
                          card.frontHighlightHistory = []; // Always start with empty history on load from storage
                          card.backHighlightHistory = []; // Always start with empty history on load from storage


                          // Remove old SRS properties if they exist (for migration/cleanup)
                          delete card.interval;
                          delete card.repetitions;
                          delete card.easeFactor;
                          delete card.dueDate;

                           // Remove temporary source info if present (cleanup for regular decks)
                           delete card.sourceDeckName;
                           delete card.sourceCardFront;
                      });
                      // Ensure folder property exists (string or undefined)
                      if (typeof deck.folder !== 'string' && typeof deck.folder !== 'undefined') {
                           deck.folder = undefined;
                      }
                     // Shuffled indices will be handled on load
                      delete deck.shuffledIndices; // Ensure this isn't loaded from storage
                      delete deck.displayName; // Ensure this isn't loaded from storage

                 }
                 return decks;
             } catch (e) {
                 console.error("Error parsing decks from localStorage:", e);
                 alert("Error loading your saved decks. Your local storage might be corrupted. Clearing storage to prevent further issues.");
                 localStorage.removeItem(DECK_STORAGE_KEY); // Clear corrupted data
                 return {};
             }
         }

         // Helper to save the entire decks collection to localStorage
         function saveAllDecksToStorage(allDecks) {
              try {
                 localStorage.setItem(DECK_STORAGE_KEY, JSON.stringify(allDecks));
              } catch (e) {
                  console.error("Error saving decks to localStorage:", e);
                   if (e.name === 'QuotaExceededError') {
                       alert('Cannot save deck. Local storage is full. Please export some decks and clear your browser storage.');
                   } else {
                       alert('Error saving deck: ' + e.message);
                   }
              }
         }

        // Function to save a single deck (updates the collection in localStorage)
        function saveDeck(deck) {
            const decks = getAllDecksFromStorage(); // Get the latest state first
            // Create a clean copy for saving, removing properties not meant for long-term storage
             const deckToSave = JSON.parse(JSON.stringify(deck)); // Deep copy
             // Remove history arrays - they are temporary for the session
             deckToSave.cards.forEach(card => {
                 delete card.frontHighlightHistory;
                 delete card.backHighlightHistory;
             });
             // Remove other temporary properties if they somehow got added
              delete deckToSave.shuffledIndices;
              delete deckToSave.displayName;
             // Remove source info if present (only used in Favorites view temp object)
             deckToSave.cards.forEach(card => {
                 delete card.sourceDeckName;
                 delete card.sourceCardFront;
             });


            decks[deckToSave.name] = deckToSave; // Store/update by name
            saveAllDecksToStorage(decks); // Save the entire updated collection
            // Note: Does NOT repopulate selects or reload currentDeck here.
            // This is handled by explicit calls or events after save/load actions.
        }

        // Function to load a deck by name or the special Favorites collection
        function loadDeck(deckName) {
            const decks = getAllDecksFromStorage();
            let deckToLoad = null;
            let cardsToLoad = [];
            let deckDisplayName = "";
            let isFavoritesView = false;

            if (deckName === ALL_FAVORITES_KEY) {
                 isFavoritesView = true;
                 deckDisplayName = "⭐ All Favorite Cards"; // Display name for favorites
                 // Collect all favorite cards from all decks
                 for (const name in decks) {
                     if (decks.hasOwnProperty(name)) {
                         const deck = decks[name];
                         deck.cards.forEach(card => {
                             if (card.isFavorite) {
                                 // For favorites view, add metadata to reference the original card
                                 // Clone the card to avoid modifying the original in memory during the favorites session
                                 const cardCopy = JSON.parse(JSON.stringify(card));
                                 cardCopy.sourceDeckName = deck.name; // Add source deck name
                                 cardCopy.sourceCardFront = card.front; // Add source card front for lookup
                                  // History arrays are temporary for the session in Favorites view, start fresh
                                  cardCopy.frontHighlightHistory = [];
                                  cardCopy.backHighlightHistory = [];
                                  // Image properties are copied by JSON.parse/stringify
                                 cardsToLoad.push(cardCopy);
                             }
                         });
                     }
                 }
                // Create a temporary deck object for the favorites view
                 deckToLoad = {
                     name: ALL_FAVORITES_KEY, // Use the special key as the name
                     displayName: deckDisplayName, // Store a display name
                     folder: undefined, // No folder for favorites collection
                     cards: cardsToLoad
                 };

            } else {
                 // Loading a regular deck
                deckToLoad = decks[deckName];
                if (deckToLoad) {
                    deckDisplayName = deckToLoad.name;
                    cardsToLoad = deckToLoad.cards;
                } else {
                     console.error("Deck not found in storage:", deckName);
                     alert("Error loading deck. It might have been deleted or corrupted.");
                     resetLearningArea();
                     populateDeckSelect(); // Refresh options in case of deletion
                     return;
                }
            }

            if (!deckToLoad || !Array.isArray(deckToLoad.cards) || deckToLoad.cards.length === 0) {
                 alert(`No cards found ${isFavoritesView ? 'in your favorites' : `in deck "${deckName}"`}.`);
                 resetLearningArea(); // Clear learning area
                 populateDeckSelect(); // Refresh options
                 return;
            }

            // Ensure cards in the loaded deck have history arrays initialized (if not already from getAllDecksFromStorage)
             deckToLoad.cards.forEach(card => {
                 if (!Array.isArray(card.frontHighlightHistory)) card.frontHighlightHistory = [];
                 if (!Array.isArray(card.backHighlightHistory)) card.backHighlightHistory = [];
                 // Ensure image properties exist (initialized to undefined by getAllDecksFromStorage)
                  if (typeof card.frontImage !== 'string' && typeof card.frontImage !== 'undefined') card.frontImage = undefined;
                  if (typeof card.backImage !== 'string' && typeof card.backImage !== 'undefined') card.backImage = undefined;

             });


            currentDeck = deckToLoad; // Set the current deck object
            currentCardIndex = 0; // Start at the beginning of the loaded deck's cards

            // Ensure shuffledIndices exists and is correct length, or create/recreate it
            // Always regenerate indices for Favorites view or if missing/mismatch/randomize checked
            if (!currentDeck.shuffledIndices || currentDeck.shuffledIndices.length !== currentDeck.cards.length || isFavoritesView || randomizeCheckbox.checked) {
                 console.log(`${isFavoritesView ? 'Favorites view' : `Deck "${deckName}"`} indices mismatch/missing or randomize checked. Re-generating ${isFavoritesView || randomizeCheckbox.checked ? 'shuffled' : 'original'} order.`);
                  const initialIndices = Array.from({length: currentDeck.cards.length}, (_, i) => i);
                 currentDeck.shuffledIndices = (isFavoritesView || randomizeCheckbox.checked) ? shuffleArray(initialIndices) : initialIndices;
            } else {
                 console.log(`Loading Deck "${deckName}" with existing shuffled order.`);
            }


            document.querySelector('.learning-section h2').textContent = `Learn: ${deckDisplayName}`; // Update section title

            displayCurrentCard(); // Display the first card in the chosen order
            updateProgressDisplay();
            learningArea.style.display = 'flex';
            deckSelect.value = deckName; // Keep deck dropdown in sync

             // Enable learning buttons
            showAnswerBtn.disabled = false;
            nextCardBtn.disabled = false;
            previousCardBtn.disabled = false;
            markKnownBtn.disabled = false;
            markNeedsReviewBtn.disabled = false;
            toggleFavoriteBtn.disabled = false; // Enable favorite button
            highlighterBtn.disabled = false; // Enable highlighter button
             // Undo/Reset buttons state will be set by displayCurrentCard

             // Show image input controls in learning section
             learningImageInputContainer.style.display = 'flex';


            // Enable export button only if NOT in Favorites view
            exportCurrentDeckBtn.disabled = isFavoritesView;
             // Delete deck button disabled in Favorites view
             deleteDeckBtn.disabled = isFavoritesView;

             // Ensure highlighter mode is OFF by default when loading a deck
             isHighlighterActive = false;
             highlighterBtn.classList.remove('active');
             highlighterBtn.textContent = 'Highlighter';

             // Text selection is managed per face in displayCurrentCard/showAnswerBtn handlers

        }

        function populateFolderSelect() {
             console.log("Populating folder select...");
             const currentValue = folderSelect.value; // Remember current selection

             folderSelect.innerHTML = ''; // Clear current options

             const defaultOption = document.createElement('option');
             defaultOption.value = "";
             defaultOption.textContent = "-- Select or Create Folder --";
             folderSelect.appendChild(defaultOption);

             const newFolderOption = document.createElement('option');
             newFolderOption.value = "new-folder-option";
             newFolderOption.textContent = "-- New Folder --";
             folderSelect.appendChild(newFolderOption);

            const decks = getAllDecksFromStorage();
            const folders = new Set();

            Object.values(decks).forEach(deck => {
                if (deck.folder && typeof deck.folder === 'string' && deck.folder.trim()) {
                    folders.add(deck.folder.trim());
                }
            });

            Array.from(folders).sort().forEach(folderName => {
                const option = document.createElement('option');
                option.value = folderName;
                option.textContent = folderName;
                folderSelect.appendChild(option);
            });

             // Attempt to restore previous selection
             if (folderSelect.querySelector(`option[value="${currentValue}"]`)) {
                 folderSelect.value = currentValue;
             } else {
                  folderSelect.value = ""; // Default if previous is gone or invalid
             }


            newFolderNameInput.style.display = 'none'; // Always hide the input initially after repopulating
            newFolderNameInput.value = ''; // Clear the input value

            updateDeleteFolderButtonState();
             console.log("Folder select populated.");
        }


        function populateDeckSelect() {
             console.log("Populating deck select...");
            const currentSelectedValue = deckSelect.value; // Remember current selection
            const currentLoadedDeckName = currentDeck ? currentDeck.name : null; // Remember loaded deck


            deckSelect.innerHTML = '<option value="">-- Select a Deck --</option>';
            const decks = getAllDecksFromStorage();
            const deckNames = Object.keys(decks);

            const groupedDecks = {};
            const UNSORTED_FOLDER_LABEL = "Unsorted Decks";

            // Add the special "All Favorites" option at the top
            const favoritesOption = document.createElement('option');
            favoritesOption.value = ALL_FAVORITES_KEY;
            favoritesOption.textContent = "⭐ All Favorite Cards";
            deckSelect.appendChild(favoritesOption);


            deckNames.forEach(deckName => {
                const deck = decks[deckName];
                const folder = (deck.folder && typeof deck.folder === 'string' && deck.folder.trim()) || UNSORTED_FOLDER_KEY;
                if (!groupedDecks[folder]) {
                    groupedDecks[folder] = [];
                }
                groupedDecks[folder].push(deck);
            });

            const sortedFolders = Object.keys(groupedDecks).sort((a, b) => {
                if (a === UNSORTED_FOLDER_KEY) return 1;
                if (b === UNSORTED_FOLDER_KEY) return -1;
                return a.localeCompare(b);
            });

            sortedFolders.forEach(folderKey => {
                const folderDecks = groupedDecks[folderKey];
                folderDecks.sort((a, b) => a.name.localeCompare(b.name));

                const optgroup = document.createElement('optgroup');
                optgroup.label = (folderKey === UNSORTED_FOLDER_KEY) ? UNSORTED_FOLDER_LABEL : folderKey;

                folderDecks.forEach(deck => {
                    const option = document.createElement('option');
                    option.value = deck.name;
                    option.textContent = deck.name; // Maybe add card counts later?
                    optgroup.appendChild(option);
                });

                deckSelect.appendChild(optgroup);
            });

            // Attempt to re-select the previously selected or loaded deck
             if (currentLoadedDeckName && deckSelect.querySelector(`option[value="${currentLoadedDeckName}"]`)) {
                 deckSelect.value = currentLoadedDeckName; // Prioritize loaded deck
                 console.log("Restored loaded deck selection:", currentLoadedDeckName);
             } else if (currentSelectedValue && deckSelect.querySelector(`option[value="${currentSelectedValue}"]`)) {
                  deckSelect.value = currentSelectedValue; // Restore previously selected value if loaded deck is gone
                   console.log("Restored previous deck selection:", currentSelectedValue);
             }
             else {
                 // Check if 'All Favorites' was selected and there are still favorites
                 if (currentSelectedValue === ALL_FAVORITES_KEY) {
                      const decksForFavoriteCheck = getAllDecksFromStorage();
                      let hasFavorites = false;
                      for (const name in decksForFavoriteCheck) {
                          if (decksForFavoriteCheck.hasOwnProperty(name)) {
                              if (decksForFavoriteCheck[name].cards.some(card => card.isFavorite)) {
                                  hasFavorites = true;
                                  break;
                              }
                          }
                      }
                      if (hasFavorites) {
                           deckSelect.value = ALL_FAVORITES_KEY;
                           console.log("Restored All Favorites selection.");
                      } else {
                          console.log("All Favorites selected, but no favorites found. Resetting learning area.");
                           resetLearningArea(); // Reset if the current deck was deleted
                          deckSelect.value = "";
                      }
                 } else {
                      console.log("No previous deck selection or loaded deck found/valid. Resetting learning area.");
                      resetLearningArea(); // Reset if the current deck was deleted or not found
                     deckSelect.value = "";
                 }
             }


             // Load button enabled if *any* option is selected (including Favorites)
             // Delete/Export buttons state depends on the *currently selected* value in the dropdown
             loadDeckBtn.disabled = (deckSelect.value === ""); // Disable if "-- Select a Deck --" is chosen
             deleteDeckBtn.disabled = (deckSelect.value === "" || deckSelect.value === ALL_FAVORITES_KEY);
             // Export button state is handled by loadDeck/resetLearningArea based on *loaded* deck.

             console.log("Deck select populated. Current value:", deckSelect.value);
        }

         function resetLearningArea() {
              console.log("Resetting learning area.");
              currentDeck = null;
              currentCardIndex = 0; // Reset index

              learningArea.style.display = 'none';
              // Clear card content elements
              cardFrontImageContainer.innerHTML = "";
              cardFrontTextContent.innerHTML = "";
              cardBackImageContainer.innerHTML = "";
              cardBackTextContent.innerHTML = "";
              cardBack.classList.add('hidden'); // Ensure back is hidden
               isAnswerShowing = false; // Reset state

              // Hide and clear learning section image inputs
              learningImageInputContainer.style.display = 'none';
              clearLearningImageInputs(); // Clear the previews and controls

              progressDisplay.textContent = "";

              document.querySelector('.learning-section h2').textContent = 'Learn Decks'; // Reset title

              showAnswerBtn.disabled = true;
              nextCardBtn.disabled = true; // Navigation buttons disabled
              previousCardBtn.disabled = true; // Navigation buttons disabled
              markKnownBtn.disabled = true; // Basic progress buttons disabled
              markNeedsReviewBtn.disabled = true; // Basic progress buttons disabled
              toggleFavoriteBtn.disabled = true; // Favorite button disabled
              updateFavoriteButtonState(false); // Reset favorite button appearance

              highlighterBtn.disabled = true; // Disable highlighter button
              highlighterBtn.classList.remove('active'); // Reset highlighter state
              highlighterBtn.textContent = 'Highlighter'; // Reset text
              isHighlighterActive = false; // Reset highlighter mode

              undoHighlightBtn.disabled = true; // Disable undo button
              resetHighlightBtn.disabled = true; // Disable reset button

               // Ensure text selection is disabled on the card text elements
                   // Also remove any previously attached click listeners (images)
                  removeImageClickListeners(cardFrontImageContainer);
                   removeImageClickListeners(cardBackImageContainer);
                  cardFrontTextContent.style.userSelect = 'none';
                  cardFrontTextContent.style.webkitUserSelect = 'none';
                  cardFrontTextContent.style.cursor = 'default';
                  cardBackTextContent.style.userSelect = 'none';
                  cardBackTextContent.style.webkitUserSelect = 'none';
                  cardBackTextContent.style.cursor = 'default';


              exportCurrentDeckBtn.disabled = true;
              deleteDeckBtn.disabled = true; // Disable delete button when no deck is loaded
              // deckSelect.value = ""; // Don't reset deckSelect value here, populateDeckSelect handles it
         }

         function updateDeleteFolderButtonState() {
             const selectedValue = folderSelect.value;
             deleteFolderBtn.disabled = (selectedValue === "" || selectedValue === "new-folder-option");
             console.log("Delete Folder button state updated. Disabled:", deleteFolderBtn.disabled);
         }

         // Clears the image inputs in the creation section ONLY
         function clearCreationImageInputs() {
              console.log("Clearing creation image inputs.");
              creationFrontImagePreviewContainer.innerHTML = "";
              creationFrontImageControls.style.display = 'none';
              creationFrontImage = null;

              creationBackImagePreviewContainer.innerHTML = "";
              creationBackImageControls.style.display = 'none';
              creationBackImage = null;
         }

         // Clears the image inputs/previews in the learning section ONLY
         function clearLearningImageInputs() {
             console.log("Clearing learning image inputs.");
              learningFrontImagePreviewContainer.innerHTML = "";
              learningFrontImageControls.style.display = 'none';

              learningBackImagePreviewContainer.innerHTML = "";
              learningBackImageControls.style.display = 'none';
         }


        // --- Creation Logic ---

        parseAndSaveBtn.addEventListener('click', () => {
             console.log("Parse & Save button clicked.");
            const text = textInput.value;
            const deckName = deckNameInput.value.trim();
            let folderName = "";

            const selectedFolderValue = folderSelect.value;
             console.log("Selected folder value:", selectedFolderValue);

            if (selectedFolderValue === 'new-folder-option') {
                folderName = newFolderNameInput.value.trim();
                 console.log("New folder name entered:", folderName);
            } else {
                folderName = selectedFolderValue; // Use the value from the select dropdown
                 console.log("Existing folder selected:", folderName);
            }

            // Allow saving a deck with ONLY images, or ONLY text, or both
            if (!text && !creationFrontImage && !creationBackImage) {
                alert("Please enter text for cards, or add at least one image.");
                return;
            }
            if (!deckName) {
                alert("Please enter a deck name.");
                return;
            }
            if (selectedFolderValue === 'new-folder-option' && !folderName) {
                 alert("Please enter a name for the new folder.");
                 newFolderNameInput.focus();
                 return;
            }


            const existingDecks = getAllDecksFromStorage();
            let overwrite = false;
            if (existingDecks[deckName]) {
                 if (!confirm(`Deck "${deckName}" already exists. Do you want to overwrite it? This will replace the cards and reset progress/favorites/highlights/images for this deck.`)) {
                     console.log("Overwrite cancelled by user.");
                     return;
                 }
                 overwrite = true;
                 console.log(`Overwriting existing deck "${deckName}".`);
            }


            const lines = text.split('\n').filter(line => line.trim() !== ''); // Filter out empty lines
            const cards = [];

            // Handle the case where there's text input
            if (lines.length > 0) {
                 lines.forEach(line => {
                    // Regex to capture front and back, allowing empty back if :: is present
                    const parts = line.match(/^(.*?)(?:::(.*))?$/); // Non-capturing group for '::' and capture group for back
                     if (parts && parts[1].trim()) { // Ensure front part exists after trim
                         const frontContent = parts[1].trim();
                         const backContent = parts[2] !== undefined ? parts[2].trim() : ""; // Back is empty if :: or back part missing

                         cards.push({
                             front: frontContent,
                             back: backContent,
                             status: 'new',
                             isFavorite: false,
                             frontHighlighted: undefined,
                             backHighlighted: undefined,
                             frontHighlightHistory: [], // History starts empty
                             backHighlightHistory: [],   // History starts empty
                              frontImage: undefined, // Initialize image properties
                              backImage: undefined
                         });
                     } else {
                          // If line is not just whitespace and doesn't match the pattern (e.g., starts with ::)
                          if (line.trim() !== '') {
                               console.warn(`Skipping malformed line: "${line.trim()}"`);
                          }
                     }
                 });
            }

            // If no text lines, but images are added, create a single card for the images
             if (cards.length === 0 && (creationFrontImage || creationBackImage)) {
                  console.log("Creating a card for images only.");
                 cards.push({
                      front: "", // No text front
                      back: "", // No text back
                      status: 'new',
                      isFavorite: false,
                      frontHighlighted: undefined,
                      backHighlighted: undefined,
                      frontHighlightHistory: [],
                      backHighlightHistory: [],
                      frontImage: undefined, // Will be set below
                      backImage: undefined // Will be set below
                 });
            } else if (cards.length === 0) {
                 // This case should be caught by the initial check, but as a fallback
                 alert("No valid content (text or images) found for cards.");
                 return;
            }


            // Add images from creation inputs to the *first* card created
             if (cards.length > 0) {
                if (creationFrontImage) {
                    cards[0].frontImage = creationFrontImage;
                     console.log("Adding creation front image to the first card.");
                }
                if (creationBackImage) {
                    cards[0].backImage = creationBackImage;
                     console.log("Adding creation back image to the first card.");
                }
            }

            console.log("Parsed cards:", cards);

            if (cards.length > 0) {
                const newDeck = {
                    name: deckName,
                    folder: folderName || undefined, // Store empty folder as undefined
                    cards: cards,
                    // shuffledIndices are generated on load, not saved with the deck
                };

                saveDeck(newDeck); // Save the new/updated deck

                alert(`Deck "${deckName}" saved/updated with ${cards.length} card(s)${folderName ? ` in folder "${folderName}"` : ''}.`);
                textInput.value = '';
                 clearCreationImageInputs(); // Clear image inputs after saving

                 folderSelect.value = "";
                 newFolderNameInput.value = '';
                 newFolderNameInput.style.display = 'none';

                deckNameInput.value = '';

                 // Re-populate dropdowns to reflect the changes (new folder/deck)
                 populateFolderSelect();
                 populateDeckSelect();

                 resetLearningArea(); // Clear learning area - force user to click Load

            } else {
                // This case should only happen if text was empty and no images were added,
                // or if text was only malformed lines. The checks above handle this,
                // but keeping this as a final fallback.
                alert("No valid flashcards found in the text or no images added.");
            }
        });

        folderSelect.addEventListener('change', () => {
             const selectedValue = folderSelect.value;
             console.log("Folder select changed. Value:", selectedValue);
             if (selectedValue === 'new-folder-option') {
                 console.log("Selected 'New Folder' option. Showing new folder input.");
                 newFolderNameInput.style.display = 'block';
                 newFolderNameInput.focus();
             } else {
                  console.log("Selected existing or default option. Hiding new folder input.");
                 newFolderNameInput.style.display = 'none';
                 newFolderNameInput.value = '';
             }
             updateDeleteFolderButtonState();
        });


        // --- Learning Logic ---

        loadDeckBtn.addEventListener('click', () => {
            console.log("Load Deck button clicked.");
            const selectedDeckName = deckSelect.value;
             console.log("Selected deck to load:", selectedDeckName);
            if (selectedDeckName) {
                loadDeck(selectedDeckName);
            } else {
                resetLearningArea();
                alert("Please select a deck or 'All Favorite Cards' to load.");
            }
        });

         // Function to process text with **syntax** highlighting
        function processSyntaxHighlighting(text) {
            // Replace **text** with <span class="syntax-highlight">text</span>
            // Use a non-greedy match (.*?) and ensure we don't create empty highlights
            return text.replace(/\*\*(.*?)\*\*/g, (match, p1) => {
                 if (p1.trim() === '') {
                     return match; // Don't highlight empty strings between **
                 }
                 return `<span class="syntax-highlight">${p1}</span>`;
            });
        }

        // Function to display the current card from the shuffled/original order
        function displayCurrentCard() {
             console.log("Displaying card:", currentCardIndex);
            if (!currentDeck || !currentDeck.cards || currentDeck.cards.length === 0 || !currentDeck.shuffledIndices || currentDeck.shuffledIndices.length === 0) {
                 console.log("No cards to display or deck state invalid.");
                 // Clear card content elements
                 cardFrontImageContainer.innerHTML = "";
                 cardFrontTextContent.innerHTML = "No cards available in this deck/view.";
                 cardBackImageContainer.innerHTML = "";
                 cardBackTextContent.innerHTML = "";

                 cardBack.classList.add('hidden'); // Hide back
                 cardFront.classList.remove('hidden'); // Ensure front is visible
                 isAnswerShowing = false; // Reset state

                 // Hide and clear learning section image inputs
                 learningImageInputContainer.style.display = 'none';
                 clearLearningImageInputs(); // Clear the previews and controls

                 updateFavoriteButtonState(false); // Reset favorite button appearance
                 updateHighlightButtons(false); // Disable highlight buttons initially
                 updateProgressDisplay(); // Clear progress display or show 0/0
                 // Disable card controls if no cards
                 showAnswerBtn.disabled = true;
                 nextCardBtn.disabled = true;
                 previousCardBtn.disabled = true;
                 markKnownBtn.disabled = true;
                 markNeedsReviewBtn.disabled = true;
                 toggleFavoriteBtn.disabled = true; // Disable favorite button
                 highlighterBtn.disabled = true; // Disable highlighter button
                 highlighterBtn.classList.remove('active'); // Reset highlighter state
                 highlighterBtn.textContent = 'Highlighter'; // Reset text
                 isHighlighterActive = false; // Reset highlighter mode
                  // Ensure text selection is disabled on the card text elements
                   // Also remove any previously attached click listeners (images)
                  removeImageClickListeners(cardFrontImageContainer);
                   removeImageClickListeners(cardBackImageContainer);
                  cardFrontTextContent.style.userSelect = 'none';
                  cardFrontTextContent.style.webkitUserSelect = 'none';
                  cardFrontTextContent.style.cursor = 'default';
                  cardBackTextContent.style.userSelect = 'none';
                  cardBackTextContent.style.webkitUserSelect = 'none';
                  cardBackTextContent.style.cursor = 'default';


                 return;
             }

            // Ensure currentCardIndex is within bounds
             currentCardIndex = Math.max(0, Math.min(currentCardIndex, currentDeck.shuffledIndices.length - 1));

            // Get the actual card index from the shuffled/ordered indices array
            const actualCardIndex = currentDeck.shuffledIndices[currentCardIndex];
             console.log(`Shuffled index: ${currentCardIndex}, Actual card index: ${actualCardIndex}`);

             // Ensure the actual index is valid
             if (actualCardIndex < 0 || actualCardIndex >= currentDeck.cards.length) {
                 console.error("Invalid shuffled index encountered:", actualCardIndex, "Deck:", currentDeck.name);
                 // Clear card content elements
                 cardFrontImageContainer.innerHTML = "";
                 cardFrontTextContent.innerHTML = "Error displaying card.";
                 cardBackImageContainer.innerHTML = "";
                 cardBackTextContent.innerHTML = "";

                 cardBack.classList.add('hidden');
                 cardFront.classList.remove('hidden');
                 isAnswerShowing = false;

                 // Hide and clear learning section image inputs
                 learningImageInputContainer.style.display = 'none';
                 clearLearningImageInputs();

                 updateFavoriteButtonState(false);
                 updateHighlightButtons(false); // Disable highlight buttons
                 updateProgressDisplay();
                 // Keep controls disabled or handle gracefully? Let's disable.
                 showAnswerBtn.disabled = true;
                 nextCardBtn.disabled = true;
                 previousCardBtn.disabled = true;
                 markKnownBtn.disabled = true;
                 markNeedsReviewBtn.disabled = true;
                 toggleFavoriteBtn.disabled = true;
                 highlighterBtn.disabled = true; // Disable highlighter button
                 highlighterBtn.classList.remove('active'); // Reset highlighter state
                 highlighterBtn.textContent = 'Highlighter'; // Reset text
                 isHighlighterActive = false; // Reset highlighter mode

                  // Ensure text selection is disabled
                  // Also remove any previously attached click listeners
                   removeImageClickListeners(cardFrontImageContainer);
                  removeImageClickListeners(cardBackImageContainer);
                  cardFrontTextContent.style.userSelect = 'none';
                  cardFrontTextContent.style.webkitUserSelect = 'none';
                  cardFrontTextContent.style.cursor = 'default';
                  cardBackTextContent.style.userSelect = 'none';
                  cardBackTextContent.style.webkitUserSelect = 'none';
                  cardBackTextContent.style.cursor = 'default';


                 return;
             }

            const card = currentDeck.cards[actualCardIndex];
             console.log("Current card object:", card);

             // --- Display Image on Card Faces ---
             // Clear image containers on both faces and remove old listeners
             removeImageClickListeners(cardFrontImageContainer);
             cardFrontImageContainer.innerHTML = "";
             removeImageClickListeners(cardBackImageContainer);
             cardBackImageContainer.innerHTML = "";


             if (card.frontImage) {
                 const img = document.createElement('img');
                 img.src = card.frontImage;
                 img.alt = "Front Image";
                 cardFrontImageContainer.appendChild(img);
                 // Add click listener to the new image element for modal zoom
                 img.addEventListener('click', () => openImageModal(card.frontImage, 'Front Image'));
             }
             if (card.backImage) {
                 const img = document.createElement('img');
                 img.src = card.backImage;
                 img.alt = "Back Image";
                 cardBackImageContainer.appendChild(img);
                 // Add click listener to the new image element for modal zoom
                 img.addEventListener('click', () => openImageModal(card.backImage, 'Back Image'));
             }


            // --- Display Text Content on Card Faces ---
            // Process text content, prioritizing saved highlighted versions
            cardFrontTextContent.innerHTML = card.frontHighlighted || processSyntaxHighlighting(card.front);
            cardBackTextContent.innerHTML = card.backHighlighted || processSyntaxHighlighting(card.back);


            // Always show front and hide back when a new card is displayed
            cardFront.classList.remove('hidden');
            cardBack.classList.add('hidden');
            isAnswerShowing = false; // Reset state to show front


            // --- Update Learning Section Image Inputs ---
             // Clear previous previews
             clearLearningImageInputs(); // This also hides controls

             // Display current card's images in the learning section input previews
             // We need to pass the image data (dataUrl) from the *current card* object
             if (card.frontImage) {
                 console.log("Displaying front image in learning input preview.");
                 displayImage(card.frontImage, learningFrontImagePreviewContainer, learningFrontImageControls);
             }
             if (card.backImage) {
                 console.log("Displaying back image in learning input preview.");
                 displayImage(card.backImage, learningBackImagePreviewContainer, learningBackImageControls);
             }
             // Show the learning image input container if hidden
             learningImageInputContainer.style.display = 'flex';


             // Update favorite button state
             updateFavoriteButtonState(card.isFavorite);

             // Update highlight button states based on current card face (front is visible initially)
             updateHighlightButtons(isAnswerShowing);


             // Show/Enable relevant controls
             showAnswerBtn.disabled = false;
             nextCardBtn.disabled = false;
             previousCardBtn.disabled = false;
             markKnownBtn.disabled = false;
             markNeedsReviewBtn.disabled = false;
             toggleFavoriteBtn.disabled = false; // Enable favorite button
             highlighterBtn.disabled = false; // Enable highlighter button


            updateProgressDisplay(); // Update display with current card number and overall progress

             // Ensure text selection is disabled on both text content areas by default
             cardFrontTextContent.style.userSelect = 'none';
             cardFrontTextContent.style.webkitUserSelect = 'none';
             cardFrontTextContent.style.cursor = 'default';
             cardBackTextContent.style.userSelect = 'none';
             cardBackTextContent.style.webkitUserSelect = 'none';
             cardBackTextContent.style.cursor = 'default';


             // Ensure highlighter button reflects current state and updates text selection on active face
             if (isHighlighterActive) {
                 highlighterBtn.classList.add('active');
                 highlighterBtn.textContent = 'Highlighter (ON)';
                 // Allow text selection only on the currently visible text content area
                 const activeTextContent = isAnswerShowing ? cardBackTextContent : cardFrontTextContent;
                 activeTextContent.style.userSelect = 'text';
                 activeTextContent.style.webkitUserSelect = 'text';
                 activeTextContent.style.cursor = 'text';
                 // Ensure inactive face remains non-selectable
                 const inactiveTextContent = isAnswerShowing ? cardFrontTextContent : cardBackTextContent;
                 inactiveTextContent.style.userSelect = 'none';
                 inactiveTextContent.style.webkitUserSelect = 'none';
                 inactiveTextContent.style.cursor = 'default';
                 // Disable undo/reset while actively highlighting
                 undoHighlightBtn.disabled = true;
                 resetHighlightBtn.disabled = true;
             } else {
                  highlighterBtn.classList.remove('active');
                  highlighterBtn.textContent = 'Highlighter';
                  // Disable text selection when inactive on BOTH faces (current and other)
                  cardFrontTextContent.style.userSelect = 'none';
                  cardFrontTextContent.style.webkitUserSelect = 'none';
                  cardFrontTextContent.style.cursor = 'default';
                  cardBackTextContent.style.userSelect = 'none';
                  cardBackTextContent.style.webkitUserSelect = 'none';
                  cardBackTextContent.style.cursor = 'default';
                 // Re-enable undo/reset buttons based on state
                 updateHighlightButtons(isAnswerShowing);
             }

        }

         // Helper to update the state of the undo and reset highlight buttons
         function updateHighlightButtons(isBackFace) {
             if (!currentDeck || !currentDeck.cards || currentDeck.cards.length === 0 || currentDeck.shuffledIndices.length === 0) {
                  undoHighlightBtn.disabled = true;
                  resetHighlightBtn.disabled = true;
                  return;
             }
              const actualCardIndex = currentDeck.shuffledIndices[currentCardIndex];
              if (actualCardIndex < 0 || actualCardIndex >= currentDeck.cards.length) {
                 undoHighlightBtn.disabled = true;
                 resetHighlightBtn.disabled = true;
                 return;
              }
             const card = currentDeck.cards[actualCardIndex];

              // Check if there is saved highlighted content or history for the *current* face's text
              const hasSavedHighlight = isBackFace ? card.backHighlighted : card.frontHighlighted;
              const hasHistory = isBackFace ? (card.backHighlightHistory && card.backHighlightHistory.length > 0) : (card.frontHighlightHistory && card.frontHighlightHistory.length > 0);

             undoHighlightBtn.disabled = !hasHistory; // Enable undo only if there's history
             resetHighlightBtn.disabled = !hasSavedHighlight; // Enable reset only if there's saved highlighted content

              // Ensure undo/reset are disabled if highlighter mode is ON
              if (isHighlighterActive) {
                  undoHighlightBtn.disabled = true;
                  resetHighlightBtn.disabled = true;
              }
             // console.log(`Highlight buttons state updated (Back face: ${isBackFace}): Undo Disabled = ${undoHighlightBtn.disabled}, Reset Disabled = ${resetHighlightBtn.disabled}`);
         }


        showAnswerBtn.addEventListener('click', () => {
             console.log("Show Answer button clicked. Current state:", isAnswerShowing);
            if (!currentDeck || currentDeck.cards.length === 0 || currentDeck.shuffledIndices.length === 0) {
                 console.warn("Show Answer button clicked but no cards loaded.");
                 return; // Should be disabled if no cards, but safety check
             }
            isAnswerShowing = !isAnswerShowing; // Toggle state
             console.log("New state:", isAnswerShowing);

            // Get the card faces and their containers
            const currentCardFaceElement = isAnswerShowing ? cardBack : cardFront;
            const otherCardFaceElement = isAnswerShowing ? cardFront : cardBack;

            const currentTextContentElement = isAnswerShowing ? cardBackTextContent : cardFrontTextContent;
             const otherTextContentElement = isAnswerShowing ? cardFrontTextContent : cardBackTextContent;

            // Update visibility
            otherCardFaceElement.classList.add('hidden');    // Hide the face that was showing
            currentCardFaceElement.classList.remove('hidden'); // Show the new face

             // Manage user-select on text content divs
             otherTextContentElement.style.userSelect = 'none'; // Disable select on the face that is now hidden
             otherTextContentElement.style.webkitUserSelect = 'none';
             otherTextContentElement.style.cursor = 'default';

             if (isHighlighterActive) {
                 currentTextContentElement.style.userSelect = 'text'; // Enable select on the visible face if highlighter is ON
                 currentTextContentElement.style.webkitUserSelect = 'text';
                 currentTextContentElement.style.cursor = 'text';
             } else {
                  currentTextContentElement.style.userSelect = 'none'; // Disable select if highlighter is OFF
                  currentTextContentElement.style.webkitUserSelect = 'none';
                  currentTextContentElement.style.cursor = 'default';
             }


             // Update highlight button states based on the now visible face
             updateHighlightButtons(isAnswerShowing);

        });

         // --- Standard Navigation Button Logic ---

        nextCardBtn.addEventListener('click', () => {
            console.log("Next Card button clicked. Current index:", currentCardIndex);
            if (currentDeck && currentDeck.shuffledIndices.length > 0) {
                 currentCardIndex = (currentCardIndex + 1) % currentDeck.shuffledIndices.length; // Loop back to start
                 console.log("Moving to next card index:", currentCardIndex);
                displayCurrentCard(); // Display the next card (resets to front view)
            }
        });

        previousCardBtn.addEventListener('click', () => {
            console.log("Previous Card button clicked. Current index:", currentCardIndex);
             if (currentDeck && currentDeck.shuffledIndices.length > 0) {
                currentCardIndex = (currentCardIndex - 1 + currentDeck.shuffledIndices.length) % currentDeck.shuffledIndices.length; // Loop back to end
                 console.log("Moving to previous card index:", currentCardIndex);
                displayCurrentCard(); // Display the previous card (resets to front view)
            }
        });

        randomizeCheckbox.addEventListener('change', () => {
            console.log("Randomize checkbox changed. Checked:", randomizeCheckbox.checked);
            if (currentDeck) {
                // Re-shuffle or reset order if randomization state changes while a deck is loaded
                const initialIndices = Array.from({length: currentDeck.cards.length}, (_, i) => i);
                if (randomizeCheckbox.checked) {
                     // Shuffle the original indices to get a new random order
                     currentDeck.shuffledIndices = shuffleArray(initialIndices);
                     console.log("Deck shuffled.");
                } else {
                     // If not random, reset to the original index order (0, 1, 2...)
                     currentDeck.shuffledIndices = initialIndices;
                     console.log("Deck order reset to original.");
                }
                currentCardIndex = 0; // Start from the beginning of the new order
                 console.log("Resetting to card index 0 after reordering.");
                displayCurrentCard(); // Display the first card in the new order
                 // Note: shuffledIndices is NOT saved with the deck, it's session-specific.
            }
             // If no deck is loaded, the change just affects the setting for the *next* loaded deck
             console.log("Randomize setting updated.");
        });

        // Basic shuffling function (Fisher-Yates) - creates a new shuffled array
        function shuffleArray(array) {
            const shuffled = [...array]; // Work on a copy
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]]; // Swap elements
            }
            return shuffled;
        }


        // --- Favorite Logic ---

        function updateFavoriteButtonState(isFavorite) {
             if (isFavorite) {
                 toggleFavoriteBtn.textContent = 'Unmark Favorite';
                 toggleFavoriteBtn.classList.add('is-favorite');
             } else {
                 toggleFavoriteBtn.textContent = 'Mark as Favorite';
                 toggleFavoriteBtn.classList.remove('is-favorite');
             }
              // console.log(`Favorite button state updated. Is Favorite: ${isFavorite}, Class List: ${toggleFavoriteBtn.classList}`);
        }

        toggleFavoriteBtn.addEventListener('click', () => {
             console.log("Favorite button clicked.");
             if (!currentDeck || currentDeck.cards.length === 0 || currentDeck.shuffledIndices.length === 0) {
                  console.warn("Favorite button clicked but no cards loaded.");
                 return; // Should be disabled if no cards, but safety check
             }

             const actualCardIndex = currentDeck.shuffledIndices[currentCardIndex];
             const card = currentDeck.cards[actualCardIndex]; // Get the current card object in the currentDeck array
             const wasFavorite = card.isFavorite;

             // Toggle favorite status in the in-memory object
             card.isFavorite = !card.isFavorite;
             console.log(`Toggling favorite for card (Actual Index ${actualCardIndex}). New state: ${card.isFavorite}`);


             // Update and save the original deck using the helper function
             const updated = updateCardInOriginalDeck(card, (originalCard) => {
                  // The helper function copies the favorite status from 'card' to 'originalCard' automatically
                  // after calling this callback, so no explicit update is needed here.
                  // originalCard.isFavorite = card.isFavorite; // This line is now redundant
             });


             if (!updated) {
                  console.error("Could not find original card to update favorite status. Reverting state.");
                  alert("Error updating favorite status. Could not find the original card in storage.");
                   // Revert the state in the temporary card object if we couldn't save
                  card.isFavorite = wasFavorite; // Revert in-memory change
                  updateFavoriteButtonState(card.isFavorite); // Revert button state
                   return; // Stop if save failed
             }

             console.log("Favorite status saved successfully.");

             // If we are in the All Favorites view and just unmarked a card, remove it from the current session.
             if (currentDeck.name === ALL_FAVORITES_KEY && !card.isFavorite) {
                  console.log("Card unmarked as favorite in Favorites view. Removing from current session.");
                 // Remove the card from the *current temporary* shuffledIndices list
                 // Find the index of the current *shuffled* card in the shuffledIndices array
                 const currentShuffledIndexInIndices = currentDeck.shuffledIndices.indexOf(actualCardIndex);

                 if (currentShuffledIndexInIndices > -1) {
                      console.log(`Found card at shuffled index ${currentShuffledIndexInIndices}. Removing.`);
                      // Remove the entry from shuffledIndices
                      currentDeck.shuffledIndices.splice(currentShuffledIndexInIndices, 1);

                      // Move to the next card in the updated list (using the modified shuffledIndices)
                      if (currentDeck.shuffledIndices.length > 0) {
                           // Adjust currentCardIndex to stay within new bounds
                           // If we removed the card at the last index, the new last index is one less.
                           // If the index is now out of bounds because we removed the last element, wrap around.
                           currentCardIndex = currentCardIndex % currentDeck.shuffledIndices.length; // Wrap handles the 0 case if only 1 card left
                           console.log("Moving to next card after removing favorite. New index:", currentCardIndex);
                           displayCurrentCard(); // Re-display the card at the new currentCardIndex
                      } else {
                           // No cards left in the favorites session
                           console.log("No more favorite cards left in this view.");
                           alert("No more favorite cards left in this view.");
                           resetLearningArea();
                           populateDeckSelect(); // Refresh options
                       }
                        // Update progress display regardless of whether we moved cards
                       updateProgressDisplay(); // Update progress for the favorites view
                 } else {
                      console.error("Error finding current card's shuffled index in shuffled indices array during favorite removal. This shouldn't happen.");
                      // If we can't find it, maybe just try to display the next card and log the error
                       // This is a fallback, ideally the index should always be found
                       // Attempt to move to next, but it might cause issues if indices are truly broken.
                      if (currentDeck.shuffledIndices.length > 0) { // Only try if there are cards left
                          currentCardIndex = currentCardIndex % currentDeck.shuffledIndices.length; // Ensure index is valid
                          displayCurrentCard();
                          updateProgressDisplay();
                      } else { // If no cards left, just reset
                           resetLearningArea();
                           populateDeckSelect();
                      }
                 }


             } else {
                  // If not in favorites view, or if favoriting, just update progress display and button state
                   console.log("Favorite status updated in regular deck or card favorited. Updating UI.");
                  updateFavoriteButtonState(card.isFavorite); // Update button state visually
                  updateProgressDisplay(); // Update progress counts
             }

        });


        // --- Progress Tracking (Basic Status) ---

        // Helper function to find and update a card in its original deck in localStorage
        // updateFunc is a function that takes the original card object and modifies it
        // Returns true if successful, false otherwise.
        function updateCardInOriginalDeck(currentCard, updateFunc) {
             console.log("updateCardInOriginalDeck called.");
             if (!currentCard) {
                 console.error("updateCardInOriginalDeck called with null currentCard.");
                 return false;
             }

             let originalDeckName;
             let cardIdentifier; // Use front text or source info as identifier

             // If the currentDeck is the ALL_FAVORITES_KEY deck, the original deck/card info
             // is stored directly on the card object itself (`sourceDeckName`, `sourceCardFront`)
             if (currentDeck.name === ALL_FAVORITES_KEY && currentCard.sourceDeckName && currentCard.sourceCardFront !== undefined) {
                 originalDeckName = currentCard.sourceDeckName;
                 cardIdentifier = currentCard.sourceCardFront; // Use original front for lookup
                 console.log(`updateCardInOriginalDeck (Favorites View): Looking for card "${cardIdentifier || '(Empty Front)'}" in deck "${originalDeckName}".`);
             } else if (currentDeck.name !== ALL_FAVORITES_KEY && currentDeck.name && currentCard.front !== undefined) {
                 // If it's a regular deck, the original deck is the current deck
                 originalDeckName = currentDeck.name;
                 cardIdentifier = currentCard.front; // Use current front for lookup
                  console.log(`updateCardInOriginalDeck (Regular View): Looking for card "${cardIdentifier || '(Empty Front)'}" in deck "${originalDeckName}".`);
             } else {
                 console.error("Could not determine original deck or card info for update.");
                 return false;
             }


            if (originalDeckName && cardIdentifier !== undefined) {
                const decks = getAllDecksFromStorage();
                const originalDeck = decks[originalDeckName];

                if (originalDeck && Array.isArray(originalDeck.cards)) {
                     // Find the card in the original deck by its identifier (front text)
                     // Use findIndex for potential future updates that need the index
                    const originalCardIndex = originalDeck.cards.findIndex(c => c.front === cardIdentifier);

                    if (originalCardIndex > -1) {
                        const originalCard = originalDeck.cards[originalCardIndex];
                         console.log("Original card found:", originalCard);
                        // Apply the update function (e.g., change status, highlights, images)
                        updateFunc(originalCard); // This modifies the originalCard object

                         console.log("Original card after updateFunc:", originalCard);


                         // After updateFunc modifies originalCard, copy highlight/image/status/favorite changes
                         // from the in-memory currentCard object (which might have been modified
                         // directly by highlight/image/favorite UI handlers in the Learning section)
                         // back to the originalCard object found in the decks array *before* saving.
                         // This ensures persistent changes from the learning UI are saved.
                         // Note: For regular decks, `card` *is* the object from `currentDeck.cards[actualCardIndex]`.
                         // For favorites, `card` is a copy. This explicit copy makes the logic consistent.
                         originalCard.status = currentCard.status;
                         originalCard.isFavorite = currentCard.isFavorite;
                         originalCard.frontHighlighted = currentCard.frontHighlighted;
                         originalCard.backHighlighted = currentCard.backHighlighted;
                         originalCard.frontImage = currentCard.frontImage;
                         originalCard.backImage = currentCard.backImage;
                         // History is NOT copied.


                         console.log("Final original card state before saving:", originalCard);

                        // Save the modified original deck back to storage
                        saveDeck(originalDeck); // This calls the saveDeck that cleans history and temporary properties
                         console.log(`Original deck "${originalDeckName}" saved.`);

                        return true; // Success
                    } else {
                         console.error(`Could not find original card "${cardIdentifier || '(Empty Front)'}" in deck "${originalDeckName}" for update.`);
                         // Maybe the card was deleted from the original deck while viewing in Favorites?
                    }
                } else {
                     console.error(`Could not find original deck "${originalDeckName}" in storage for update.`);
                     // Maybe the original deck was deleted?
                }
            } else {
                console.error("Missing information to find original card for update.");
            }
            return false; // Failure
        }


        markKnownBtn.addEventListener('click', () => {
             console.log("Mark Known button clicked.");
             if (!currentDeck || currentDeck.cards.length === 0 || currentDeck.shuffledIndices.length === 0) return;

              const actualCardIndex = currentDeck.shuffledIndices[currentCardIndex];
              if (actualCardIndex < 0 || actualCardIndex >= currentDeck.cards.length) return;
              const card = currentDeck.cards[actualCardIndex]; // Get the current card object in the currentDeck array

             // Update status in the in-memory object
             card.status = 'known';
             console.log(`Marking card (Actual Index ${actualCardIndex}) as known. New status: ${card.status}`);


             // Update status in the original deck in storage
             const updated = updateCardInOriginalDeck(card, (originalCard) => {
                  // The updateFunc just needs to indicate the *intention*.
                  // updateCardInOriginalDeck now copies status from the in-memory card.
                  // originalCard.status = 'known'; // This line is technically not needed now
             });

             if (updated) {
                updateProgressDisplay();
             } else {
                 console.error("Failed to save 'known' status.");
                 alert("Error marking card as known.");
                 // Revert status in memory if save failed? Maybe too complex for basic status.
                 // For simplicity, assume the in-memory change sticks even if save fails.
                 // User will see it updated locally but it might revert on page reload.
             }
        });

        markNeedsReviewBtn.addEventListener('click', () => {
             console.log("Mark Needs Review button clicked.");
             if (!currentDeck || currentDeck.cards.length === 0 || currentDeck.shuffledIndices.length === 0) return;

              const actualCardIndex = currentDeck.shuffledIndices[currentCardIndex];
              if (actualCardIndex < 0 || actualCardIndex >= currentDeck.cards.length) return;
              const card = currentDeck.cards[actualCardIndex]; // Get the current card object in the currentDeck array

              // Update status in the in-memory object
              card.status = 'needsReview';
             console.log(`Marking card (Actual Index ${actualCardIndex}) as needsReview. New status: ${card.status}`);


              // Update status in the original deck in storage
              const updated = updateCardInOriginalDeck(card, (originalCard) => {
                  // updateCardInOriginalDeck now copies status from the in-memory card.
                  // originalCard.status = 'needsReview'; // This line is technically not needed now
              });

             if (updated) {
                updateProgressDisplay();
             } else {
                 console.error("Failed to save 'needsReview' status.");
                 alert("Error marking card as 'Needs Review'.");
             }
        });


        function updateProgressDisplay() {
             console.log("Updating progress display.");
            if (currentDeck && currentDeck.cards && currentDeck.cards.length > 0) {

                const totalCardsInView = currentDeck.shuffledIndices ? currentDeck.shuffledIndices.length : 0;
                 const currentCardNumberDisplay = totalCardsInView > 0 ? currentCardIndex + 1 : 0;


                if (currentDeck.name === ALL_FAVORITES_KEY) {
                     // For Favorites view, just show count and current card number
                     const totalFavorites = currentDeck.cards.length; // Total cards currently in the favorite view
                     progressDisplay.innerHTML = `Card: ${currentCardNumberDisplay}/${totalCardsInView}<br>
                                                  Total Favorites: ${totalFavorites}`;
                } else {
                     // For regular decks, show standard progress counts
                     const knownCount = currentDeck.cards.filter(card => card.status === 'known').length;
                      const needsReviewCount = currentDeck.cards.filter(card => card.status === 'needsReview').length;
                      const newCount = currentDeck.cards.filter(card => card.status === 'new').length;
                     const totalCards = currentDeck.cards.length; // Total cards in the original deck
                     const knownPercentage = totalCards > 0 ? ((knownCount / totalCards) * 100).toFixed(0) : 0;


                    progressDisplay.innerHTML = `Card: ${currentCardNumberDisplay}/${totalCardsInView}<br>
                                                Deck Status: ${knownCount} Known / ${needsReviewCount} Review / ${newCount} New<br>
                                                Overall Progress: ${knownPercentage}% Known`;
                }
             console.log("Progress display updated.");
            } else {
                 progressDisplay.textContent = '';
                 console.log("Progress display cleared (no deck loaded).");
            }
        }


        // --- File Import/Export (Individual Deck Files) ---

        importDeckInput.addEventListener('change', (event) => {
             console.log("Import file selected.");
            const file = event.target.files[0];
            if (!file) {
                 console.log("No file selected for import.");
                return;
            }
             console.log("Import file:", file.name);
            const reader = new FileReader();
            reader.onload = (e) => {
                 console.log("File read complete.");
                try {
                    const importedDeck = JSON.parse(e.target.result);
                    // Basic validation: Check if it looks like a deck object
                    if (importedDeck && typeof importedDeck.name === 'string' && Array.isArray(importedDeck.cards)) {
                         console.log("File appears to be a valid deck format.");

                         // Clean up and ensure necessary properties for imported cards
                         importedDeck.cards.forEach(card => {
                             // If importing from old format or SRS, set default status/favorite
                             if (!card.status || (card.status !== 'new' && card.status !== 'known' && card.status !== 'needsReview')) {
                                 card.status = 'new';
                             }
                              if (typeof card.isFavorite !== 'boolean') { // Add default favorite status if missing
                                 card.isFavorite = false;
                             }
                              // Initialize highlight properties if missing, or ensure they are strings/undefined
                              if (typeof card.frontHighlighted !== 'string' && typeof card.frontHighlighted !== 'undefined') card.frontHighlighted = undefined;
                              if (typeof card.backHighlighted !== 'string' && typeof card.backHighlighted !== 'undefined') card.backHighlighted = undefined;

                               // Initialize image properties if missing, or ensure they are strings/undefined
                               if (typeof card.frontImage !== 'string' && typeof card.frontImage !== 'undefined') card.frontImage = undefined;
                               if (typeof card.backImage !== 'string' && typeof card.backImage !== 'undefined') card.backImage = undefined;


                              // --- IMPORTANT for Import: Reset history, don't import it ---
                               // History is session/local state, not part of the permanent deck data.
                              card.frontHighlightHistory = [];
                              card.backHighlightHistory = [];


                             // Remove old SRS properties if they exist in the imported file
                             delete card.interval;
                             delete card.repetitions;
                             delete card.easeFactor;
                             delete card.dueDate;
                             // Also remove temporary source info if present from a favorited export (unlikely but safe)
                             delete card.sourceDeckName;
                             delete card.sourceCardFront;
                         });
                          // Ensure folder property exists (string or undefined)
                         if (typeof importedDeck.folder !== 'string' && typeof importedDeck.folder !== 'undefined') {
                            importedDeck.folder = undefined;
                         }


                         // We don't save shuffledIndices or display name with the deck file itself
                         delete importedDeck.shuffledIndices;
                         delete importedDeck.displayName;


                         // Check if a deck with this name already exists and confirm overwrite
                         const existingDecks = getAllDecksFromStorage();
                         if (existingDecks[importedDeck.name]) {
                             if (!confirm(`A deck named "${importedDeck.name}" already exists in your browser. Do you want to overwrite it with the imported file? This will replace the existing deck and its progress/favorites/highlights/history/images.`)) {
                                 // User cancelled import
                                  console.log("Import cancelled by user (overwrite prompt).");
                                 event.target.value = ''; // Reset file input
                                 return;
                             }
                             console.log(`Overwriting existing deck "${importedDeck.name}" with imported data.`);
                         }

                         // Check if the imported deck name is the special favorites key
                         if (importedDeck.name === ALL_FAVORITES_KEY) {
                              alert(`Cannot import a deck with the reserved name "${ALL_FAVORITES_KEY}". Please rename the deck file.`);
                              event.target.value = ''; // Reset file input
                               console.warn("Import failed: Reserved deck name used.");
                              return;
                         }

                         // Check for extremely large decks (potential performance/storage issues)
                         if (importedDeck.cards.length > 5000) { // Example limit
                             console.warn(`Imported deck "${importedDeck.name}" has ${importedDeck.cards.length} cards. This is a large deck.`);
                             // Optionally warn the user here
                             // if (!confirm(`Imported deck "${importedDeck.name}" has ${importedDeck.cards.length} cards. This is a large deck and might impact performance or storage. Proceed?`)) {
                             //     event.target.value = ''; // Reset file input
                             //     return;
                             // }
                         }
                         // Check for extremely large images (Base64 strings can be huge)
                          // Simple check on string length - not perfect, but indicates potential issue
                          const totalImageSizeEstimate = importedDeck.cards.reduce((sum, card) => {
                              let size = 0;
                              if (card.frontImage && typeof card.frontImage === 'string') size += card.frontImage.length;
                              if (card.backImage && typeof card.backImage === 'string') size += card.backImage.length;
                              return sum + size;
                          }, 0);

                           if (totalImageSizeEstimate > 10 * 1024 * 1024) { // Example limit: ~10MB of Base64 string data
                               console.warn(`Imported deck "${importedDeck.name}" has large image data (${(totalImageSizeEstimate / (1024*1024)).toFixed(2)} MB estimate).`);
                               // Optionally warn the user
                           }


                         // Save the imported deck to localStorage
                         saveDeck(importedDeck); // This updates the overall collection in localStorage

                         alert(`Deck "${importedDeck.name}" imported and saved to your browser successfully!`);
                         console.log(`Deck "${importedDeck.name}" imported successfully.`);

                         // Select the newly imported deck in the dropdown
                         // Use a timeout to ensure the populateDeckSelect has finished adding the option
                         setTimeout(() => {
                              populateFolderSelect(); // Need to repopulate folders just in case
                              populateDeckSelect();
                              // Select the imported deck if it exists in the new list
                              if (deckSelect.querySelector(`option[value="${importedDeck.name}"]`)) {
                                   deckSelect.value = importedDeck.name;
                              }
                             // Don't automatically load, let the user click Load
                             resetLearningArea(); // Ensure current view is cleared
                         }, 50);


                    } else {
                        alert("Invalid flashcard deck file format. File must be a JSON object with 'name' (string) and 'cards' (array) properties.");
                         console.error("Import failed: Invalid file format.", importedDeck);
                    }
                } catch (error) {
                    alert("Error reading or parsing the file: " + error.message);
                    console.error("Error during file import:", error);
                } finally {
                    // Reset the file input so the same file can be selected again if needed
                    event.target.value = '';
                }
            };
             reader.onerror = function() {
                  alert("Error reading file: " + reader.error);
                   console.error("Error reading file during import:", reader.error);
                   event.target.value = ''; // Reset file input
             };
            reader.readAsText(file); // Read the file content as text
        });

        // Handle export current deck button click
        exportCurrentDeckBtn.addEventListener('click', () => {
            console.log("Export button clicked.");
            if (!currentDeck || currentDeck.name === ALL_FAVORITES_KEY) {
                alert("Please load a regular deck first before exporting. The 'All Favorite Cards' view cannot be exported as a single deck file.");
                 console.warn("Export attempted without a regular deck loaded.");
                return;
            }

            // Ensure we export the current state of the deck from localStorage, not just the in-memory object
             const decks = getAllDecksFromStorage();
             const deckToExport = decks[currentDeck.name]; // Get the latest version

             if (!deckToExport) {
                 alert("Could not find the currently loaded deck in storage for export. Please try loading it again.");
                  console.error(`Could not find deck "${currentDeck.name}" in storage for export.`);
                 return;
             }
            console.log(`Preparing to export deck "${deckToExport.name}".`);

             // Clean up the deck object for export - remove temporary internal state like shuffledIndices or display name
             const cleanedDeck = JSON.parse(JSON.stringify(deckToExport)); // Deep copy

             // --- IMPORTANT for Export: Remove history from exported file ---
              // History is session/local state, not part of the permanent deck data.
             cleanedDeck.cards.forEach(card => {
                 delete card.frontHighlightHistory;
                 delete card.backHighlightHistory;
                  // Ensure temporary source info is also removed, though shouldn't be on regular decks
                 delete card.sourceDeckName;
                 delete card.sourceCardFront;
             });

             delete cleanedDeck.shuffledIndices;
             delete cleanedDeck.displayName; // Should not be on regular decks anyway, but safety

            console.log("Cleaned deck object for export:", cleanedDeck);

            const dataStr = JSON.stringify(cleanedDeck, null, 2); // Pretty print JSON
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = `${deckToExport.name.replace(/[^a-z0-9]/gi, '_')}_flashcard_deck.json`; // Sanitize filename and add suffix
            document.body.appendChild(a); // Required for Firefox
            a.click(); // Trigger download
            document.body.removeChild(a); // Clean up
            URL.revokeObjectURL(url); // Free up the object URL

             console.log(`Deck "${deckToExport.name}" export initiated.`);
            // Optional: Inform user
            // alert(`Exported deck "${currentDeck.name}".`);
        });


        // --- Delete Deck ---
        deleteDeckBtn.addEventListener('click', () => {
             console.log("Delete Deck button clicked.");
             const selectedDeckName = deckSelect.value;
             console.log("Selected deck to delete:", selectedDeckName);
            if (selectedDeckName && selectedDeckName !== ALL_FAVORITES_KEY) {
                const decks = getAllDecksFromStorage();
                const deckToDelete = decks[selectedDeckName];
                const folderDisplay = deckToDelete && deckToDelete.folder ? ` in folder "${deckToDelete.folder}"` : "";

                if (confirm(`Are you sure you want to delete the deck "${selectedDeckName}"${folderDisplay} from your browser's storage? This action cannot be undone.`)) {
                    delete decks[selectedDeckName];
                    saveAllDecksToStorage(decks);
                    console.log(`Deck "${selectedDeckName}" deleted from storage.`);

                    // Check if the currently loaded deck was the one deleted
                    if (currentDeck && currentDeck.name === selectedDeckName) {
                         console.log("Deleted deck was the currently loaded deck. Resetting learning area.");
                         resetLearningArea(); // Reset if the deleted deck was loaded
                    }

                    alert(`Deck "${selectedDeckName}" deleted.`);
                     // Re-populate dropdowns to reflect the deletion
                    populateFolderSelect();
                    populateDeckSelect();
                } else {
                     console.log("Deck deletion cancelled by user.");
                }
            } else if (selectedDeckName === ALL_FAVORITES_KEY) {
                alert("You cannot delete the 'All Favorite Cards' view. This view shows cards marked as favorite across all your decks.");
                 console.warn("Delete attempted on All Favorites view.");
            }
             else {
                 alert("Please select a deck to delete.");
                 console.warn("Delete attempted with no deck selected.");
            }
        });

        // --- Delete Folder ---
        deleteFolderBtn.addEventListener('click', () => {
             console.log("Delete Folder button clicked.");
             const selectedFolder = folderSelect.value;
             console.log("Selected folder to delete:", selectedFolder);

             if (selectedFolder === "" || selectedFolder === "new-folder-option") {
                 alert("Please select a specific folder to delete.");
                  console.warn("Delete folder attempted without selecting a specific folder.");
                 return;
             }

             const allDecks = getAllDecksFromStorage();
             const decksInFolder = Object.values(allDecks).filter(deck => (deck.folder || '').trim() === selectedFolder.trim());

             if (decksInFolder.length === 0) {
                  console.log(`Folder "${selectedFolder}" is empty.`);
                  if (confirm(`Folder "${selectedFolder}" appears empty. Do you want to delete it anyway?`)) {
                       // To delete an empty folder visually, we just need to repopulate the select boxes.
                       // The data structure implicitly doesn't store empty folders.
                       alert(`Folder "${selectedFolder}" removed from list.`);
                       console.log(`Empty folder "${selectedFolder}" removed from UI list.`);
                       populateFolderSelect(); // Repopulating removes the empty folder option
                       populateDeckSelect(); // Ensure deck select is also refreshed
                  } else {
                       console.log("Empty folder deletion cancelled by user.");
                  }
                  return;
             }


             const confirmMessage = `Are you sure you want to delete the folder "${selectedFolder}"?\n\nThis will also delete ${decksInFolder.length} deck(s) within this folder:\n- ${decksInFolder.map(d => d.name).join('\n- ')}\n\nFavorite status, progress, highlights, and images for cards in these decks will also be lost.\n\nThis action cannot be undone.`;

             if (confirm(confirmMessage)) {
                  console.log(`Deleting folder "${selectedFolder}" and its decks.`);
                  const decksAfterDeletion = {};
                  for (const deckName in allDecks) {
                       const deck = allDecks[deckName];
                       // Keep decks that are NOT in the selected folder
                       if ((deck.folder || '').trim() !== selectedFolder.trim()) {
                           decksAfterDeletion[deckName] = deck;
                       } else {
                            console.log(`Deleting deck "${deckName}" as part of folder deletion.`);
                       }
                  }

                  saveAllDecksToStorage(decksAfterDeletion);
                   console.log("Decks collection saved after folder deletion.");

                  // Check if the currently loaded deck was in the deleted folder
                  // Need to check if currentDeck exists and if its name matches any of the deleted decks
                   if (currentDeck && currentDeck.name !== ALL_FAVORITES_KEY) {
                       const wasCurrentDeckDeleted = decksInFolder.some(deck => deck.name === currentDeck.name);
                       if (wasCurrentDeckDeleted) {
                           console.log("Currently loaded deck was in the deleted folder. Resetting learning area.");
                           resetLearningArea();
                       }
                   }
                   // If in favorites view, resetting is handled implicitly by populateDeckSelect
                   // and the next time favorites are loaded, the deleted cards won't be included.


                  alert(`Folder "${selectedFolder}" and its ${decksInFolder.length} deck(s) deleted.`);
                  populateFolderSelect(); // Refresh dropdowns
                  populateDeckSelect();
             } else {
                  console.log("Folder deletion cancelled by user.");
             }
        });


        // --- Highlighter Feature ---

        highlighterBtn.addEventListener('click', () => {
             console.log("Highlighter button clicked. Current state:", isHighlighterActive);
            if (!currentDeck || currentDeck.cards.length === 0 || currentDeck.shuffledIndices.length === 0) {
                 console.warn("Highlighter button clicked but no cards loaded.");
                 return;
            }

            isHighlighterActive = !isHighlighterActive; // Toggle highlighter mode
             console.log("Highlighter new state:", isHighlighterActive);

             // Determine which text content element is currently visible
             const activeTextContent = isAnswerShowing ? cardBackTextContent : cardFrontTextContent;
             const inactiveTextContent = isAnswerShowing ? cardFrontTextContent : cardBackTextContent;


            if (isHighlighterActive) {
                highlighterBtn.classList.add('active');
                highlighterBtn.textContent = 'Highlighter (ON)';
                 // Allow text selection when active
                 activeTextContent.style.userSelect = 'text';
                 activeTextContent.style.webkitUserSelect = 'text';
                 activeTextContent.style.cursor = 'text';
                 // Ensure inactive face remains non-selectable
                 inactiveTextContent.style.userSelect = 'none';
                 inactiveTextContent.style.webkitUserSelect = 'none';
                 inactiveTextContent.style.cursor = 'default';
                 // Disable undo/reset while actively highlighting
                 undoHighlightBtn.disabled = true;
                 resetHighlightBtn.disabled = true;
            } else {
                highlighterBtn.classList.remove('active');
                highlighterBtn.textContent = 'Highlighter';
                 // Disable text selection when inactive on BOTH faces (current and other)
                 activeTextContent.style.userSelect = 'none';
                 activeTextContent.style.webkitUserSelect = 'none';
                 activeTextContent.style.cursor = 'default';
                  inactiveTextContent.style.userSelect = 'none';
                  inactiveTextContent.style.webkitUserSelect = 'none';
                  inactiveTextContent.style.cursor = 'default';
                 // Re-enable undo/reset buttons based on state
                 updateHighlightButtons(isAnswerShowing);
            }
        });

        // Function to handle text selection and highlighting via mouseup on card faces
        function handleCardSelection(event) {
            // This listener is on the text-content divs now
             console.log("Mouseup on card text content.");
            if (!isHighlighterActive) {
                 console.log("Highlighter is not active. Ignoring selection.");
                 return; // Only process when highlighter is active
            }

            const selection = window.getSelection();
            const selectedText = selection.toString().trim();
            if (!selectedText) {
                 console.log("No text selected or selection is just whitespace. Ignoring.");
                 return; // No text selected
            }
             console.log("Selected text:", selectedText);

            // Check if selection is within the text content element it was triggered on
            const textContentElement = event.currentTarget;
             if (!textContentElement.classList.contains('card-text-content')) {
                 console.warn("Mouseup target is not a text content element? Ignoring.", event.currentTarget);
                 return; // Should not happen with the current listeners, but safety
             }

            const range = selection.getRangeAt(0);

            try {
                 // Ensure the selection is entirely within the current text content element
                 if (!textContentElement.contains(range.startContainer) || !textContentElement.contains(range.endContainer)) {
                      console.warn("Selection spans outside the current text content element. Ignoring.");
                      alert('Cannot highlight text that spans across different elements within the card face.');
                     selection.removeAllRanges();
                     return;
                 }
                 console.log("Selection is within the target text content element.");

                 // --- History: Save current state before applying highlight ---
                 const actualCardIndex = currentDeck.shuffledIndices[currentCardIndex];
                 const card = currentDeck.cards[actualCardIndex];
                 const isBackFace = textContentElement.parentElement.classList.contains('back'); // Check parent (.card-face)
                 const history = isBackFace ? card.backHighlightHistory : card.frontHighlightHistory;

                 // Store the current HTML state of the text content element
                 const currentHTML = textContentElement.innerHTML;

                  // Check if the current HTML is different from the last history state to avoid duplicates
                 if (history.length === 0 || history[history.length - 1] !== currentHTML) {
                     // Add the current HTML to history, limiting the size
                     history.push(currentHTML);
                     if (history.length > MAX_HIGHLIGHT_HISTORY) {
                         history.shift(); // Remove the oldest state
                     }
                     console.log("Added current HTML to history. History size:", history.length);
                 } else {
                      console.log("Current HTML is same as last history state. Not adding.");
                 }
                  // --- End History ---


                // Create a highlight span element (using the dedicated user-highlight class)
                const highlightSpan = document.createElement('span');
                highlightSpan.className = 'user-highlight'; // Use the specific class for user highlights

                // Apply the highlight - this is where surroundContents can fail on complex selections
                range.surroundContents(highlightSpan);
                console.log("Highlight span applied.");

                // Clear the selection after highlighting
                selection.removeAllRanges();
                console.log("Selection cleared.");

                // Save the new highlighted content of the text element
                saveHighlightedContent(isBackFace, textContentElement.innerHTML);
                 console.log("Saved highlighted content.");


            } catch (e) {
                console.error('Error applying highlight:', e);
                // This catch block is for when surroundContents fails due to complex DOM
                alert('Could not apply highlight to this selection. Try selecting text within a single word or phrase, avoiding borders of existing highlights or complex formatting.');
                 selection.removeAllRanges(); // Attempt to clear selection even on error
                 console.log("Error caught and selection cleared.");
            } finally {
                 // Always update button states after a highlight attempt
                 updateHighlightButtons(isAnswerShowing);
                  console.log("Highlight button states updated.");
            }
        }

        // Function to save highlighted content back to the card object in storage
        // Pass the updated HTML content of the text area explicitly
        function saveHighlightedContent(isBackFace, updatedTextHTML) {
             console.log("saveHighlightedContent called (Back face:", isBackFace, ")");
            if (!currentDeck || currentDeck.cards.length === 0 || currentDeck.shuffledIndices.length === 0) {
                 console.error("saveHighlightedContent called but no deck/card loaded.");
                 return;
             }

            const actualCardIndex = currentDeck.shuffledIndices[currentCardIndex];
             if (actualCardIndex < 0 || actualCardIndex >= currentDeck.cards.length) {
                 console.error("Invalid actual card index during highlight save:", actualCardIndex);
                 return;
             }

            const card = currentDeck.cards[actualCardIndex]; // This is the card object in the currentDeck array
             console.log("Updating in-memory card object for highlight.");
            // Update the highlighted property with the new HTML in the in-memory card object
            if (isBackFace) {
                card.backHighlighted = updatedTextHTML;
            } else {
                card.frontHighlighted = updatedTextHTML;
            }

            // Save the persistent change to the *original* card in storage
            const saved = updateCardInOriginalDeck(card, (originalCard) => {
                 // Copy the updated highlighted text HTML from the in-memory card to the original
                  if (isBackFace) {
                       originalCard.backHighlighted = card.backHighlighted;
                  } else {
                       originalCard.frontHighlighted = card.frontHighlighted;
                  }
                  // Image properties are also copied by updateCardInOriginalDeck now
              });
             if (!saved) {
                  console.error("Failed to save highlight via updateCardInOriginalDeck.");
                  // Optionally alert or indicate failure
             } else {
                  console.log("Highlight saved persistently.");
             }
             // No alert here, saving is implicit with highlighting
        }

        // --- Undo and Reset Highlight Logic ---

        undoHighlightBtn.addEventListener('click', () => {
             console.log("Undo Highlight button clicked.");
             if (!currentDeck || currentDeck.cards.length === 0 || currentDeck.shuffledIndices.length === 0) return;

              const actualCardIndex = currentDeck.shuffledIndices[currentCardIndex];
              if (actualCardIndex < 0 || actualCardIndex >= currentDeck.cards.length) return;
              const card = currentDeck.cards[actualCardIndex]; // Get the card object in the currentDeck array


             const isBackFace = isAnswerShowing;
             const history = isBackFace ? card.backHighlightHistory : card.frontHighlightHistory;
             const textContentElement = isBackFace ? cardBackTextContent : cardFrontTextContent;

             if (history && history.length > 0) {
                 // Pop the last state from history
                 const previousHTML = history.pop();
                 console.log(`Popped state from history. History size: ${history.length}. Restoring HTML:`, previousHTML);

                 // Update the card face's text content HTML
                 textContentElement.innerHTML = previousHTML;

                 // Update the saved highlighted property in the in-memory card object
                 if (isBackFace) {
                     // If history is now empty, reset saved highlight to undefined, otherwise set to the state we just restored
                     card.backHighlighted = history.length > 0 ? previousHTML : undefined;
                 } else {
                      // If history is now empty, reset saved highlight to undefined, otherwise set to the state we just restored
                     card.frontHighlighted = history.length > 0 ? previousHTML : undefined;
                 }
                 console.log("In-memory card highlighted state updated after undo:", isBackFace ? card.backHighlighted : card.frontHighlighted);


                 // Save the updated state (including modified highlighted property - history is not saved)
                 const saved = updateCardInOriginalDeck(card, (originalCard) => {
                     // Copy the updated highlighted property from the in-memory card to the original
                      if (isBackFace) {
                           originalCard.backHighlighted = card.backHighlighted;
                      } else {
                           originalCard.frontHighlighted = card.frontHighlighted;
                      }
                 });

                 if (!saved) {
                      console.error("Failed to save undo highlight via updateCardInOriginalDeck.");
                      // Optionally alert or indicate failure
                 } else {
                     console.log("Undo highlight saved persistently.");
                 }

                 // Update button states
                 updateHighlightButtons(isBackFace);
                  console.log("Highlight button states updated after undo.");

             } else {
                 console.log("Undo button clicked but highlight history is empty.");
                 // History is empty, nothing to undo
                 updateHighlightButtons(isBackFace); // Ensure button is disabled
             }
             // No alert here, undo is implicit
        });

        resetHighlightBtn.addEventListener('click', () => {
             console.log("Reset Highlight button clicked.");
             if (!currentDeck || currentDeck.cards.length === 0 || currentDeck.shuffledIndices.length === 0) return;

              const actualCardIndex = currentDeck.shuffledIndices[currentCardIndex];
              if (actualCardIndex < 0 || actualCardIndex >= currentDeck.cards.length) return;
              const card = currentDeck.cards[actualCardIndex]; // Get the card object in the currentDeck array


             const isBackFace = isAnswerShowing;
             const textContentElement = isBackFace ? cardBackTextContent : cardFrontTextContent;

             // --- History: Save current state before resetting ---
              const history = isBackFace ? card.backHighlightHistory : card.frontHighlightHistory;
              const currentHTML = textContentElement.innerHTML;
              // Only push to history if it's a different state
              if (history.length === 0 || history[history.length - 1] !== currentHTML) {
                  history.push(currentHTML);
                  if (history.length > MAX_HIGHLIGHT_HISTORY) {
                      history.shift();
                  }
                   console.log("Added current HTML to history before reset. History size:", history.length);
              } else {
                   console.log("Current HTML is same as last history state before reset. Not adding.");
              }
             // --- End History ---


             // Get the original text for the current face
             const originalText = isBackFace ? card.back : card.front;
              console.log("Original text for reset:", originalText);

             // Process the original text to re-apply ** syntax highlighting only
             const cleanHTML = processSyntaxHighlighting(originalText);
             console.log("Clean HTML after processing original text:", cleanHTML);


             // Update the card face's text content HTML
             textContentElement.innerHTML = cleanHTML;

             // Clear the saved user-applied highlighted property in the in-memory card object
             if (isBackFace) {
                 card.backHighlighted = undefined; // Reset saved user highlight
                 // History is NOT cleared on reset, so undo can still revert to the state before reset.
             } else {
                 card.frontHighlighted = undefined; // Reset saved user highlight
             }
             console.log("In-memory card highlighted state set to undefined after reset.");


             // Save the updated state (cleared highlighted property, keeping history)
             const saved = updateCardInOriginalDeck(card, (originalCard) => {
                 // Copy the updated highlighted property from the in-memory card to the original
                  if (isBackFace) {
                       originalCard.backHighlighted = card.backHighlighted; // undefined
                  } else {
                       originalCard.frontHighlighted = card.frontHighlighted; // undefined
                  }
              });

              if (!saved) {
                   console.error("Failed to save reset highlight via updateCardInOriginalDeck.");
                   // Optionally alert or indicate failure
              } else {
                   console.log("Reset highlight saved persistently.");
              }


             // Update button states
             updateHighlightButtons(isBackFace);
             console.log("Highlight button states updated after reset.");
             // No alert here, reset is implicit
        });


        // Add event listeners for highlighting to the *text content* elements
        cardFrontTextContent.addEventListener('mouseup', handleCardSelection);
        cardBackTextContent.addEventListener('mouseup', handleCardSelection);


        // --- Generic Image Handling Helpers ---

        // Helper function to prevent default drag behaviors
        function preventDefaults(e) {
             e.preventDefault();
             e.stopPropagation();
        }

        // Helper function to handle dropped files (specifically images)
        // This function is generic and calls the specific callback with the dataUrl
        function handleDrop(e, previewContainer, controlsElement, onImageLoadCallback) {
             console.log("Drop event handled on target:", e.target.id);
             const dt = e.dataTransfer;
             const files = dt.files;

             if (files.length) {
                 const file = files[0]; // Only process the first file
                  console.log("Dropped file:", file.name, file.type, "size:", file.size);
                 if (file.type.match('image.*')) {
                     handleImageFile(file, previewContainer, controlsElement, onImageLoadCallback); // Pass the specific callback
                 } else {
                     alert('Please drop an image file.');
                      console.warn("Dropped file is not an image (type:", file.type, ").");
                 }
             } else {
                  console.log("No files dropped.");
             }
        }

        // Helper function to handle image files (reads as Data URL)
        function handleImageFile(file, previewContainer, controlsElement, onImageLoadCallback) {
             console.log("Handling image file:", file.name);

             // Optional: Add size limit check
              const MAX_FILE_SIZE_MB = 5; // Example limit for images
              const MAX_FILE_SIZE_BYTES = MAX_FILE_SIZE_MB * 1024 * 1024;
              if (file.size > MAX_FILE_SIZE_BYTES) {
                   alert(`Image file is too large (${(file.size / 1024 / 1024).toFixed(2)} MB). Please select an image smaller than ${MAX_FILE_SIZE_MB} MB.`);
                   previewContainer.innerHTML = ''; // Clear any loading indicator
                   controlsElement.style.display = 'none';
                   if (onImageLoadCallback) { // Call callback with null to indicate removal or failure
                       onImageLoadCallback(null);
                       console.log("Image file too large, calling onImageLoadCallback(null)");
                   } else {
                       console.log("Image file too large, no onImageLoadCallback provided.");
                   }
                   console.warn("Image file too large.");
                   return; // Stop processing
              }


             const reader = new FileReader();

             reader.onloadstart = function() {
                  console.log("FileReader loading started.");
                 previewContainer.innerHTML = 'Loading image...'; // Show loading indicator
                 controlsElement.style.display = 'none'; // Hide controls during load
             }

             reader.onload = function(e) {
                  console.log("FileReader loading complete. Result type:", typeof e.target.result, "Size:", e.target.result ? e.target.result.length : 0);
                 // Call the callback first with the data URL
                 if (onImageLoadCallback) {
                      console.log("Calling onImageLoadCallback with Data URL.");
                      onImageLoadCallback(e.target.result);
                 }
                 // Then display the image in the preview using the Data URL
                 displayImage(e.target.result, previewContainer, controlsElement);
                  console.log("Image displayed in preview.");
             };

             reader.onerror = function() {
                 previewContainer.innerHTML = 'Error loading image.';
                 console.error("Error reading image file:", reader.error);
                 alert("Error loading image.");
                 // Call callback with null to signify failure? Depends on desired behavior.
                 // For now, just log/alert and leave previous state. If the callback clears state on null, it will work.
                 if (onImageLoadCallback) {
                      console.warn("FileReader error, calling onImageLoadCallback with null.");
                      onImageLoadCallback(null);
                 }
             }

             try {
                 reader.readAsDataURL(file); // Read the file as a Data URL
                  console.log("Calling readAsDataURL.");
             } catch (e) {
                 console.error("Error calling readAsDataURL:", e);
                 previewContainer.innerHTML = 'Error starting image load.';
                 alert("Error preparing image file.");
                 if (onImageLoadCallback) {
                      console.warn("Error starting readAsDataURL, calling onImageLoadCallback with null.");
                      onImageLoadCallback(null);
                 }
             }
        }

        // Helper function to handle image blobs (e.g., from clipboard)
         function handleImageBlob(blob, previewContainer, controlsElement, onImageLoadCallback) {
              console.log("Handling image blob (type:", blob.type, ", size:", blob.size, ")");
             // Treat blob like a file for reading purposes
             handleImageFile(blob, previewContainer, controlsElement, onImageLoadCallback);
         }


        // Helper function to display the image preview and controls in a given container
        // This function does NOT call the onImageLoadCallback, that happens in handleImageFile/Blob
        function displayImage(dataUrl, previewContainer, controlsElement) {
             console.log("Displaying image preview in:", previewContainer.id);
             previewContainer.innerHTML = ''; // Clear previous content
             const img = document.createElement('img');
             img.src = dataUrl;
             img.alt = "Image preview";
              // Add a specific class for preview images if needed,
              // or rely on the container class for styling
             // img.className = 'preview-thumbnail'; // Add a class if you want specific preview styling

              // Ensure the preview image itself is not clickable for zoom
              img.style.cursor = 'default';
              img.style.userSelect = 'none';


             previewContainer.appendChild(img);
             controlsElement.style.display = 'flex'; // Show controls
             console.log("Image preview updated and controls shown for:", previewContainer.id);
        }

        // Helper function to handle items from clipboard read() - primarily for button paste
        function handleClipboardItems(items, previewContainer, controlsElement, onImageChangeCallback) {
             console.log("Handling clipboard items from button click:", items);
             let imageFound = false;
             // Iterate through items to find an image
             for (const item of items) {
                  console.log("Clipboard item types:", item.types); // <-- Log the array of types

                  // Look for any image type within the item's types array (iterate item.types)
                 for (const type of item.types) { // <-- This loop correctly iterates through the types array
                     if (type.startsWith('image/')) {
                          console.log("Found image type:", type);
                           // Get the blob for this specific image type
                           item.getType(type).then(blob => {
                                console.log("Got image blob from clipboard item:", blob);
                                handleImageBlob(blob, previewContainer, controlsElement, onImageChangeCallback); // Process the blob
                           }).catch(err => {
                                console.warn(`Failed to get image data from clipboard type ${type} using navigator.clipboard.read():`, err); // Use 'type' variable here
                                // Log the specific error name/message
                               alert(`Failed to read from clipboard using the button. Error: ${err.message || 'Unknown error'}\n\nThis paste method often requires browser permissions or HTTPS. Please try pasting directly using Ctrl+V (or Cmd+V).`);
                               // If reading failed, we should probably reset the preview state
                               previewContainer.innerHTML = '';
                               controlsElement.style.display = 'none';
                               onImageChangeCallback(null); // Indicate removal or failure
                           });
                           imageFound = true; // Mark as found
                           // Break the inner loop (types) as we've found and are processing an image type for this item
                           break;
                     }
                 }
                  // If an image was found in the current item, we can stop processing subsequent items too
                  if (imageFound) {
                       break; // Break the outer loop (items)
                  }
             }
             if (!imageFound) {
                 alert('No image found in clipboard.');
                 console.log("No image type found in clipboard items from button click.");
             }
        }


        // --- Setup Functions for Image Inputs (Creation & Learning) ---

        // Function to set up drag/drop, remove, and paste button listeners for a specific input zone
        function setupImageInput(dropZone, previewContainer, controlsElement, removeBtn, pasteBtn, onImageChangeCallback) {
             console.log(`Setting up image input listeners for dropZone ID: ${dropZone.id}`);

             // Prevent default drag behaviors
             ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                  dropZone.addEventListener(eventName, preventDefaults, false);
             });

             // Highlight drop zone on drag over
             ['dragenter', 'dragover'].forEach(eventName => {
                  dropZone.addEventListener(eventName, () => {
                       dropZone.classList.add('active');
                  }, false);
             });

             // Remove highlight on drag leave or drop
             ['dragleave', 'drop'].forEach(eventName => {
                  dropZone.addEventListener(eventName, () => {
                       dropZone.classList.remove('active');
                  }, false);
             });

             // Handle dropped files
             dropZone.addEventListener('drop', (e) => {
                  console.log("Drop event on drop zone:", dropZone.id);
                  handleDrop(e, previewContainer, controlsElement, onImageChangeCallback); // Pass the specific callback
             }, false);

             // Handle remove button click
             if (removeBtn) { // Ensure remove button exists
                 removeBtn.addEventListener('click', () => {
                      console.log("Remove button clicked for:", dropZone.id);
                      previewContainer.innerHTML = ''; // Clear preview
                      controlsElement.style.display = 'none'; // Hide controls
                      onImageChangeCallback(null); // Call the specific callback with null to remove image
                      console.log("Image removed and callback executed for:", dropZone.id);
                 });
             } else {
                 console.warn("Remove button not found for dropZone ID:", dropZone.id);
             }


             // Handle paste button click (uses navigator.clipboard.read - may need permissions/HTTPS)
             if (pasteBtn) { // Ensure paste button exists
                 pasteBtn.addEventListener('click', () => {
                      console.log("Paste button clicked for:", dropZone.id);
                      // Use clipboard.read() if available (secure contexts/permissions)
                      if (navigator.clipboard && navigator.clipboard.read) {
                           console.log("Using navigator.clipboard.read()...");
                           navigator.clipboard.read().then(items => {
                               handleClipboardItems(items, previewContainer, controlsElement, onImageChangeCallback); // Pass the specific callback
                           }).catch(err => {
                               console.error('Failed to read clipboard using navigator.clipboard.read(): ', err);
                                // Log the specific error name/message
                               alert(`Failed to read from clipboard using the button. Error: ${err.message || 'Unknown error'}\n\nThis paste method often requires browser permissions or HTTPS. Please try pasting directly using Ctrl+V (or Cmd+V).`);
                                // Reset preview state if read failed
                                previewContainer.innerHTML = '';
                                controlsElement.style.display = 'none';
                                onImageChangeCallback(null); // Indicate removal or failure
                           });
                      } else {
                           // Fallback for contexts where clipboard.read is not available
                           alert('Clipboard reading using the button is not supported in this browser or context. Please try pasting directly using Ctrl+V.');
                           console.warn("navigator.clipboard.read() not supported.");
                           // Reset preview state as we can't proceed
                            previewContainer.innerHTML = '';
                            controlsElement.style.display = 'none';
                            onImageChangeCallback(null); // Indicate removal or failure
                      }
                 });
             } else {
                  console.warn("Paste button not found for dropZone ID:", pasteBtn ? pasteBtn.id : 'N/A', " for dropZone:", dropZone.id);
             }
        }


        // Global paste listener for the document (handles Ctrl+V, browser's paste command)
        document.addEventListener('paste', (e) => {
             console.log('Global Paste event detected:', e);
             if (e.clipboardData && e.clipboardData.items) {
                  console.log('ClipboardData available on paste event.');
                 // Determine which drop zone (if any) is focused or the closest ancestor
                 // Check for focus on the drop zone itself or any element inside it (like the p or button)
                 const activeElement = document.activeElement;
                 console.log('Active Element:', activeElement);

                 // Use closest() on the active element to find if it's inside one of our specific drop zones
                 const closestCreationFront = activeElement.closest('#creationFrontImageDropZone');
                 const closestCreationBack = activeElement.closest('#creationBackImageDropZone');
                 const closestLearningFront = activeElement.closest('#learningFrontImageDropZone');
                 const closestLearningBack = activeElement.closest('#learningBackImageDropZone');

                 console.log("Closest drop zones found:", { closestCreationFront, closestCreationBack, closestLearningFront, closestLearningBack });

                 let previewContainer = null;
                 let controlsElement = null;
                 let onImageChangeCallback = null;
                 let handled = false; // Flag to indicate if the paste was handled by our logic

                 if (closestCreationFront) {
                      previewContainer = creationFrontImagePreviewContainer;
                      controlsElement = creationFrontImageControls;
                      onImageChangeCallback = (dataUrl) => { creationFrontImage = dataUrl; }; // Simple assignment for creation
                      handled = true;
                      console.log("Paste target: Creation Front Image Drop Zone (via global paste)");
                 } else if (closestCreationBack) {
                      previewContainer = creationBackImagePreviewContainer;
                      controlsElement = creationBackImageControls;
                      onImageChangeCallback = (dataUrl) => { creationBackImage = dataUrl; }; // Simple assignment for creation
                      handled = true;
                      console.log("Paste target: Creation Back Image Drop Zone (via global paste)");
                 } else if (closestLearningFront) {
                    // Handle paste in learning section front drop zone
                     if (!currentDeck || currentDeck.cards.length === 0 || currentDeck.shuffledIndices.length === 0) {
                          console.warn("Paste attempted in learning section image input without a loaded card. Not handling.");
                          // Do NOT prevent default if no deck/card is loaded.
                          // Let the default paste happen (e.g., paste text into text fields).
                          handled = false; // Ensure handled is false
                          return; // Exit listener
                     }
                      const actualCardIndex = currentDeck.shuffledIndices[currentCardIndex];
                      const card = currentDeck.cards[actualCardIndex]; // Get the current card object


                      previewContainer = learningFrontImagePreviewContainer;
                      controlsElement = learningFrontImageControls;
                       // Define the callback logic specifically for learning section images
                      onImageChangeCallback = (dataUrl) => {
                           console.log("Learning Front Image Paste Callback (Global Paste):", dataUrl ? "Image received" : "Image removed (null)");
                           if (dataUrl === null) {
                                card.frontImage = undefined; // Set to undefined in-memory
                           } else {
                                card.frontImage = dataUrl; // Update in-memory card object
                           }

                          // Save the change persistently using the helper
                          const saved = updateCardInOriginalDeck(card, (originalCard) => {
                              originalCard.frontImage = card.frontImage; // Copy from the (potentially updated) in-memory card
                          });

                          if (saved) {
                               console.log("Learning front image saved successfully. Re-displaying card.");
                              // If save successful, re-render the main card face to show the image
                              displayCurrentCard(); // This will update the main card display
                              // UI preview is already updated by handleImageFile/Blob via displayImage()
                          } else {
                              console.error("Failed to save learning front image after paste.");
                              alert("Error saving image to deck after paste.");
                               // Revert the change in memory and UI preview if save failed
                              card.frontImage = undefined; // Revert in-memory change
                              learningFrontImagePreviewContainer.innerHTML = ''; // Clear preview
                              learningFrontImageControls.style.display = 'none'; // Hide controls
                          }
                      };
                      handled = true;
                      console.log("Paste target: Learning Front Image Drop Zone (via global paste)");

                 } else if (closestLearningBack) {
                     // Handle paste in learning section back drop zone
                     if (!currentDeck || currentDeck.cards.length === 0 || currentDeck.shuffledIndices.length === 0) {
                          console.warn("Paste attempted in learning section image input without a loaded card. Not handling.");
                          handled = false; // Ensure handled is false
                          return; // Exit listener
                     }
                      const actualCardIndex = currentDeck.shuffledIndices[currentCardIndex];
                      const card = currentDeck.cards[actualCardIndex]; // Get the current card object


                      previewContainer = learningBackImagePreviewContainer;
                      controlsElement = learningBackImageControls;
                       // Define the callback logic specifically for learning section images
                      onImageChangeCallback = (dataUrl) => {
                           console.log("Learning Back Image Paste Callback (Global Paste):", dataUrl ? "Image received" : "Image removed (null)");
                           if (dataUrl === null) {
                                card.backImage = undefined; // Set to undefined in-memory
                           } else {
                                card.backImage = dataUrl; // Update in-memory card object
                           }

                          // Save the change persistently using the helper
                          const saved = updateCardInOriginalDeck(card, (originalCard) => {
                              originalCard.backImage = card.backImage; // Copy from the (potentially updated) in-memory card
                          });

                          if (saved) {
                               console.log("Learning back image saved successfully. Re-displaying card.");
                              // If save successful, re-render the main card face to show the image
                              displayCurrentCard(); // This will update the main card display
                               // UI preview is already updated by handleImageFile/Blob via displayImage()
                          } else {
                              console.error("Failed to save learning back image after paste.");
                              alert("Error saving image to deck after paste.");
                               // Revert the change in memory and UI preview if save failed
                              card.backImage = undefined; // Revert in-memory change
                              learningBackImagePreviewContainer.innerHTML = ""; // Clear preview
                              learningBackImageControls.style.display = 'none'; // Hide controls
                          }
                      };
                      handled = true;
                      console.log("Paste target: Learning Back Image Drop Zone (via global paste)");
                 }


                 if (handled && previewContainer && controlsElement && onImageChangeCallback) {
                     console.log("Attempting to handle global paste data as image for the detected target.");
                     let imageFoundAndHandled = false;
                     for (let i = 0; i < e.clipboardData.items.length; i++) {
                         const item = e.clipboardData.items[i];
                          // Look for any image type
                         if (item.type.startsWith('image/')) {
                             const blob = item.getAsFile();
                              if (blob) {
                                   console.log("Image blob found via global paste. Processing with handleImageBlob.");
                                   handleImageBlob(blob, previewContainer, controlsElement, onImageChangeCallback);
                                   e.preventDefault(); // Prevent the default paste action only if an image is found and handled by our logic
                                   imageFoundAndHandled = true;
                                   break; // Stop processing items after finding and handling an image
                              } else {
                                   console.warn("Clipboard item type is image/* but getAsFile() returned null during global paste.");
                              }
                         }
                     }
                      if (!imageFoundAndHandled) {
                           console.log("Global paste event detected with items, but no image was found or handled by the specific target. Allowing default paste.");
                           // Do NOT prevent default if nothing was handled, let browser handle text paste etc.
                      } else {
                           console.log("Global paste event successfully handled as image.");
                      }
                 } else {
                     // This case means no relevant drop zone was targeted.
                      console.log("Global paste event did not target a specific image drop zone. Allowing default paste.");
                 }
             } else {
                  console.log('ClipboardData not available on paste event.');
             }
        });


         // --- Image Modal Logic ---

         function openImageModal(imageUrl, captionText) {
              console.log("Opening image modal:", { imageUrl, captionText });
              modalImage.src = imageUrl;
              modalCaption.textContent = captionText || '';
              imageModal.classList.add('visible'); // Use class to show/hide
         }

         function closeImageModal() {
              console.log("Closing image modal.");
              imageModal.classList.remove('visible');
              modalImage.src = ''; // Clear src when hidden
              modalCaption.textContent = ''; // Clear caption
         }

         // Close the modal when the close button is clicked
         modalClose.addEventListener('click', closeImageModal);

         // Close the modal when clicking anywhere on the overlay (but not the image itself)
         imageModal.addEventListener('click', (e) => {
             if (e.target === imageModal) { // Check if the click target is the modal background itself
                 closeImageModal();
             }
         });
         // Optional: Close with Escape key
         document.addEventListener('keydown', (e) => {
             if (e.key === 'Escape' && imageModal.classList.contains('visible')) {
                 closeImageModal();
             }
         });

        // Helper function to remove previous click listeners from images within a container
        // This is called *before* adding the image element in displayCurrentCard
        function removeImageClickListeners(containerElement) {
             console.log("Removing image click listeners (if any) from:", containerElement.id);
            // Find all img elements within the container
            const images = containerElement.querySelectorAll('img');
            images.forEach(img => {
                // To reliably remove listeners attached via addEventListener
                // without having access to the *specific* listener function instance,
                // cloning and replacing the node is a common technique.
                // However, since displayCurrentCard clears the container's innerHTML anyway,
                // the old elements (and their listeners) are removed from the DOM.
                // We just need to ensure we add the *new* listeners *after* creating the new img elements.
                // This function is primarily for safety/clarity before clearing.
                // Let's ensure we clear the innerHTML first in displayCurrentCard.
                 if (img && img.parentNode === containerElement) {
                      // We are replacing the content fully in displayCurrentCard, so removing explicitly here is less critical
                      // than ensuring new listeners are added. However, if we were just *updating* the src,
                      // explicit removal or using event delegation would be better.
                      // Given the current display approach (clear and rebuild), just ensuring the container is empty before appending is key.
                      // This function can remain minimal or serve as a reminder.
                      // Let's just ensure the container is cleared in displayCurrentCard before adding new elements.
                      console.log("Removing potentially old image elements from container (as displayCurrentCard will replace content):", containerElement.id);
                      // The clearing of innerHTML happens in displayCurrentCard. No need to explicitly remove here.
                 }
            });
        }


        // --- Initialization ---

        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM fully loaded.");
            populateFolderSelect();
            populateDeckSelect();

             resetLearningArea(); // Ensure learning UI is hidden initially

             // Set up image handling in the creation section
             setupImageInput(creationFrontImageDropZone, creationFrontImagePreviewContainer, creationFrontImageControls, removeCreationFrontImageBtn, creationFrontImagePasteBtn, (dataUrl) => { creationFrontImage = dataUrl; });
             setupImageInput(creationBackImageDropZone, creationBackImagePreviewContainer, creationBackImageControls, removeCreationBackImageBtn, creationBackImagePasteBtn, (dataUrl) => { creationBackImage = dataUrl; });

             // Set up image handling in the learning section
             setupImageInput(learningFrontImageDropZone, learningFrontImagePreviewContainer, learningFrontImageControls, removeLearningFrontImageBtn, learningFrontImagePasteBtn, (dataUrl) => {
                  // Callback for learning section front image input
                  console.log("Learning Front Image Input Callback:", dataUrl ? "Image received" : "Image removed (null)");
                  if (!currentDeck || currentDeck.cards.length === 0 || currentDeck.shuffledIndices.length === 0) {
                       console.error("Attempted to set learning front image without a loaded card.");
                       alert("Error: Cannot set image on current card. Please reload deck.");
                       // Revert the UI preview that handleImageFile/Blob might have set if we can't save
                       learningFrontImagePreviewContainer.innerHTML = "";
                       learningFrontImageControls.style.display = 'none';
                       return;
                  }
                   const actualCardIndex = currentDeck.shuffledIndices[currentCardIndex];
                   const card = currentDeck.cards[actualCardIndex]; // Get the in-memory card object

                  card.frontImage = dataUrl === null ? undefined : dataUrl; // Update the in-memory object (undefined if removed)

                  // Save the persistent change to localStorage
                  const saved = updateCardInOriginalDeck(card, (originalCard) => {
                       originalCard.frontImage = card.frontImage; // Copy from the in-memory card
                  });

                  if (saved) {
                       console.log("Learning front image saved successfully. Re-displaying card.");
                       // If save successful, re-render the main card face to show the image
                       displayCurrentCard(); // This will update the main card display
                       // UI preview is already updated by handleImageFile/Blob via displayImage()
                  } else {
                       // If save failed, revert the in-memory change and the UI preview
                       console.error("Failed to save learning front image.");
                       alert("Error saving image to deck.");
                       card.frontImage = undefined; // Revert in-memory change
                       learningFrontImagePreviewContainer.innerHTML = ""; // Clear preview
                       learningFrontImageControls.style.display = 'none'; // Hide controls
                  }
             });

             setupImageInput(learningBackImageDropZone, learningBackImagePreviewContainer, learningBackImageControls, removeLearningBackImageBtn, learningBackImagePasteBtn, (dataUrl) => {
                  // Callback for learning section back image input
                   console.log("Learning Back Image Input Callback:", dataUrl ? "Image received" : "Image removed (null)");
                   if (!currentDeck || currentDeck.cards.length === 0 || currentDeck.shuffledIndices.length === 0) {
                       console.error("Attempted to set learning back image without a loaded card.");
                       alert("Error: Cannot set image on current card. Please reload deck.");
                        // Revert the UI preview that handleImageFile/Blob might have set if we can't save
                       learningBackImagePreviewContainer.innerHTML = "";
                       learningBackImageControls.style.display = 'none';
                       return;
                  }
                   const actualCardIndex = currentDeck.shuffledIndices[currentCardIndex];
                   const card = currentDeck.cards[actualCardIndex]; // Get the in-memory card object

                  card.backImage = dataUrl === null ? undefined : dataUrl; // Update the in-memory object (undefined if removed)

                  // Save the persistent change to localStorage
                  const saved = updateCardInOriginalDeck(card, (originalCard) => {
                       originalCard.backImage = card.backImage; // Copy from the in-memory card
                  });

                  if (saved) {
                       console.log("Learning back image saved successfully. Re-displaying card.");
                       // If save successful, re-render the main card face to show the image
                       displayCurrentCard(); // This will update the main card display
                        // UI preview is already updated by handleImageFile/Blob via displayImage()
                  } else {
                       // If save failed, revert the in-memory change and the UI preview
                       console.error("Failed to save learning back image.");
                       alert("Error saving image to deck.");
                       card.backImage = undefined; // Revert in-memory change
                       learningBackImagePreviewContainer.innerHTML = ""; // Clear preview
                       learningBackImageControls.style.display = 'none'; // Hide controls
                  }
             });


        });

        // Add event listener to deckSelect to update load/delete/export button state when selection changes
        deckSelect.addEventListener('change', () => {
             console.log("Deck select changed. Value:", deckSelect.value);
             const selectedValue = deckSelect.value;
             // Load button enabled if anything other than the default empty option is selected
              loadDeckBtn.disabled = (selectedValue === "");
             // Delete button enabled if a regular deck is selected (value is not empty and not ALL_FAVORITES_KEY)
             deleteDeckBtn.disabled = (selectedValue === "" || selectedValue === ALL_FAVORITES_KEY);
             // Export button is disabled initially and enabled when a *regular* deck is *loaded*
             // Leave exportCurrentDeckBtn state management to loadDeck and resetLearningArea for clarity.
        });


    </script>
</body>
</html>
